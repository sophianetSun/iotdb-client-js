/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import Int64 = require("node-int64");
import * as thrift from "thrift";
import * as TSExecuteStatementReq from "./TSExecuteStatementReq";
import * as TSExecuteStatementResp from "./TSExecuteStatementResp";
import * as TSRawDataQueryReq from "./TSRawDataQueryReq";
import * as TSLastDataQueryReq from "./TSLastDataQueryReq";
import * as TSFastLastDataQueryForOneDeviceReq from "./TSFastLastDataQueryForOneDeviceReq";
import * as TSAggregationQueryReq from "./TSAggregationQueryReq";
import * as TSGroupByQueryIntervalReq from "./TSGroupByQueryIntervalReq";
import * as TSFetchResultsReq from "./TSFetchResultsReq";
import * as TSFetchResultsResp from "./TSFetchResultsResp";
import * as TSOpenSessionReq from "./TSOpenSessionReq";
import * as TSOpenSessionResp from "./TSOpenSessionResp";
import * as TSCloseSessionReq from "./TSCloseSessionReq";
import * as org_apache_iotdb_common_rpc_thrift from "./../../../common/rpc/thrift";
import * as TSExecuteBatchStatementReq from "./TSExecuteBatchStatementReq";
import * as TSFetchMetadataReq from "./TSFetchMetadataReq";
import * as TSFetchMetadataResp from "./TSFetchMetadataResp";
import * as TSCancelOperationReq from "./TSCancelOperationReq";
import * as TSCloseOperationReq from "./TSCloseOperationReq";
import * as TSGetTimeZoneResp from "./TSGetTimeZoneResp";
import * as TSSetTimeZoneReq from "./TSSetTimeZoneReq";
import * as ServerProperties from "./ServerProperties";
import * as TSCreateTimeseriesReq from "./TSCreateTimeseriesReq";
import * as TSCreateAlignedTimeseriesReq from "./TSCreateAlignedTimeseriesReq";
import * as TSCreateMultiTimeseriesReq from "./TSCreateMultiTimeseriesReq";
import * as TSInsertRecordReq from "./TSInsertRecordReq";
import * as TSInsertStringRecordReq from "./TSInsertStringRecordReq";
import * as TSInsertTabletReq from "./TSInsertTabletReq";
import * as TSInsertTabletsReq from "./TSInsertTabletsReq";
import * as TSInsertRecordsReq from "./TSInsertRecordsReq";
import * as TSInsertRecordsOfOneDeviceReq from "./TSInsertRecordsOfOneDeviceReq";
import * as TSInsertStringRecordsOfOneDeviceReq from "./TSInsertStringRecordsOfOneDeviceReq";
import * as TSInsertStringRecordsReq from "./TSInsertStringRecordsReq";
import * as TSDeleteDataReq from "./TSDeleteDataReq";
import * as TSCreateSchemaTemplateReq from "./TSCreateSchemaTemplateReq";
import * as TSAppendSchemaTemplateReq from "./TSAppendSchemaTemplateReq";
import * as TSPruneSchemaTemplateReq from "./TSPruneSchemaTemplateReq";
import * as TSQueryTemplateReq from "./TSQueryTemplateReq";
import * as TSQueryTemplateResp from "./TSQueryTemplateResp";
import * as TSSetSchemaTemplateReq from "./TSSetSchemaTemplateReq";
import * as TSUnsetSchemaTemplateReq from "./TSUnsetSchemaTemplateReq";
import * as TSDropSchemaTemplateReq from "./TSDropSchemaTemplateReq";
import * as TCreateTimeseriesUsingSchemaTemplateReq from "./TCreateTimeseriesUsingSchemaTemplateReq";
import * as TSyncIdentityInfo from "./TSyncIdentityInfo";
import * as TSyncTransportMetaInfo from "./TSyncTransportMetaInfo";
import * as TPipeTransferReq from "./TPipeTransferReq";
import * as TPipeTransferResp from "./TPipeTransferResp";
import * as TPipeSubscribeReq from "./TPipeSubscribeReq";
import * as TPipeSubscribeResp from "./TPipeSubscribeResp";
import * as TSBackupConfigurationResp from "./TSBackupConfigurationResp";
import * as TSConnectionInfoResp from "./TSConnectionInfoResp";
export interface IExecuteQueryStatementV2ArgsArgs {
    req: TSExecuteStatementReq.TSExecuteStatementReq;
}
export class ExecuteQueryStatementV2Args {
    public req: TSExecuteStatementReq.TSExecuteStatementReq;
    constructor(args: IExecuteQueryStatementV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteQueryStatementV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteQueryStatementV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1: TSExecuteStatementReq.TSExecuteStatementReq = TSExecuteStatementReq.TSExecuteStatementReq.read(input);
                        _args.req = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteQueryStatementV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteQueryStatementV2Args from input");
        }
    }
}
export interface IExecuteUpdateStatementV2ArgsArgs {
    req: TSExecuteStatementReq.TSExecuteStatementReq;
}
export class ExecuteUpdateStatementV2Args {
    public req: TSExecuteStatementReq.TSExecuteStatementReq;
    constructor(args: IExecuteUpdateStatementV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteUpdateStatementV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteUpdateStatementV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_2: TSExecuteStatementReq.TSExecuteStatementReq = TSExecuteStatementReq.TSExecuteStatementReq.read(input);
                        _args.req = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteUpdateStatementV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteUpdateStatementV2Args from input");
        }
    }
}
export interface IExecuteStatementV2ArgsArgs {
    req: TSExecuteStatementReq.TSExecuteStatementReq;
}
export class ExecuteStatementV2Args {
    public req: TSExecuteStatementReq.TSExecuteStatementReq;
    constructor(args: IExecuteStatementV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteStatementV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteStatementV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_3: TSExecuteStatementReq.TSExecuteStatementReq = TSExecuteStatementReq.TSExecuteStatementReq.read(input);
                        _args.req = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteStatementV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteStatementV2Args from input");
        }
    }
}
export interface IExecuteRawDataQueryV2ArgsArgs {
    req: TSRawDataQueryReq.TSRawDataQueryReq;
}
export class ExecuteRawDataQueryV2Args {
    public req: TSRawDataQueryReq.TSRawDataQueryReq;
    constructor(args: IExecuteRawDataQueryV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteRawDataQueryV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteRawDataQueryV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_4: TSRawDataQueryReq.TSRawDataQueryReq = TSRawDataQueryReq.TSRawDataQueryReq.read(input);
                        _args.req = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteRawDataQueryV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteRawDataQueryV2Args from input");
        }
    }
}
export interface IExecuteLastDataQueryV2ArgsArgs {
    req: TSLastDataQueryReq.TSLastDataQueryReq;
}
export class ExecuteLastDataQueryV2Args {
    public req: TSLastDataQueryReq.TSLastDataQueryReq;
    constructor(args: IExecuteLastDataQueryV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteLastDataQueryV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteLastDataQueryV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_5: TSLastDataQueryReq.TSLastDataQueryReq = TSLastDataQueryReq.TSLastDataQueryReq.read(input);
                        _args.req = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteLastDataQueryV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteLastDataQueryV2Args from input");
        }
    }
}
export interface IExecuteFastLastDataQueryForOneDeviceV2ArgsArgs {
    req: TSFastLastDataQueryForOneDeviceReq.TSFastLastDataQueryForOneDeviceReq;
}
export class ExecuteFastLastDataQueryForOneDeviceV2Args {
    public req: TSFastLastDataQueryForOneDeviceReq.TSFastLastDataQueryForOneDeviceReq;
    constructor(args: IExecuteFastLastDataQueryForOneDeviceV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteFastLastDataQueryForOneDeviceV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteFastLastDataQueryForOneDeviceV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_6: TSFastLastDataQueryForOneDeviceReq.TSFastLastDataQueryForOneDeviceReq = TSFastLastDataQueryForOneDeviceReq.TSFastLastDataQueryForOneDeviceReq.read(input);
                        _args.req = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteFastLastDataQueryForOneDeviceV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteFastLastDataQueryForOneDeviceV2Args from input");
        }
    }
}
export interface IExecuteAggregationQueryV2ArgsArgs {
    req: TSAggregationQueryReq.TSAggregationQueryReq;
}
export class ExecuteAggregationQueryV2Args {
    public req: TSAggregationQueryReq.TSAggregationQueryReq;
    constructor(args: IExecuteAggregationQueryV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteAggregationQueryV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteAggregationQueryV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_7: TSAggregationQueryReq.TSAggregationQueryReq = TSAggregationQueryReq.TSAggregationQueryReq.read(input);
                        _args.req = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteAggregationQueryV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteAggregationQueryV2Args from input");
        }
    }
}
export interface IExecuteGroupByQueryIntervalQueryArgsArgs {
    req: TSGroupByQueryIntervalReq.TSGroupByQueryIntervalReq;
}
export class ExecuteGroupByQueryIntervalQueryArgs {
    public req: TSGroupByQueryIntervalReq.TSGroupByQueryIntervalReq;
    constructor(args: IExecuteGroupByQueryIntervalQueryArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteGroupByQueryIntervalQueryArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteGroupByQueryIntervalQueryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_8: TSGroupByQueryIntervalReq.TSGroupByQueryIntervalReq = TSGroupByQueryIntervalReq.TSGroupByQueryIntervalReq.read(input);
                        _args.req = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteGroupByQueryIntervalQueryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteGroupByQueryIntervalQueryArgs from input");
        }
    }
}
export interface IFetchResultsV2ArgsArgs {
    req: TSFetchResultsReq.TSFetchResultsReq;
}
export class FetchResultsV2Args {
    public req: TSFetchResultsReq.TSFetchResultsReq;
    constructor(args: IFetchResultsV2ArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchResultsV2Args");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchResultsV2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_9: TSFetchResultsReq.TSFetchResultsReq = TSFetchResultsReq.TSFetchResultsReq.read(input);
                        _args.req = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FetchResultsV2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FetchResultsV2Args from input");
        }
    }
}
export interface IOpenSessionArgsArgs {
    req: TSOpenSessionReq.TSOpenSessionReq;
}
export class OpenSessionArgs {
    public req: TSOpenSessionReq.TSOpenSessionReq;
    constructor(args: IOpenSessionArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("OpenSessionArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): OpenSessionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_10: TSOpenSessionReq.TSOpenSessionReq = TSOpenSessionReq.TSOpenSessionReq.read(input);
                        _args.req = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new OpenSessionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read OpenSessionArgs from input");
        }
    }
}
export interface ICloseSessionArgsArgs {
    req: TSCloseSessionReq.TSCloseSessionReq;
}
export class CloseSessionArgs {
    public req: TSCloseSessionReq.TSCloseSessionReq;
    constructor(args: ICloseSessionArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseSessionArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseSessionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_11: TSCloseSessionReq.TSCloseSessionReq = TSCloseSessionReq.TSCloseSessionReq.read(input);
                        _args.req = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CloseSessionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CloseSessionArgs from input");
        }
    }
}
export interface IExecuteStatementArgsArgs {
    req: TSExecuteStatementReq.TSExecuteStatementReq;
}
export class ExecuteStatementArgs {
    public req: TSExecuteStatementReq.TSExecuteStatementReq;
    constructor(args: IExecuteStatementArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteStatementArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteStatementArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_12: TSExecuteStatementReq.TSExecuteStatementReq = TSExecuteStatementReq.TSExecuteStatementReq.read(input);
                        _args.req = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteStatementArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteStatementArgs from input");
        }
    }
}
export interface IExecuteBatchStatementArgsArgs {
    req: TSExecuteBatchStatementReq.TSExecuteBatchStatementReq;
}
export class ExecuteBatchStatementArgs {
    public req: TSExecuteBatchStatementReq.TSExecuteBatchStatementReq;
    constructor(args: IExecuteBatchStatementArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteBatchStatementArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteBatchStatementArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_13: TSExecuteBatchStatementReq.TSExecuteBatchStatementReq = TSExecuteBatchStatementReq.TSExecuteBatchStatementReq.read(input);
                        _args.req = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteBatchStatementArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteBatchStatementArgs from input");
        }
    }
}
export interface IExecuteQueryStatementArgsArgs {
    req: TSExecuteStatementReq.TSExecuteStatementReq;
}
export class ExecuteQueryStatementArgs {
    public req: TSExecuteStatementReq.TSExecuteStatementReq;
    constructor(args: IExecuteQueryStatementArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteQueryStatementArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteQueryStatementArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_14: TSExecuteStatementReq.TSExecuteStatementReq = TSExecuteStatementReq.TSExecuteStatementReq.read(input);
                        _args.req = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteQueryStatementArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteQueryStatementArgs from input");
        }
    }
}
export interface IExecuteUpdateStatementArgsArgs {
    req: TSExecuteStatementReq.TSExecuteStatementReq;
}
export class ExecuteUpdateStatementArgs {
    public req: TSExecuteStatementReq.TSExecuteStatementReq;
    constructor(args: IExecuteUpdateStatementArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteUpdateStatementArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteUpdateStatementArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_15: TSExecuteStatementReq.TSExecuteStatementReq = TSExecuteStatementReq.TSExecuteStatementReq.read(input);
                        _args.req = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteUpdateStatementArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteUpdateStatementArgs from input");
        }
    }
}
export interface IFetchResultsArgsArgs {
    req: TSFetchResultsReq.TSFetchResultsReq;
}
export class FetchResultsArgs {
    public req: TSFetchResultsReq.TSFetchResultsReq;
    constructor(args: IFetchResultsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchResultsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchResultsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_16: TSFetchResultsReq.TSFetchResultsReq = TSFetchResultsReq.TSFetchResultsReq.read(input);
                        _args.req = value_16;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FetchResultsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FetchResultsArgs from input");
        }
    }
}
export interface IFetchMetadataArgsArgs {
    req: TSFetchMetadataReq.TSFetchMetadataReq;
}
export class FetchMetadataArgs {
    public req: TSFetchMetadataReq.TSFetchMetadataReq;
    constructor(args: IFetchMetadataArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchMetadataArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchMetadataArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_17: TSFetchMetadataReq.TSFetchMetadataReq = TSFetchMetadataReq.TSFetchMetadataReq.read(input);
                        _args.req = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FetchMetadataArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FetchMetadataArgs from input");
        }
    }
}
export interface ICancelOperationArgsArgs {
    req: TSCancelOperationReq.TSCancelOperationReq;
}
export class CancelOperationArgs {
    public req: TSCancelOperationReq.TSCancelOperationReq;
    constructor(args: ICancelOperationArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelOperationArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelOperationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_18: TSCancelOperationReq.TSCancelOperationReq = TSCancelOperationReq.TSCancelOperationReq.read(input);
                        _args.req = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CancelOperationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CancelOperationArgs from input");
        }
    }
}
export interface ICloseOperationArgsArgs {
    req: TSCloseOperationReq.TSCloseOperationReq;
}
export class CloseOperationArgs {
    public req: TSCloseOperationReq.TSCloseOperationReq;
    constructor(args: ICloseOperationArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseOperationArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseOperationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_19: TSCloseOperationReq.TSCloseOperationReq = TSCloseOperationReq.TSCloseOperationReq.read(input);
                        _args.req = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CloseOperationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CloseOperationArgs from input");
        }
    }
}
export interface IGetTimeZoneArgsArgs {
    sessionId: number | Int64;
}
export class GetTimeZoneArgs {
    public sessionId: Int64;
    constructor(args: IGetTimeZoneArgsArgs) {
        if (args != null && args.sessionId != null) {
            if (typeof args.sessionId === "number") {
                this.sessionId = new Int64(args.sessionId);
            }
            else {
                this.sessionId = args.sessionId;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sessionId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTimeZoneArgs");
        if (this.sessionId != null) {
            output.writeFieldBegin("sessionId", thrift.Thrift.Type.I64, 1);
            output.writeI64(this.sessionId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTimeZoneArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_20: Int64 = input.readI64();
                        _args.sessionId = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.sessionId !== undefined) {
            return new GetTimeZoneArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetTimeZoneArgs from input");
        }
    }
}
export interface ISetTimeZoneArgsArgs {
    req: TSSetTimeZoneReq.TSSetTimeZoneReq;
}
export class SetTimeZoneArgs {
    public req: TSSetTimeZoneReq.TSSetTimeZoneReq;
    constructor(args: ISetTimeZoneArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetTimeZoneArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetTimeZoneArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_21: TSSetTimeZoneReq.TSSetTimeZoneReq = TSSetTimeZoneReq.TSSetTimeZoneReq.read(input);
                        _args.req = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SetTimeZoneArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetTimeZoneArgs from input");
        }
    }
}
export interface IGetPropertiesArgsArgs {
}
export class GetPropertiesArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetPropertiesArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetPropertiesArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetPropertiesArgs();
    }
}
export interface ISetStorageGroupArgsArgs {
    sessionId: number | Int64;
    storageGroup: string;
}
export class SetStorageGroupArgs {
    public sessionId: Int64;
    public storageGroup: string;
    constructor(args: ISetStorageGroupArgsArgs) {
        if (args != null && args.sessionId != null) {
            if (typeof args.sessionId === "number") {
                this.sessionId = new Int64(args.sessionId);
            }
            else {
                this.sessionId = args.sessionId;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sessionId] is unset!");
        }
        if (args != null && args.storageGroup != null) {
            this.storageGroup = args.storageGroup;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[storageGroup] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetStorageGroupArgs");
        if (this.sessionId != null) {
            output.writeFieldBegin("sessionId", thrift.Thrift.Type.I64, 1);
            output.writeI64(this.sessionId);
            output.writeFieldEnd();
        }
        if (this.storageGroup != null) {
            output.writeFieldBegin("storageGroup", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.storageGroup);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetStorageGroupArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_22: Int64 = input.readI64();
                        _args.sessionId = value_22;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_23: string = input.readString();
                        _args.storageGroup = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.sessionId !== undefined && _args.storageGroup !== undefined) {
            return new SetStorageGroupArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetStorageGroupArgs from input");
        }
    }
}
export interface ICreateTimeseriesArgsArgs {
    req: TSCreateTimeseriesReq.TSCreateTimeseriesReq;
}
export class CreateTimeseriesArgs {
    public req: TSCreateTimeseriesReq.TSCreateTimeseriesReq;
    constructor(args: ICreateTimeseriesArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateTimeseriesArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateTimeseriesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_24: TSCreateTimeseriesReq.TSCreateTimeseriesReq = TSCreateTimeseriesReq.TSCreateTimeseriesReq.read(input);
                        _args.req = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateTimeseriesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateTimeseriesArgs from input");
        }
    }
}
export interface ICreateAlignedTimeseriesArgsArgs {
    req: TSCreateAlignedTimeseriesReq.TSCreateAlignedTimeseriesReq;
}
export class CreateAlignedTimeseriesArgs {
    public req: TSCreateAlignedTimeseriesReq.TSCreateAlignedTimeseriesReq;
    constructor(args: ICreateAlignedTimeseriesArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateAlignedTimeseriesArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateAlignedTimeseriesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_25: TSCreateAlignedTimeseriesReq.TSCreateAlignedTimeseriesReq = TSCreateAlignedTimeseriesReq.TSCreateAlignedTimeseriesReq.read(input);
                        _args.req = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateAlignedTimeseriesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateAlignedTimeseriesArgs from input");
        }
    }
}
export interface ICreateMultiTimeseriesArgsArgs {
    req: TSCreateMultiTimeseriesReq.TSCreateMultiTimeseriesReq;
}
export class CreateMultiTimeseriesArgs {
    public req: TSCreateMultiTimeseriesReq.TSCreateMultiTimeseriesReq;
    constructor(args: ICreateMultiTimeseriesArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateMultiTimeseriesArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateMultiTimeseriesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_26: TSCreateMultiTimeseriesReq.TSCreateMultiTimeseriesReq = TSCreateMultiTimeseriesReq.TSCreateMultiTimeseriesReq.read(input);
                        _args.req = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateMultiTimeseriesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateMultiTimeseriesArgs from input");
        }
    }
}
export interface IDeleteTimeseriesArgsArgs {
    sessionId: number | Int64;
    path: Array<string>;
}
export class DeleteTimeseriesArgs {
    public sessionId: Int64;
    public path: Array<string>;
    constructor(args: IDeleteTimeseriesArgsArgs) {
        if (args != null && args.sessionId != null) {
            if (typeof args.sessionId === "number") {
                this.sessionId = new Int64(args.sessionId);
            }
            else {
                this.sessionId = args.sessionId;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sessionId] is unset!");
        }
        if (args != null && args.path != null) {
            this.path = args.path;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[path] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteTimeseriesArgs");
        if (this.sessionId != null) {
            output.writeFieldBegin("sessionId", thrift.Thrift.Type.I64, 1);
            output.writeI64(this.sessionId);
            output.writeFieldEnd();
        }
        if (this.path != null) {
            output.writeFieldBegin("path", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.path.length);
            this.path.forEach((value_27: string): void => {
                output.writeString(value_27);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteTimeseriesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_28: Int64 = input.readI64();
                        _args.sessionId = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_29: Array<string> = new Array<string>();
                        const metadata_1: thrift.TList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_30: string = input.readString();
                            value_29.push(value_30);
                        }
                        input.readListEnd();
                        _args.path = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.sessionId !== undefined && _args.path !== undefined) {
            return new DeleteTimeseriesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteTimeseriesArgs from input");
        }
    }
}
export interface IDeleteStorageGroupsArgsArgs {
    sessionId: number | Int64;
    storageGroup: Array<string>;
}
export class DeleteStorageGroupsArgs {
    public sessionId: Int64;
    public storageGroup: Array<string>;
    constructor(args: IDeleteStorageGroupsArgsArgs) {
        if (args != null && args.sessionId != null) {
            if (typeof args.sessionId === "number") {
                this.sessionId = new Int64(args.sessionId);
            }
            else {
                this.sessionId = args.sessionId;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sessionId] is unset!");
        }
        if (args != null && args.storageGroup != null) {
            this.storageGroup = args.storageGroup;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[storageGroup] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteStorageGroupsArgs");
        if (this.sessionId != null) {
            output.writeFieldBegin("sessionId", thrift.Thrift.Type.I64, 1);
            output.writeI64(this.sessionId);
            output.writeFieldEnd();
        }
        if (this.storageGroup != null) {
            output.writeFieldBegin("storageGroup", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.storageGroup.length);
            this.storageGroup.forEach((value_31: string): void => {
                output.writeString(value_31);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteStorageGroupsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_32: Int64 = input.readI64();
                        _args.sessionId = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_33: Array<string> = new Array<string>();
                        const metadata_2: thrift.TList = input.readListBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_34: string = input.readString();
                            value_33.push(value_34);
                        }
                        input.readListEnd();
                        _args.storageGroup = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.sessionId !== undefined && _args.storageGroup !== undefined) {
            return new DeleteStorageGroupsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteStorageGroupsArgs from input");
        }
    }
}
export interface IInsertRecordArgsArgs {
    req: TSInsertRecordReq.TSInsertRecordReq;
}
export class InsertRecordArgs {
    public req: TSInsertRecordReq.TSInsertRecordReq;
    constructor(args: IInsertRecordArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertRecordArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertRecordArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_35: TSInsertRecordReq.TSInsertRecordReq = TSInsertRecordReq.TSInsertRecordReq.read(input);
                        _args.req = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertRecordArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertRecordArgs from input");
        }
    }
}
export interface IInsertStringRecordArgsArgs {
    req: TSInsertStringRecordReq.TSInsertStringRecordReq;
}
export class InsertStringRecordArgs {
    public req: TSInsertStringRecordReq.TSInsertStringRecordReq;
    constructor(args: IInsertStringRecordArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertStringRecordArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertStringRecordArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_36: TSInsertStringRecordReq.TSInsertStringRecordReq = TSInsertStringRecordReq.TSInsertStringRecordReq.read(input);
                        _args.req = value_36;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertStringRecordArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertStringRecordArgs from input");
        }
    }
}
export interface IInsertTabletArgsArgs {
    req: TSInsertTabletReq.TSInsertTabletReq;
}
export class InsertTabletArgs {
    public req: TSInsertTabletReq.TSInsertTabletReq;
    constructor(args: IInsertTabletArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertTabletArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertTabletArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_37: TSInsertTabletReq.TSInsertTabletReq = TSInsertTabletReq.TSInsertTabletReq.read(input);
                        _args.req = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertTabletArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertTabletArgs from input");
        }
    }
}
export interface IInsertTabletsArgsArgs {
    req: TSInsertTabletsReq.TSInsertTabletsReq;
}
export class InsertTabletsArgs {
    public req: TSInsertTabletsReq.TSInsertTabletsReq;
    constructor(args: IInsertTabletsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertTabletsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertTabletsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_38: TSInsertTabletsReq.TSInsertTabletsReq = TSInsertTabletsReq.TSInsertTabletsReq.read(input);
                        _args.req = value_38;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertTabletsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertTabletsArgs from input");
        }
    }
}
export interface IInsertRecordsArgsArgs {
    req: TSInsertRecordsReq.TSInsertRecordsReq;
}
export class InsertRecordsArgs {
    public req: TSInsertRecordsReq.TSInsertRecordsReq;
    constructor(args: IInsertRecordsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertRecordsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertRecordsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_39: TSInsertRecordsReq.TSInsertRecordsReq = TSInsertRecordsReq.TSInsertRecordsReq.read(input);
                        _args.req = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertRecordsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertRecordsArgs from input");
        }
    }
}
export interface IInsertRecordsOfOneDeviceArgsArgs {
    req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq;
}
export class InsertRecordsOfOneDeviceArgs {
    public req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq;
    constructor(args: IInsertRecordsOfOneDeviceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertRecordsOfOneDeviceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertRecordsOfOneDeviceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_40: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq = TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq.read(input);
                        _args.req = value_40;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertRecordsOfOneDeviceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertRecordsOfOneDeviceArgs from input");
        }
    }
}
export interface IInsertStringRecordsOfOneDeviceArgsArgs {
    req: TSInsertStringRecordsOfOneDeviceReq.TSInsertStringRecordsOfOneDeviceReq;
}
export class InsertStringRecordsOfOneDeviceArgs {
    public req: TSInsertStringRecordsOfOneDeviceReq.TSInsertStringRecordsOfOneDeviceReq;
    constructor(args: IInsertStringRecordsOfOneDeviceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertStringRecordsOfOneDeviceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertStringRecordsOfOneDeviceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_41: TSInsertStringRecordsOfOneDeviceReq.TSInsertStringRecordsOfOneDeviceReq = TSInsertStringRecordsOfOneDeviceReq.TSInsertStringRecordsOfOneDeviceReq.read(input);
                        _args.req = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertStringRecordsOfOneDeviceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertStringRecordsOfOneDeviceArgs from input");
        }
    }
}
export interface IInsertStringRecordsArgsArgs {
    req: TSInsertStringRecordsReq.TSInsertStringRecordsReq;
}
export class InsertStringRecordsArgs {
    public req: TSInsertStringRecordsReq.TSInsertStringRecordsReq;
    constructor(args: IInsertStringRecordsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertStringRecordsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertStringRecordsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_42: TSInsertStringRecordsReq.TSInsertStringRecordsReq = TSInsertStringRecordsReq.TSInsertStringRecordsReq.read(input);
                        _args.req = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InsertStringRecordsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InsertStringRecordsArgs from input");
        }
    }
}
export interface ITestInsertTabletArgsArgs {
    req: TSInsertTabletReq.TSInsertTabletReq;
}
export class TestInsertTabletArgs {
    public req: TSInsertTabletReq.TSInsertTabletReq;
    constructor(args: ITestInsertTabletArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertTabletArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertTabletArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_43: TSInsertTabletReq.TSInsertTabletReq = TSInsertTabletReq.TSInsertTabletReq.read(input);
                        _args.req = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new TestInsertTabletArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TestInsertTabletArgs from input");
        }
    }
}
export interface ITestInsertTabletsArgsArgs {
    req: TSInsertTabletsReq.TSInsertTabletsReq;
}
export class TestInsertTabletsArgs {
    public req: TSInsertTabletsReq.TSInsertTabletsReq;
    constructor(args: ITestInsertTabletsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertTabletsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertTabletsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_44: TSInsertTabletsReq.TSInsertTabletsReq = TSInsertTabletsReq.TSInsertTabletsReq.read(input);
                        _args.req = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new TestInsertTabletsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TestInsertTabletsArgs from input");
        }
    }
}
export interface ITestInsertRecordArgsArgs {
    req: TSInsertRecordReq.TSInsertRecordReq;
}
export class TestInsertRecordArgs {
    public req: TSInsertRecordReq.TSInsertRecordReq;
    constructor(args: ITestInsertRecordArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertRecordArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertRecordArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_45: TSInsertRecordReq.TSInsertRecordReq = TSInsertRecordReq.TSInsertRecordReq.read(input);
                        _args.req = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new TestInsertRecordArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TestInsertRecordArgs from input");
        }
    }
}
export interface ITestInsertStringRecordArgsArgs {
    req: TSInsertStringRecordReq.TSInsertStringRecordReq;
}
export class TestInsertStringRecordArgs {
    public req: TSInsertStringRecordReq.TSInsertStringRecordReq;
    constructor(args: ITestInsertStringRecordArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertStringRecordArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertStringRecordArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_46: TSInsertStringRecordReq.TSInsertStringRecordReq = TSInsertStringRecordReq.TSInsertStringRecordReq.read(input);
                        _args.req = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new TestInsertStringRecordArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TestInsertStringRecordArgs from input");
        }
    }
}
export interface ITestInsertRecordsArgsArgs {
    req: TSInsertRecordsReq.TSInsertRecordsReq;
}
export class TestInsertRecordsArgs {
    public req: TSInsertRecordsReq.TSInsertRecordsReq;
    constructor(args: ITestInsertRecordsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertRecordsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertRecordsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_47: TSInsertRecordsReq.TSInsertRecordsReq = TSInsertRecordsReq.TSInsertRecordsReq.read(input);
                        _args.req = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new TestInsertRecordsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TestInsertRecordsArgs from input");
        }
    }
}
export interface ITestInsertRecordsOfOneDeviceArgsArgs {
    req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq;
}
export class TestInsertRecordsOfOneDeviceArgs {
    public req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq;
    constructor(args: ITestInsertRecordsOfOneDeviceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertRecordsOfOneDeviceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertRecordsOfOneDeviceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_48: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq = TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq.read(input);
                        _args.req = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new TestInsertRecordsOfOneDeviceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TestInsertRecordsOfOneDeviceArgs from input");
        }
    }
}
export interface ITestInsertStringRecordsArgsArgs {
    req: TSInsertStringRecordsReq.TSInsertStringRecordsReq;
}
export class TestInsertStringRecordsArgs {
    public req: TSInsertStringRecordsReq.TSInsertStringRecordsReq;
    constructor(args: ITestInsertStringRecordsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertStringRecordsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertStringRecordsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_49: TSInsertStringRecordsReq.TSInsertStringRecordsReq = TSInsertStringRecordsReq.TSInsertStringRecordsReq.read(input);
                        _args.req = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new TestInsertStringRecordsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read TestInsertStringRecordsArgs from input");
        }
    }
}
export interface IDeleteDataArgsArgs {
    req: TSDeleteDataReq.TSDeleteDataReq;
}
export class DeleteDataArgs {
    public req: TSDeleteDataReq.TSDeleteDataReq;
    constructor(args: IDeleteDataArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_50: TSDeleteDataReq.TSDeleteDataReq = TSDeleteDataReq.TSDeleteDataReq.read(input);
                        _args.req = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteDataArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteDataArgs from input");
        }
    }
}
export interface IExecuteRawDataQueryArgsArgs {
    req: TSRawDataQueryReq.TSRawDataQueryReq;
}
export class ExecuteRawDataQueryArgs {
    public req: TSRawDataQueryReq.TSRawDataQueryReq;
    constructor(args: IExecuteRawDataQueryArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteRawDataQueryArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteRawDataQueryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_51: TSRawDataQueryReq.TSRawDataQueryReq = TSRawDataQueryReq.TSRawDataQueryReq.read(input);
                        _args.req = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteRawDataQueryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteRawDataQueryArgs from input");
        }
    }
}
export interface IExecuteLastDataQueryArgsArgs {
    req: TSLastDataQueryReq.TSLastDataQueryReq;
}
export class ExecuteLastDataQueryArgs {
    public req: TSLastDataQueryReq.TSLastDataQueryReq;
    constructor(args: IExecuteLastDataQueryArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteLastDataQueryArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteLastDataQueryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_52: TSLastDataQueryReq.TSLastDataQueryReq = TSLastDataQueryReq.TSLastDataQueryReq.read(input);
                        _args.req = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteLastDataQueryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteLastDataQueryArgs from input");
        }
    }
}
export interface IExecuteAggregationQueryArgsArgs {
    req: TSAggregationQueryReq.TSAggregationQueryReq;
}
export class ExecuteAggregationQueryArgs {
    public req: TSAggregationQueryReq.TSAggregationQueryReq;
    constructor(args: IExecuteAggregationQueryArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteAggregationQueryArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteAggregationQueryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_53: TSAggregationQueryReq.TSAggregationQueryReq = TSAggregationQueryReq.TSAggregationQueryReq.read(input);
                        _args.req = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteAggregationQueryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteAggregationQueryArgs from input");
        }
    }
}
export interface IRequestStatementIdArgsArgs {
    sessionId: number | Int64;
}
export class RequestStatementIdArgs {
    public sessionId: Int64;
    constructor(args: IRequestStatementIdArgsArgs) {
        if (args != null && args.sessionId != null) {
            if (typeof args.sessionId === "number") {
                this.sessionId = new Int64(args.sessionId);
            }
            else {
                this.sessionId = args.sessionId;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sessionId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RequestStatementIdArgs");
        if (this.sessionId != null) {
            output.writeFieldBegin("sessionId", thrift.Thrift.Type.I64, 1);
            output.writeI64(this.sessionId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RequestStatementIdArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_54: Int64 = input.readI64();
                        _args.sessionId = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.sessionId !== undefined) {
            return new RequestStatementIdArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RequestStatementIdArgs from input");
        }
    }
}
export interface ICreateSchemaTemplateArgsArgs {
    req: TSCreateSchemaTemplateReq.TSCreateSchemaTemplateReq;
}
export class CreateSchemaTemplateArgs {
    public req: TSCreateSchemaTemplateReq.TSCreateSchemaTemplateReq;
    constructor(args: ICreateSchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateSchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateSchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_55: TSCreateSchemaTemplateReq.TSCreateSchemaTemplateReq = TSCreateSchemaTemplateReq.TSCreateSchemaTemplateReq.read(input);
                        _args.req = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateSchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateSchemaTemplateArgs from input");
        }
    }
}
export interface IAppendSchemaTemplateArgsArgs {
    req: TSAppendSchemaTemplateReq.TSAppendSchemaTemplateReq;
}
export class AppendSchemaTemplateArgs {
    public req: TSAppendSchemaTemplateReq.TSAppendSchemaTemplateReq;
    constructor(args: IAppendSchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AppendSchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AppendSchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_56: TSAppendSchemaTemplateReq.TSAppendSchemaTemplateReq = TSAppendSchemaTemplateReq.TSAppendSchemaTemplateReq.read(input);
                        _args.req = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new AppendSchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AppendSchemaTemplateArgs from input");
        }
    }
}
export interface IPruneSchemaTemplateArgsArgs {
    req: TSPruneSchemaTemplateReq.TSPruneSchemaTemplateReq;
}
export class PruneSchemaTemplateArgs {
    public req: TSPruneSchemaTemplateReq.TSPruneSchemaTemplateReq;
    constructor(args: IPruneSchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PruneSchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PruneSchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_57: TSPruneSchemaTemplateReq.TSPruneSchemaTemplateReq = TSPruneSchemaTemplateReq.TSPruneSchemaTemplateReq.read(input);
                        _args.req = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PruneSchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PruneSchemaTemplateArgs from input");
        }
    }
}
export interface IQuerySchemaTemplateArgsArgs {
    req: TSQueryTemplateReq.TSQueryTemplateReq;
}
export class QuerySchemaTemplateArgs {
    public req: TSQueryTemplateReq.TSQueryTemplateReq;
    constructor(args: IQuerySchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("QuerySchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): QuerySchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_58: TSQueryTemplateReq.TSQueryTemplateReq = TSQueryTemplateReq.TSQueryTemplateReq.read(input);
                        _args.req = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new QuerySchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read QuerySchemaTemplateArgs from input");
        }
    }
}
export interface IShowConfigurationTemplateArgsArgs {
}
export class ShowConfigurationTemplateArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShowConfigurationTemplateArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShowConfigurationTemplateArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ShowConfigurationTemplateArgs();
    }
}
export interface IShowConfigurationArgsArgs {
    nodeId: number;
}
export class ShowConfigurationArgs {
    public nodeId: number;
    constructor(args: IShowConfigurationArgsArgs) {
        if (args != null && args.nodeId != null) {
            this.nodeId = args.nodeId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[nodeId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShowConfigurationArgs");
        if (this.nodeId != null) {
            output.writeFieldBegin("nodeId", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.nodeId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShowConfigurationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_59: number = input.readI32();
                        _args.nodeId = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.nodeId !== undefined) {
            return new ShowConfigurationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ShowConfigurationArgs from input");
        }
    }
}
export interface ISetSchemaTemplateArgsArgs {
    req: TSSetSchemaTemplateReq.TSSetSchemaTemplateReq;
}
export class SetSchemaTemplateArgs {
    public req: TSSetSchemaTemplateReq.TSSetSchemaTemplateReq;
    constructor(args: ISetSchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetSchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetSchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_60: TSSetSchemaTemplateReq.TSSetSchemaTemplateReq = TSSetSchemaTemplateReq.TSSetSchemaTemplateReq.read(input);
                        _args.req = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SetSchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetSchemaTemplateArgs from input");
        }
    }
}
export interface IUnsetSchemaTemplateArgsArgs {
    req: TSUnsetSchemaTemplateReq.TSUnsetSchemaTemplateReq;
}
export class UnsetSchemaTemplateArgs {
    public req: TSUnsetSchemaTemplateReq.TSUnsetSchemaTemplateReq;
    constructor(args: IUnsetSchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UnsetSchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UnsetSchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_61: TSUnsetSchemaTemplateReq.TSUnsetSchemaTemplateReq = TSUnsetSchemaTemplateReq.TSUnsetSchemaTemplateReq.read(input);
                        _args.req = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new UnsetSchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UnsetSchemaTemplateArgs from input");
        }
    }
}
export interface IDropSchemaTemplateArgsArgs {
    req: TSDropSchemaTemplateReq.TSDropSchemaTemplateReq;
}
export class DropSchemaTemplateArgs {
    public req: TSDropSchemaTemplateReq.TSDropSchemaTemplateReq;
    constructor(args: IDropSchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropSchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropSchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_62: TSDropSchemaTemplateReq.TSDropSchemaTemplateReq = TSDropSchemaTemplateReq.TSDropSchemaTemplateReq.read(input);
                        _args.req = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DropSchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DropSchemaTemplateArgs from input");
        }
    }
}
export interface ICreateTimeseriesUsingSchemaTemplateArgsArgs {
    req: TCreateTimeseriesUsingSchemaTemplateReq.TCreateTimeseriesUsingSchemaTemplateReq;
}
export class CreateTimeseriesUsingSchemaTemplateArgs {
    public req: TCreateTimeseriesUsingSchemaTemplateReq.TCreateTimeseriesUsingSchemaTemplateReq;
    constructor(args: ICreateTimeseriesUsingSchemaTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateTimeseriesUsingSchemaTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, 1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateTimeseriesUsingSchemaTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_63: TCreateTimeseriesUsingSchemaTemplateReq.TCreateTimeseriesUsingSchemaTemplateReq = TCreateTimeseriesUsingSchemaTemplateReq.TCreateTimeseriesUsingSchemaTemplateReq.read(input);
                        _args.req = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateTimeseriesUsingSchemaTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateTimeseriesUsingSchemaTemplateArgs from input");
        }
    }
}
export interface IHandshakeArgsArgs {
    info: TSyncIdentityInfo.TSyncIdentityInfo;
}
export class HandshakeArgs {
    public info: TSyncIdentityInfo.TSyncIdentityInfo;
    constructor(args: IHandshakeArgsArgs) {
        if (args != null && args.info != null) {
            this.info = args.info;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[info] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("HandshakeArgs");
        if (this.info != null) {
            output.writeFieldBegin("info", thrift.Thrift.Type.STRUCT, -1);
            this.info.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): HandshakeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_64: TSyncIdentityInfo.TSyncIdentityInfo = TSyncIdentityInfo.TSyncIdentityInfo.read(input);
                        _args.info = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.info !== undefined) {
            return new HandshakeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read HandshakeArgs from input");
        }
    }
}
export interface ISendPipeDataArgsArgs {
    buff: Buffer;
}
export class SendPipeDataArgs {
    public buff: Buffer;
    constructor(args: ISendPipeDataArgsArgs) {
        if (args != null && args.buff != null) {
            this.buff = args.buff;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[buff] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendPipeDataArgs");
        if (this.buff != null) {
            output.writeFieldBegin("buff", thrift.Thrift.Type.STRING, 1);
            output.writeBinary(this.buff);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendPipeDataArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_65: Buffer = input.readBinary();
                        _args.buff = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.buff !== undefined) {
            return new SendPipeDataArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SendPipeDataArgs from input");
        }
    }
}
export interface ISendFileArgsArgs {
    metaInfo: TSyncTransportMetaInfo.TSyncTransportMetaInfo;
    buff: Buffer;
}
export class SendFileArgs {
    public metaInfo: TSyncTransportMetaInfo.TSyncTransportMetaInfo;
    public buff: Buffer;
    constructor(args: ISendFileArgsArgs) {
        if (args != null && args.metaInfo != null) {
            this.metaInfo = args.metaInfo;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[metaInfo] is unset!");
        }
        if (args != null && args.buff != null) {
            this.buff = args.buff;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[buff] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendFileArgs");
        if (this.metaInfo != null) {
            output.writeFieldBegin("metaInfo", thrift.Thrift.Type.STRUCT, 1);
            this.metaInfo.write(output);
            output.writeFieldEnd();
        }
        if (this.buff != null) {
            output.writeFieldBegin("buff", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.buff);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendFileArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_66: TSyncTransportMetaInfo.TSyncTransportMetaInfo = TSyncTransportMetaInfo.TSyncTransportMetaInfo.read(input);
                        _args.metaInfo = value_66;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_67: Buffer = input.readBinary();
                        _args.buff = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.metaInfo !== undefined && _args.buff !== undefined) {
            return new SendFileArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SendFileArgs from input");
        }
    }
}
export interface IPipeTransferArgsArgs {
    req: TPipeTransferReq.TPipeTransferReq;
}
export class PipeTransferArgs {
    public req: TPipeTransferReq.TPipeTransferReq;
    constructor(args: IPipeTransferArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PipeTransferArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PipeTransferArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_68: TPipeTransferReq.TPipeTransferReq = TPipeTransferReq.TPipeTransferReq.read(input);
                        _args.req = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PipeTransferArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PipeTransferArgs from input");
        }
    }
}
export interface IPipeSubscribeArgsArgs {
    req: TPipeSubscribeReq.TPipeSubscribeReq;
}
export class PipeSubscribeArgs {
    public req: TPipeSubscribeReq.TPipeSubscribeReq;
    constructor(args: IPipeSubscribeArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PipeSubscribeArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PipeSubscribeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_69: TPipeSubscribeReq.TPipeSubscribeReq = TPipeSubscribeReq.TPipeSubscribeReq.read(input);
                        _args.req = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PipeSubscribeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PipeSubscribeArgs from input");
        }
    }
}
export interface IGetBackupConfigurationArgsArgs {
}
export class GetBackupConfigurationArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetBackupConfigurationArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetBackupConfigurationArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetBackupConfigurationArgs();
    }
}
export interface IFetchAllConnectionsInfoArgsArgs {
}
export class FetchAllConnectionsInfoArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchAllConnectionsInfoArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchAllConnectionsInfoArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchAllConnectionsInfoArgs();
    }
}
export interface ITestConnectionEmptyRPCArgsArgs {
}
export class TestConnectionEmptyRPCArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestConnectionEmptyRPCArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestConnectionEmptyRPCArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestConnectionEmptyRPCArgs();
    }
}
export interface IExecuteQueryStatementV2ResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteQueryStatementV2Result {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteQueryStatementV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteQueryStatementV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteQueryStatementV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_70: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_70;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteQueryStatementV2Result(_args);
    }
}
export interface IExecuteUpdateStatementV2ResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteUpdateStatementV2Result {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteUpdateStatementV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteUpdateStatementV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteUpdateStatementV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_71: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteUpdateStatementV2Result(_args);
    }
}
export interface IExecuteStatementV2ResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteStatementV2Result {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteStatementV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteStatementV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteStatementV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_72: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_72;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteStatementV2Result(_args);
    }
}
export interface IExecuteRawDataQueryV2ResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteRawDataQueryV2Result {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteRawDataQueryV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteRawDataQueryV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteRawDataQueryV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_73: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_73;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteRawDataQueryV2Result(_args);
    }
}
export interface IExecuteLastDataQueryV2ResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteLastDataQueryV2Result {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteLastDataQueryV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteLastDataQueryV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteLastDataQueryV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_74: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_74;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteLastDataQueryV2Result(_args);
    }
}
export interface IExecuteFastLastDataQueryForOneDeviceV2ResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteFastLastDataQueryForOneDeviceV2Result {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteFastLastDataQueryForOneDeviceV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteFastLastDataQueryForOneDeviceV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteFastLastDataQueryForOneDeviceV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_75: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteFastLastDataQueryForOneDeviceV2Result(_args);
    }
}
export interface IExecuteAggregationQueryV2ResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteAggregationQueryV2Result {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteAggregationQueryV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteAggregationQueryV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteAggregationQueryV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_76: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_76;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteAggregationQueryV2Result(_args);
    }
}
export interface IExecuteGroupByQueryIntervalQueryResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteGroupByQueryIntervalQueryResult {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteGroupByQueryIntervalQueryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteGroupByQueryIntervalQueryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteGroupByQueryIntervalQueryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_77: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteGroupByQueryIntervalQueryResult(_args);
    }
}
export interface IFetchResultsV2ResultArgs {
    success?: TSFetchResultsResp.TSFetchResultsResp;
}
export class FetchResultsV2Result {
    public success?: TSFetchResultsResp.TSFetchResultsResp;
    constructor(args?: IFetchResultsV2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchResultsV2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchResultsV2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_78: TSFetchResultsResp.TSFetchResultsResp = TSFetchResultsResp.TSFetchResultsResp.read(input);
                        _args.success = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchResultsV2Result(_args);
    }
}
export interface IOpenSessionResultArgs {
    success?: TSOpenSessionResp.TSOpenSessionResp;
}
export class OpenSessionResult {
    public success?: TSOpenSessionResp.TSOpenSessionResp;
    constructor(args?: IOpenSessionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("OpenSessionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): OpenSessionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_79: TSOpenSessionResp.TSOpenSessionResp = TSOpenSessionResp.TSOpenSessionResp.read(input);
                        _args.success = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new OpenSessionResult(_args);
    }
}
export interface ICloseSessionResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CloseSessionResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICloseSessionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseSessionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseSessionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_80: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CloseSessionResult(_args);
    }
}
export interface IExecuteStatementResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteStatementResult {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteStatementResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteStatementResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteStatementResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_81: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteStatementResult(_args);
    }
}
export interface IExecuteBatchStatementResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ExecuteBatchStatementResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IExecuteBatchStatementResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteBatchStatementResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteBatchStatementResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_82: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_82;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteBatchStatementResult(_args);
    }
}
export interface IExecuteQueryStatementResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteQueryStatementResult {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteQueryStatementResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteQueryStatementResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteQueryStatementResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_83: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteQueryStatementResult(_args);
    }
}
export interface IExecuteUpdateStatementResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteUpdateStatementResult {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteUpdateStatementResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteUpdateStatementResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteUpdateStatementResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_84: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteUpdateStatementResult(_args);
    }
}
export interface IFetchResultsResultArgs {
    success?: TSFetchResultsResp.TSFetchResultsResp;
}
export class FetchResultsResult {
    public success?: TSFetchResultsResp.TSFetchResultsResp;
    constructor(args?: IFetchResultsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchResultsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchResultsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_85: TSFetchResultsResp.TSFetchResultsResp = TSFetchResultsResp.TSFetchResultsResp.read(input);
                        _args.success = value_85;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchResultsResult(_args);
    }
}
export interface IFetchMetadataResultArgs {
    success?: TSFetchMetadataResp.TSFetchMetadataResp;
}
export class FetchMetadataResult {
    public success?: TSFetchMetadataResp.TSFetchMetadataResp;
    constructor(args?: IFetchMetadataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchMetadataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchMetadataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_86: TSFetchMetadataResp.TSFetchMetadataResp = TSFetchMetadataResp.TSFetchMetadataResp.read(input);
                        _args.success = value_86;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchMetadataResult(_args);
    }
}
export interface ICancelOperationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CancelOperationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICancelOperationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelOperationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelOperationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_87: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CancelOperationResult(_args);
    }
}
export interface ICloseOperationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CloseOperationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICloseOperationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseOperationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseOperationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_88: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_88;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CloseOperationResult(_args);
    }
}
export interface IGetTimeZoneResultArgs {
    success?: TSGetTimeZoneResp.TSGetTimeZoneResp;
}
export class GetTimeZoneResult {
    public success?: TSGetTimeZoneResp.TSGetTimeZoneResp;
    constructor(args?: IGetTimeZoneResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTimeZoneResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTimeZoneResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_89: TSGetTimeZoneResp.TSGetTimeZoneResp = TSGetTimeZoneResp.TSGetTimeZoneResp.read(input);
                        _args.success = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetTimeZoneResult(_args);
    }
}
export interface ISetTimeZoneResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetTimeZoneResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetTimeZoneResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetTimeZoneResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetTimeZoneResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_90: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_90;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetTimeZoneResult(_args);
    }
}
export interface IGetPropertiesResultArgs {
    success?: ServerProperties.ServerProperties;
}
export class GetPropertiesResult {
    public success?: ServerProperties.ServerProperties;
    constructor(args?: IGetPropertiesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetPropertiesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetPropertiesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_91: ServerProperties.ServerProperties = ServerProperties.ServerProperties.read(input);
                        _args.success = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetPropertiesResult(_args);
    }
}
export interface ISetStorageGroupResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetStorageGroupResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetStorageGroupResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetStorageGroupResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetStorageGroupResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_92: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_92;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetStorageGroupResult(_args);
    }
}
export interface ICreateTimeseriesResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateTimeseriesResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateTimeseriesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateTimeseriesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateTimeseriesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_93: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_93;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateTimeseriesResult(_args);
    }
}
export interface ICreateAlignedTimeseriesResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateAlignedTimeseriesResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateAlignedTimeseriesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateAlignedTimeseriesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateAlignedTimeseriesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_94: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_94;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateAlignedTimeseriesResult(_args);
    }
}
export interface ICreateMultiTimeseriesResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateMultiTimeseriesResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateMultiTimeseriesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateMultiTimeseriesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateMultiTimeseriesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_95: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_95;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateMultiTimeseriesResult(_args);
    }
}
export interface IDeleteTimeseriesResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteTimeseriesResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteTimeseriesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteTimeseriesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteTimeseriesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_96: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_96;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteTimeseriesResult(_args);
    }
}
export interface IDeleteStorageGroupsResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteStorageGroupsResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteStorageGroupsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteStorageGroupsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteStorageGroupsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_97: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteStorageGroupsResult(_args);
    }
}
export interface IInsertRecordResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertRecordResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertRecordResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertRecordResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertRecordResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_98: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_98;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertRecordResult(_args);
    }
}
export interface IInsertStringRecordResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertStringRecordResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertStringRecordResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertStringRecordResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertStringRecordResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_99: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertStringRecordResult(_args);
    }
}
export interface IInsertTabletResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertTabletResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertTabletResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertTabletResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertTabletResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_100: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_100;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertTabletResult(_args);
    }
}
export interface IInsertTabletsResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertTabletsResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertTabletsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertTabletsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertTabletsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_101: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertTabletsResult(_args);
    }
}
export interface IInsertRecordsResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertRecordsResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertRecordsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertRecordsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertRecordsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_102: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_102;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertRecordsResult(_args);
    }
}
export interface IInsertRecordsOfOneDeviceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertRecordsOfOneDeviceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertRecordsOfOneDeviceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertRecordsOfOneDeviceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertRecordsOfOneDeviceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_103: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertRecordsOfOneDeviceResult(_args);
    }
}
export interface IInsertStringRecordsOfOneDeviceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertStringRecordsOfOneDeviceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertStringRecordsOfOneDeviceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertStringRecordsOfOneDeviceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertStringRecordsOfOneDeviceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_104: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_104;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertStringRecordsOfOneDeviceResult(_args);
    }
}
export interface IInsertStringRecordsResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InsertStringRecordsResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInsertStringRecordsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InsertStringRecordsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InsertStringRecordsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_105: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_105;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InsertStringRecordsResult(_args);
    }
}
export interface ITestInsertTabletResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestInsertTabletResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestInsertTabletResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertTabletResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertTabletResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_106: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_106;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestInsertTabletResult(_args);
    }
}
export interface ITestInsertTabletsResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestInsertTabletsResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestInsertTabletsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertTabletsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertTabletsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_107: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestInsertTabletsResult(_args);
    }
}
export interface ITestInsertRecordResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestInsertRecordResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestInsertRecordResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertRecordResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertRecordResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_108: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_108;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestInsertRecordResult(_args);
    }
}
export interface ITestInsertStringRecordResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestInsertStringRecordResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestInsertStringRecordResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertStringRecordResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertStringRecordResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_109: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestInsertStringRecordResult(_args);
    }
}
export interface ITestInsertRecordsResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestInsertRecordsResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestInsertRecordsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertRecordsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertRecordsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_110: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_110;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestInsertRecordsResult(_args);
    }
}
export interface ITestInsertRecordsOfOneDeviceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestInsertRecordsOfOneDeviceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestInsertRecordsOfOneDeviceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertRecordsOfOneDeviceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertRecordsOfOneDeviceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_111: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_111;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestInsertRecordsOfOneDeviceResult(_args);
    }
}
export interface ITestInsertStringRecordsResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestInsertStringRecordsResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestInsertStringRecordsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestInsertStringRecordsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestInsertStringRecordsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_112: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_112;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestInsertStringRecordsResult(_args);
    }
}
export interface IDeleteDataResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteDataResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteDataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_113: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_113;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteDataResult(_args);
    }
}
export interface IExecuteRawDataQueryResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteRawDataQueryResult {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteRawDataQueryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteRawDataQueryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteRawDataQueryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_114: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_114;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteRawDataQueryResult(_args);
    }
}
export interface IExecuteLastDataQueryResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteLastDataQueryResult {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteLastDataQueryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteLastDataQueryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteLastDataQueryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_115: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_115;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteLastDataQueryResult(_args);
    }
}
export interface IExecuteAggregationQueryResultArgs {
    success?: TSExecuteStatementResp.TSExecuteStatementResp;
}
export class ExecuteAggregationQueryResult {
    public success?: TSExecuteStatementResp.TSExecuteStatementResp;
    constructor(args?: IExecuteAggregationQueryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteAggregationQueryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteAggregationQueryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_116: TSExecuteStatementResp.TSExecuteStatementResp = TSExecuteStatementResp.TSExecuteStatementResp.read(input);
                        _args.success = value_116;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteAggregationQueryResult(_args);
    }
}
export interface IRequestStatementIdResultArgs {
    success?: number | Int64;
}
export class RequestStatementIdResult {
    public success?: Int64;
    constructor(args?: IRequestStatementIdResultArgs) {
        if (args != null && args.success != null) {
            if (typeof args.success === "number") {
                this.success = new Int64(args.success);
            }
            else {
                this.success = args.success;
            }
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RequestStatementIdResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I64, 0);
            output.writeI64(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RequestStatementIdResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_117: Int64 = input.readI64();
                        _args.success = value_117;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RequestStatementIdResult(_args);
    }
}
export interface ICreateSchemaTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateSchemaTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateSchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateSchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateSchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_118: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_118;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateSchemaTemplateResult(_args);
    }
}
export interface IAppendSchemaTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class AppendSchemaTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IAppendSchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AppendSchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AppendSchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_119: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_119;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AppendSchemaTemplateResult(_args);
    }
}
export interface IPruneSchemaTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class PruneSchemaTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IPruneSchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PruneSchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PruneSchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_120: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_120;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PruneSchemaTemplateResult(_args);
    }
}
export interface IQuerySchemaTemplateResultArgs {
    success?: TSQueryTemplateResp.TSQueryTemplateResp;
}
export class QuerySchemaTemplateResult {
    public success?: TSQueryTemplateResp.TSQueryTemplateResp;
    constructor(args?: IQuerySchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("QuerySchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): QuerySchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_121: TSQueryTemplateResp.TSQueryTemplateResp = TSQueryTemplateResp.TSQueryTemplateResp.read(input);
                        _args.success = value_121;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new QuerySchemaTemplateResult(_args);
    }
}
export interface IShowConfigurationTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp;
}
export class ShowConfigurationTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp;
    constructor(args?: IShowConfigurationTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShowConfigurationTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShowConfigurationTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_122: org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp = org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp.read(input);
                        _args.success = value_122;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ShowConfigurationTemplateResult(_args);
    }
}
export interface IShowConfigurationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp;
}
export class ShowConfigurationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp;
    constructor(args?: IShowConfigurationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShowConfigurationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShowConfigurationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_123: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp = org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp.read(input);
                        _args.success = value_123;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ShowConfigurationResult(_args);
    }
}
export interface ISetSchemaTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetSchemaTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetSchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetSchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetSchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_124: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_124;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetSchemaTemplateResult(_args);
    }
}
export interface IUnsetSchemaTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class UnsetSchemaTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IUnsetSchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UnsetSchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UnsetSchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_125: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_125;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UnsetSchemaTemplateResult(_args);
    }
}
export interface IDropSchemaTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DropSchemaTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDropSchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropSchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropSchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_126: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_126;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DropSchemaTemplateResult(_args);
    }
}
export interface ICreateTimeseriesUsingSchemaTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateTimeseriesUsingSchemaTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateTimeseriesUsingSchemaTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateTimeseriesUsingSchemaTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateTimeseriesUsingSchemaTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_127: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_127;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateTimeseriesUsingSchemaTemplateResult(_args);
    }
}
export interface IHandshakeResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class HandshakeResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IHandshakeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("HandshakeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): HandshakeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_128: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_128;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new HandshakeResult(_args);
    }
}
export interface ISendPipeDataResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SendPipeDataResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISendPipeDataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendPipeDataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendPipeDataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_129: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_129;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SendPipeDataResult(_args);
    }
}
export interface ISendFileResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SendFileResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISendFileResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendFileResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendFileResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_130: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_130;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SendFileResult(_args);
    }
}
export interface IPipeTransferResultArgs {
    success?: TPipeTransferResp.TPipeTransferResp;
}
export class PipeTransferResult {
    public success?: TPipeTransferResp.TPipeTransferResp;
    constructor(args?: IPipeTransferResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PipeTransferResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PipeTransferResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_131: TPipeTransferResp.TPipeTransferResp = TPipeTransferResp.TPipeTransferResp.read(input);
                        _args.success = value_131;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PipeTransferResult(_args);
    }
}
export interface IPipeSubscribeResultArgs {
    success?: TPipeSubscribeResp.TPipeSubscribeResp;
}
export class PipeSubscribeResult {
    public success?: TPipeSubscribeResp.TPipeSubscribeResp;
    constructor(args?: IPipeSubscribeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PipeSubscribeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PipeSubscribeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_132: TPipeSubscribeResp.TPipeSubscribeResp = TPipeSubscribeResp.TPipeSubscribeResp.read(input);
                        _args.success = value_132;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PipeSubscribeResult(_args);
    }
}
export interface IGetBackupConfigurationResultArgs {
    success?: TSBackupConfigurationResp.TSBackupConfigurationResp;
}
export class GetBackupConfigurationResult {
    public success?: TSBackupConfigurationResp.TSBackupConfigurationResp;
    constructor(args?: IGetBackupConfigurationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetBackupConfigurationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetBackupConfigurationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_133: TSBackupConfigurationResp.TSBackupConfigurationResp = TSBackupConfigurationResp.TSBackupConfigurationResp.read(input);
                        _args.success = value_133;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetBackupConfigurationResult(_args);
    }
}
export interface IFetchAllConnectionsInfoResultArgs {
    success?: TSConnectionInfoResp.TSConnectionInfoResp;
}
export class FetchAllConnectionsInfoResult {
    public success?: TSConnectionInfoResp.TSConnectionInfoResp;
    constructor(args?: IFetchAllConnectionsInfoResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchAllConnectionsInfoResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchAllConnectionsInfoResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_134: TSConnectionInfoResp.TSConnectionInfoResp = TSConnectionInfoResp.TSConnectionInfoResp.read(input);
                        _args.success = value_134;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchAllConnectionsInfoResult(_args);
    }
}
export interface ITestConnectionEmptyRPCResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestConnectionEmptyRPCResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestConnectionEmptyRPCResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestConnectionEmptyRPCResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestConnectionEmptyRPCResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_135: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_135;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestConnectionEmptyRPCResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public executeQueryStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeQueryStatementV2(req, requestId);
        });
    }
    public executeUpdateStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeUpdateStatementV2(req, requestId);
        });
    }
    public executeStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeStatementV2(req, requestId);
        });
    }
    public executeRawDataQueryV2(req: TSRawDataQueryReq.TSRawDataQueryReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeRawDataQueryV2(req, requestId);
        });
    }
    public executeLastDataQueryV2(req: TSLastDataQueryReq.TSLastDataQueryReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeLastDataQueryV2(req, requestId);
        });
    }
    public executeFastLastDataQueryForOneDeviceV2(req: TSFastLastDataQueryForOneDeviceReq.TSFastLastDataQueryForOneDeviceReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeFastLastDataQueryForOneDeviceV2(req, requestId);
        });
    }
    public executeAggregationQueryV2(req: TSAggregationQueryReq.TSAggregationQueryReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeAggregationQueryV2(req, requestId);
        });
    }
    public executeGroupByQueryIntervalQuery(req: TSGroupByQueryIntervalReq.TSGroupByQueryIntervalReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeGroupByQueryIntervalQuery(req, requestId);
        });
    }
    public fetchResultsV2(req: TSFetchResultsReq.TSFetchResultsReq): Promise<TSFetchResultsResp.TSFetchResultsResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSFetchResultsResp.TSFetchResultsResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchResultsV2(req, requestId);
        });
    }
    public openSession(req: TSOpenSessionReq.TSOpenSessionReq): Promise<TSOpenSessionResp.TSOpenSessionResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSOpenSessionResp.TSOpenSessionResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_openSession(req, requestId);
        });
    }
    public closeSession(req: TSCloseSessionReq.TSCloseSessionReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_closeSession(req, requestId);
        });
    }
    public executeStatement(req: TSExecuteStatementReq.TSExecuteStatementReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeStatement(req, requestId);
        });
    }
    public executeBatchStatement(req: TSExecuteBatchStatementReq.TSExecuteBatchStatementReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeBatchStatement(req, requestId);
        });
    }
    public executeQueryStatement(req: TSExecuteStatementReq.TSExecuteStatementReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeQueryStatement(req, requestId);
        });
    }
    public executeUpdateStatement(req: TSExecuteStatementReq.TSExecuteStatementReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeUpdateStatement(req, requestId);
        });
    }
    public fetchResults(req: TSFetchResultsReq.TSFetchResultsReq): Promise<TSFetchResultsResp.TSFetchResultsResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSFetchResultsResp.TSFetchResultsResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchResults(req, requestId);
        });
    }
    public fetchMetadata(req: TSFetchMetadataReq.TSFetchMetadataReq): Promise<TSFetchMetadataResp.TSFetchMetadataResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSFetchMetadataResp.TSFetchMetadataResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchMetadata(req, requestId);
        });
    }
    public cancelOperation(req: TSCancelOperationReq.TSCancelOperationReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cancelOperation(req, requestId);
        });
    }
    public closeOperation(req: TSCloseOperationReq.TSCloseOperationReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_closeOperation(req, requestId);
        });
    }
    public getTimeZone(sessionId: Int64): Promise<TSGetTimeZoneResp.TSGetTimeZoneResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSGetTimeZoneResp.TSGetTimeZoneResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getTimeZone(sessionId, requestId);
        });
    }
    public setTimeZone(req: TSSetTimeZoneReq.TSSetTimeZoneReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setTimeZone(req, requestId);
        });
    }
    public getProperties(): Promise<ServerProperties.ServerProperties> {
        const requestId: number = this.incrementSeqId();
        return new Promise<ServerProperties.ServerProperties>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getProperties(requestId);
        });
    }
    public setStorageGroup(sessionId: Int64, storageGroup: string): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setStorageGroup(sessionId, storageGroup, requestId);
        });
    }
    public createTimeseries(req: TSCreateTimeseriesReq.TSCreateTimeseriesReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createTimeseries(req, requestId);
        });
    }
    public createAlignedTimeseries(req: TSCreateAlignedTimeseriesReq.TSCreateAlignedTimeseriesReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createAlignedTimeseries(req, requestId);
        });
    }
    public createMultiTimeseries(req: TSCreateMultiTimeseriesReq.TSCreateMultiTimeseriesReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createMultiTimeseries(req, requestId);
        });
    }
    public deleteTimeseries(sessionId: Int64, path: Array<string>): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteTimeseries(sessionId, path, requestId);
        });
    }
    public deleteStorageGroups(sessionId: Int64, storageGroup: Array<string>): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteStorageGroups(sessionId, storageGroup, requestId);
        });
    }
    public insertRecord(req: TSInsertRecordReq.TSInsertRecordReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertRecord(req, requestId);
        });
    }
    public insertStringRecord(req: TSInsertStringRecordReq.TSInsertStringRecordReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertStringRecord(req, requestId);
        });
    }
    public insertTablet(req: TSInsertTabletReq.TSInsertTabletReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertTablet(req, requestId);
        });
    }
    public insertTablets(req: TSInsertTabletsReq.TSInsertTabletsReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertTablets(req, requestId);
        });
    }
    public insertRecords(req: TSInsertRecordsReq.TSInsertRecordsReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertRecords(req, requestId);
        });
    }
    public insertRecordsOfOneDevice(req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertRecordsOfOneDevice(req, requestId);
        });
    }
    public insertStringRecordsOfOneDevice(req: TSInsertStringRecordsOfOneDeviceReq.TSInsertStringRecordsOfOneDeviceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertStringRecordsOfOneDevice(req, requestId);
        });
    }
    public insertStringRecords(req: TSInsertStringRecordsReq.TSInsertStringRecordsReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_insertStringRecords(req, requestId);
        });
    }
    public testInsertTablet(req: TSInsertTabletReq.TSInsertTabletReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testInsertTablet(req, requestId);
        });
    }
    public testInsertTablets(req: TSInsertTabletsReq.TSInsertTabletsReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testInsertTablets(req, requestId);
        });
    }
    public testInsertRecord(req: TSInsertRecordReq.TSInsertRecordReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testInsertRecord(req, requestId);
        });
    }
    public testInsertStringRecord(req: TSInsertStringRecordReq.TSInsertStringRecordReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testInsertStringRecord(req, requestId);
        });
    }
    public testInsertRecords(req: TSInsertRecordsReq.TSInsertRecordsReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testInsertRecords(req, requestId);
        });
    }
    public testInsertRecordsOfOneDevice(req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testInsertRecordsOfOneDevice(req, requestId);
        });
    }
    public testInsertStringRecords(req: TSInsertStringRecordsReq.TSInsertStringRecordsReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testInsertStringRecords(req, requestId);
        });
    }
    public deleteData(req: TSDeleteDataReq.TSDeleteDataReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteData(req, requestId);
        });
    }
    public executeRawDataQuery(req: TSRawDataQueryReq.TSRawDataQueryReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeRawDataQuery(req, requestId);
        });
    }
    public executeLastDataQuery(req: TSLastDataQueryReq.TSLastDataQueryReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeLastDataQuery(req, requestId);
        });
    }
    public executeAggregationQuery(req: TSAggregationQueryReq.TSAggregationQueryReq): Promise<TSExecuteStatementResp.TSExecuteStatementResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeAggregationQuery(req, requestId);
        });
    }
    public requestStatementId(sessionId: Int64): Promise<Int64> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Int64>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_requestStatementId(sessionId, requestId);
        });
    }
    public createSchemaTemplate(req: TSCreateSchemaTemplateReq.TSCreateSchemaTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createSchemaTemplate(req, requestId);
        });
    }
    public appendSchemaTemplate(req: TSAppendSchemaTemplateReq.TSAppendSchemaTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_appendSchemaTemplate(req, requestId);
        });
    }
    public pruneSchemaTemplate(req: TSPruneSchemaTemplateReq.TSPruneSchemaTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pruneSchemaTemplate(req, requestId);
        });
    }
    public querySchemaTemplate(req: TSQueryTemplateReq.TSQueryTemplateReq): Promise<TSQueryTemplateResp.TSQueryTemplateResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSQueryTemplateResp.TSQueryTemplateResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_querySchemaTemplate(req, requestId);
        });
    }
    public showConfigurationTemplate(): Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_showConfigurationTemplate(requestId);
        });
    }
    public showConfiguration(nodeId: number): Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_showConfiguration(nodeId, requestId);
        });
    }
    public setSchemaTemplate(req: TSSetSchemaTemplateReq.TSSetSchemaTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setSchemaTemplate(req, requestId);
        });
    }
    public unsetSchemaTemplate(req: TSUnsetSchemaTemplateReq.TSUnsetSchemaTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_unsetSchemaTemplate(req, requestId);
        });
    }
    public dropSchemaTemplate(req: TSDropSchemaTemplateReq.TSDropSchemaTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_dropSchemaTemplate(req, requestId);
        });
    }
    public createTimeseriesUsingSchemaTemplate(req: TCreateTimeseriesUsingSchemaTemplateReq.TCreateTimeseriesUsingSchemaTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createTimeseriesUsingSchemaTemplate(req, requestId);
        });
    }
    public handshake(info: TSyncIdentityInfo.TSyncIdentityInfo): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_handshake(info, requestId);
        });
    }
    public sendPipeData(buff: Buffer): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_sendPipeData(buff, requestId);
        });
    }
    public sendFile(metaInfo: TSyncTransportMetaInfo.TSyncTransportMetaInfo, buff: Buffer): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_sendFile(metaInfo, buff, requestId);
        });
    }
    public pipeTransfer(req: TPipeTransferReq.TPipeTransferReq): Promise<TPipeTransferResp.TPipeTransferResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPipeTransferResp.TPipeTransferResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pipeTransfer(req, requestId);
        });
    }
    public pipeSubscribe(req: TPipeSubscribeReq.TPipeSubscribeReq): Promise<TPipeSubscribeResp.TPipeSubscribeResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPipeSubscribeResp.TPipeSubscribeResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pipeSubscribe(req, requestId);
        });
    }
    public getBackupConfiguration(): Promise<TSBackupConfigurationResp.TSBackupConfigurationResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSBackupConfigurationResp.TSBackupConfigurationResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getBackupConfiguration(requestId);
        });
    }
    public fetchAllConnectionsInfo(): Promise<TSConnectionInfoResp.TSConnectionInfoResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSConnectionInfoResp.TSConnectionInfoResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchAllConnectionsInfo(requestId);
        });
    }
    public testConnectionEmptyRPC(): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testConnectionEmptyRPC(requestId);
        });
    }
    public send_executeQueryStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeQueryStatementV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteQueryStatementV2Args = new ExecuteQueryStatementV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeUpdateStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeUpdateStatementV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteUpdateStatementV2Args = new ExecuteUpdateStatementV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeStatementV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteStatementV2Args = new ExecuteStatementV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeRawDataQueryV2(req: TSRawDataQueryReq.TSRawDataQueryReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeRawDataQueryV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteRawDataQueryV2Args = new ExecuteRawDataQueryV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeLastDataQueryV2(req: TSLastDataQueryReq.TSLastDataQueryReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeLastDataQueryV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteLastDataQueryV2Args = new ExecuteLastDataQueryV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeFastLastDataQueryForOneDeviceV2(req: TSFastLastDataQueryForOneDeviceReq.TSFastLastDataQueryForOneDeviceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeFastLastDataQueryForOneDeviceV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteFastLastDataQueryForOneDeviceV2Args = new ExecuteFastLastDataQueryForOneDeviceV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeAggregationQueryV2(req: TSAggregationQueryReq.TSAggregationQueryReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeAggregationQueryV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteAggregationQueryV2Args = new ExecuteAggregationQueryV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeGroupByQueryIntervalQuery(req: TSGroupByQueryIntervalReq.TSGroupByQueryIntervalReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeGroupByQueryIntervalQuery", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteGroupByQueryIntervalQueryArgs = new ExecuteGroupByQueryIntervalQueryArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchResultsV2(req: TSFetchResultsReq.TSFetchResultsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchResultsV2", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchResultsV2Args = new FetchResultsV2Args({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_openSession(req: TSOpenSessionReq.TSOpenSessionReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("openSession", thrift.Thrift.MessageType.CALL, requestId);
        const args: OpenSessionArgs = new OpenSessionArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_closeSession(req: TSCloseSessionReq.TSCloseSessionReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.CALL, requestId);
        const args: CloseSessionArgs = new CloseSessionArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeStatement(req: TSExecuteStatementReq.TSExecuteStatementReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeStatement", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteStatementArgs = new ExecuteStatementArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeBatchStatement(req: TSExecuteBatchStatementReq.TSExecuteBatchStatementReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeBatchStatement", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteBatchStatementArgs = new ExecuteBatchStatementArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeQueryStatement(req: TSExecuteStatementReq.TSExecuteStatementReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeQueryStatement", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteQueryStatementArgs = new ExecuteQueryStatementArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeUpdateStatement(req: TSExecuteStatementReq.TSExecuteStatementReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeUpdateStatement", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteUpdateStatementArgs = new ExecuteUpdateStatementArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchResults(req: TSFetchResultsReq.TSFetchResultsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchResults", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchResultsArgs = new FetchResultsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchMetadata(req: TSFetchMetadataReq.TSFetchMetadataReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchMetadata", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchMetadataArgs = new FetchMetadataArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cancelOperation(req: TSCancelOperationReq.TSCancelOperationReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cancelOperation", thrift.Thrift.MessageType.CALL, requestId);
        const args: CancelOperationArgs = new CancelOperationArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_closeOperation(req: TSCloseOperationReq.TSCloseOperationReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("closeOperation", thrift.Thrift.MessageType.CALL, requestId);
        const args: CloseOperationArgs = new CloseOperationArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getTimeZone(sessionId: Int64, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getTimeZone", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetTimeZoneArgs = new GetTimeZoneArgs({ sessionId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setTimeZone(req: TSSetTimeZoneReq.TSSetTimeZoneReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setTimeZone", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetTimeZoneArgs = new SetTimeZoneArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getProperties(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getProperties", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetPropertiesArgs = new GetPropertiesArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setStorageGroup(sessionId: Int64, storageGroup: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setStorageGroup", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetStorageGroupArgs = new SetStorageGroupArgs({ sessionId, storageGroup });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createTimeseries(req: TSCreateTimeseriesReq.TSCreateTimeseriesReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createTimeseries", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateTimeseriesArgs = new CreateTimeseriesArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createAlignedTimeseries(req: TSCreateAlignedTimeseriesReq.TSCreateAlignedTimeseriesReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createAlignedTimeseries", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateAlignedTimeseriesArgs = new CreateAlignedTimeseriesArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createMultiTimeseries(req: TSCreateMultiTimeseriesReq.TSCreateMultiTimeseriesReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createMultiTimeseries", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateMultiTimeseriesArgs = new CreateMultiTimeseriesArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteTimeseries(sessionId: Int64, path: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteTimeseries", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteTimeseriesArgs = new DeleteTimeseriesArgs({ sessionId, path });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteStorageGroups(sessionId: Int64, storageGroup: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteStorageGroups", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteStorageGroupsArgs = new DeleteStorageGroupsArgs({ sessionId, storageGroup });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertRecord(req: TSInsertRecordReq.TSInsertRecordReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertRecord", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertRecordArgs = new InsertRecordArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertStringRecord(req: TSInsertStringRecordReq.TSInsertStringRecordReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertStringRecord", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertStringRecordArgs = new InsertStringRecordArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertTablet(req: TSInsertTabletReq.TSInsertTabletReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertTablet", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertTabletArgs = new InsertTabletArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertTablets(req: TSInsertTabletsReq.TSInsertTabletsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertTablets", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertTabletsArgs = new InsertTabletsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertRecords(req: TSInsertRecordsReq.TSInsertRecordsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertRecords", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertRecordsArgs = new InsertRecordsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertRecordsOfOneDevice(req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertRecordsOfOneDevice", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertRecordsOfOneDeviceArgs = new InsertRecordsOfOneDeviceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertStringRecordsOfOneDevice(req: TSInsertStringRecordsOfOneDeviceReq.TSInsertStringRecordsOfOneDeviceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertStringRecordsOfOneDevice", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertStringRecordsOfOneDeviceArgs = new InsertStringRecordsOfOneDeviceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_insertStringRecords(req: TSInsertStringRecordsReq.TSInsertStringRecordsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("insertStringRecords", thrift.Thrift.MessageType.CALL, requestId);
        const args: InsertStringRecordsArgs = new InsertStringRecordsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testInsertTablet(req: TSInsertTabletReq.TSInsertTabletReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testInsertTablet", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestInsertTabletArgs = new TestInsertTabletArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testInsertTablets(req: TSInsertTabletsReq.TSInsertTabletsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testInsertTablets", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestInsertTabletsArgs = new TestInsertTabletsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testInsertRecord(req: TSInsertRecordReq.TSInsertRecordReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testInsertRecord", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestInsertRecordArgs = new TestInsertRecordArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testInsertStringRecord(req: TSInsertStringRecordReq.TSInsertStringRecordReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testInsertStringRecord", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestInsertStringRecordArgs = new TestInsertStringRecordArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testInsertRecords(req: TSInsertRecordsReq.TSInsertRecordsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testInsertRecords", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestInsertRecordsArgs = new TestInsertRecordsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testInsertRecordsOfOneDevice(req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testInsertRecordsOfOneDevice", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestInsertRecordsOfOneDeviceArgs = new TestInsertRecordsOfOneDeviceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testInsertStringRecords(req: TSInsertStringRecordsReq.TSInsertStringRecordsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testInsertStringRecords", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestInsertStringRecordsArgs = new TestInsertStringRecordsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteData(req: TSDeleteDataReq.TSDeleteDataReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteData", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteDataArgs = new DeleteDataArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeRawDataQuery(req: TSRawDataQueryReq.TSRawDataQueryReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeRawDataQuery", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteRawDataQueryArgs = new ExecuteRawDataQueryArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeLastDataQuery(req: TSLastDataQueryReq.TSLastDataQueryReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeLastDataQuery", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteLastDataQueryArgs = new ExecuteLastDataQueryArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeAggregationQuery(req: TSAggregationQueryReq.TSAggregationQueryReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeAggregationQuery", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteAggregationQueryArgs = new ExecuteAggregationQueryArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_requestStatementId(sessionId: Int64, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("requestStatementId", thrift.Thrift.MessageType.CALL, requestId);
        const args: RequestStatementIdArgs = new RequestStatementIdArgs({ sessionId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createSchemaTemplate(req: TSCreateSchemaTemplateReq.TSCreateSchemaTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createSchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateSchemaTemplateArgs = new CreateSchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_appendSchemaTemplate(req: TSAppendSchemaTemplateReq.TSAppendSchemaTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("appendSchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: AppendSchemaTemplateArgs = new AppendSchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pruneSchemaTemplate(req: TSPruneSchemaTemplateReq.TSPruneSchemaTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pruneSchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: PruneSchemaTemplateArgs = new PruneSchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_querySchemaTemplate(req: TSQueryTemplateReq.TSQueryTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("querySchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: QuerySchemaTemplateArgs = new QuerySchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_showConfigurationTemplate(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("showConfigurationTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: ShowConfigurationTemplateArgs = new ShowConfigurationTemplateArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_showConfiguration(nodeId: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("showConfiguration", thrift.Thrift.MessageType.CALL, requestId);
        const args: ShowConfigurationArgs = new ShowConfigurationArgs({ nodeId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setSchemaTemplate(req: TSSetSchemaTemplateReq.TSSetSchemaTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setSchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetSchemaTemplateArgs = new SetSchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_unsetSchemaTemplate(req: TSUnsetSchemaTemplateReq.TSUnsetSchemaTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("unsetSchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: UnsetSchemaTemplateArgs = new UnsetSchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_dropSchemaTemplate(req: TSDropSchemaTemplateReq.TSDropSchemaTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("dropSchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: DropSchemaTemplateArgs = new DropSchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createTimeseriesUsingSchemaTemplate(req: TCreateTimeseriesUsingSchemaTemplateReq.TCreateTimeseriesUsingSchemaTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createTimeseriesUsingSchemaTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateTimeseriesUsingSchemaTemplateArgs = new CreateTimeseriesUsingSchemaTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_handshake(info: TSyncIdentityInfo.TSyncIdentityInfo, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("handshake", thrift.Thrift.MessageType.CALL, requestId);
        const args: HandshakeArgs = new HandshakeArgs({ info });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_sendPipeData(buff: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("sendPipeData", thrift.Thrift.MessageType.CALL, requestId);
        const args: SendPipeDataArgs = new SendPipeDataArgs({ buff });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_sendFile(metaInfo: TSyncTransportMetaInfo.TSyncTransportMetaInfo, buff: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("sendFile", thrift.Thrift.MessageType.CALL, requestId);
        const args: SendFileArgs = new SendFileArgs({ metaInfo, buff });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pipeTransfer(req: TPipeTransferReq.TPipeTransferReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pipeTransfer", thrift.Thrift.MessageType.CALL, requestId);
        const args: PipeTransferArgs = new PipeTransferArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pipeSubscribe(req: TPipeSubscribeReq.TPipeSubscribeReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pipeSubscribe", thrift.Thrift.MessageType.CALL, requestId);
        const args: PipeSubscribeArgs = new PipeSubscribeArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getBackupConfiguration(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getBackupConfiguration", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetBackupConfigurationArgs = new GetBackupConfigurationArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchAllConnectionsInfo(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchAllConnectionsInfo", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchAllConnectionsInfoArgs = new FetchAllConnectionsInfoArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testConnectionEmptyRPC(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testConnectionEmptyRPC", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestConnectionEmptyRPCArgs = new TestConnectionEmptyRPCArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_executeQueryStatementV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteQueryStatementV2Result = ExecuteQueryStatementV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeQueryStatementV2 failed: unknown result"));
            }
        }
    }
    public recv_executeUpdateStatementV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteUpdateStatementV2Result = ExecuteUpdateStatementV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeUpdateStatementV2 failed: unknown result"));
            }
        }
    }
    public recv_executeStatementV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteStatementV2Result = ExecuteStatementV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeStatementV2 failed: unknown result"));
            }
        }
    }
    public recv_executeRawDataQueryV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteRawDataQueryV2Result = ExecuteRawDataQueryV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeRawDataQueryV2 failed: unknown result"));
            }
        }
    }
    public recv_executeLastDataQueryV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteLastDataQueryV2Result = ExecuteLastDataQueryV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeLastDataQueryV2 failed: unknown result"));
            }
        }
    }
    public recv_executeFastLastDataQueryForOneDeviceV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteFastLastDataQueryForOneDeviceV2Result = ExecuteFastLastDataQueryForOneDeviceV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeFastLastDataQueryForOneDeviceV2 failed: unknown result"));
            }
        }
    }
    public recv_executeAggregationQueryV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteAggregationQueryV2Result = ExecuteAggregationQueryV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeAggregationQueryV2 failed: unknown result"));
            }
        }
    }
    public recv_executeGroupByQueryIntervalQuery(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteGroupByQueryIntervalQueryResult = ExecuteGroupByQueryIntervalQueryResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeGroupByQueryIntervalQuery failed: unknown result"));
            }
        }
    }
    public recv_fetchResultsV2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchResultsV2Result = FetchResultsV2Result.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchResultsV2 failed: unknown result"));
            }
        }
    }
    public recv_openSession(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: OpenSessionResult = OpenSessionResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "openSession failed: unknown result"));
            }
        }
    }
    public recv_closeSession(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CloseSessionResult = CloseSessionResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "closeSession failed: unknown result"));
            }
        }
    }
    public recv_executeStatement(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteStatementResult = ExecuteStatementResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeStatement failed: unknown result"));
            }
        }
    }
    public recv_executeBatchStatement(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteBatchStatementResult = ExecuteBatchStatementResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeBatchStatement failed: unknown result"));
            }
        }
    }
    public recv_executeQueryStatement(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteQueryStatementResult = ExecuteQueryStatementResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeQueryStatement failed: unknown result"));
            }
        }
    }
    public recv_executeUpdateStatement(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteUpdateStatementResult = ExecuteUpdateStatementResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeUpdateStatement failed: unknown result"));
            }
        }
    }
    public recv_fetchResults(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchResultsResult = FetchResultsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchResults failed: unknown result"));
            }
        }
    }
    public recv_fetchMetadata(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchMetadataResult = FetchMetadataResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchMetadata failed: unknown result"));
            }
        }
    }
    public recv_cancelOperation(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CancelOperationResult = CancelOperationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cancelOperation failed: unknown result"));
            }
        }
    }
    public recv_closeOperation(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CloseOperationResult = CloseOperationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "closeOperation failed: unknown result"));
            }
        }
    }
    public recv_getTimeZone(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetTimeZoneResult = GetTimeZoneResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getTimeZone failed: unknown result"));
            }
        }
    }
    public recv_setTimeZone(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetTimeZoneResult = SetTimeZoneResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setTimeZone failed: unknown result"));
            }
        }
    }
    public recv_getProperties(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetPropertiesResult = GetPropertiesResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getProperties failed: unknown result"));
            }
        }
    }
    public recv_setStorageGroup(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetStorageGroupResult = SetStorageGroupResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setStorageGroup failed: unknown result"));
            }
        }
    }
    public recv_createTimeseries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateTimeseriesResult = CreateTimeseriesResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createTimeseries failed: unknown result"));
            }
        }
    }
    public recv_createAlignedTimeseries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateAlignedTimeseriesResult = CreateAlignedTimeseriesResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createAlignedTimeseries failed: unknown result"));
            }
        }
    }
    public recv_createMultiTimeseries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateMultiTimeseriesResult = CreateMultiTimeseriesResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createMultiTimeseries failed: unknown result"));
            }
        }
    }
    public recv_deleteTimeseries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteTimeseriesResult = DeleteTimeseriesResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteTimeseries failed: unknown result"));
            }
        }
    }
    public recv_deleteStorageGroups(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteStorageGroupsResult = DeleteStorageGroupsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteStorageGroups failed: unknown result"));
            }
        }
    }
    public recv_insertRecord(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertRecordResult = InsertRecordResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertRecord failed: unknown result"));
            }
        }
    }
    public recv_insertStringRecord(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertStringRecordResult = InsertStringRecordResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertStringRecord failed: unknown result"));
            }
        }
    }
    public recv_insertTablet(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertTabletResult = InsertTabletResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertTablet failed: unknown result"));
            }
        }
    }
    public recv_insertTablets(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertTabletsResult = InsertTabletsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertTablets failed: unknown result"));
            }
        }
    }
    public recv_insertRecords(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertRecordsResult = InsertRecordsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertRecords failed: unknown result"));
            }
        }
    }
    public recv_insertRecordsOfOneDevice(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertRecordsOfOneDeviceResult = InsertRecordsOfOneDeviceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertRecordsOfOneDevice failed: unknown result"));
            }
        }
    }
    public recv_insertStringRecordsOfOneDevice(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertStringRecordsOfOneDeviceResult = InsertStringRecordsOfOneDeviceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertStringRecordsOfOneDevice failed: unknown result"));
            }
        }
    }
    public recv_insertStringRecords(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InsertStringRecordsResult = InsertStringRecordsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "insertStringRecords failed: unknown result"));
            }
        }
    }
    public recv_testInsertTablet(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestInsertTabletResult = TestInsertTabletResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testInsertTablet failed: unknown result"));
            }
        }
    }
    public recv_testInsertTablets(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestInsertTabletsResult = TestInsertTabletsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testInsertTablets failed: unknown result"));
            }
        }
    }
    public recv_testInsertRecord(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestInsertRecordResult = TestInsertRecordResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testInsertRecord failed: unknown result"));
            }
        }
    }
    public recv_testInsertStringRecord(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestInsertStringRecordResult = TestInsertStringRecordResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testInsertStringRecord failed: unknown result"));
            }
        }
    }
    public recv_testInsertRecords(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestInsertRecordsResult = TestInsertRecordsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testInsertRecords failed: unknown result"));
            }
        }
    }
    public recv_testInsertRecordsOfOneDevice(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestInsertRecordsOfOneDeviceResult = TestInsertRecordsOfOneDeviceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testInsertRecordsOfOneDevice failed: unknown result"));
            }
        }
    }
    public recv_testInsertStringRecords(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestInsertStringRecordsResult = TestInsertStringRecordsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testInsertStringRecords failed: unknown result"));
            }
        }
    }
    public recv_deleteData(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteDataResult = DeleteDataResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteData failed: unknown result"));
            }
        }
    }
    public recv_executeRawDataQuery(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteRawDataQueryResult = ExecuteRawDataQueryResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeRawDataQuery failed: unknown result"));
            }
        }
    }
    public recv_executeLastDataQuery(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteLastDataQueryResult = ExecuteLastDataQueryResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeLastDataQuery failed: unknown result"));
            }
        }
    }
    public recv_executeAggregationQuery(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteAggregationQueryResult = ExecuteAggregationQueryResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeAggregationQuery failed: unknown result"));
            }
        }
    }
    public recv_requestStatementId(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RequestStatementIdResult = RequestStatementIdResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "requestStatementId failed: unknown result"));
            }
        }
    }
    public recv_createSchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateSchemaTemplateResult = CreateSchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createSchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_appendSchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AppendSchemaTemplateResult = AppendSchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "appendSchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_pruneSchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PruneSchemaTemplateResult = PruneSchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pruneSchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_querySchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: QuerySchemaTemplateResult = QuerySchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "querySchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_showConfigurationTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ShowConfigurationTemplateResult = ShowConfigurationTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "showConfigurationTemplate failed: unknown result"));
            }
        }
    }
    public recv_showConfiguration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ShowConfigurationResult = ShowConfigurationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "showConfiguration failed: unknown result"));
            }
        }
    }
    public recv_setSchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetSchemaTemplateResult = SetSchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setSchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_unsetSchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UnsetSchemaTemplateResult = UnsetSchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "unsetSchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_dropSchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DropSchemaTemplateResult = DropSchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "dropSchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_createTimeseriesUsingSchemaTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateTimeseriesUsingSchemaTemplateResult = CreateTimeseriesUsingSchemaTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createTimeseriesUsingSchemaTemplate failed: unknown result"));
            }
        }
    }
    public recv_handshake(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: HandshakeResult = HandshakeResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "handshake failed: unknown result"));
            }
        }
    }
    public recv_sendPipeData(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SendPipeDataResult = SendPipeDataResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "sendPipeData failed: unknown result"));
            }
        }
    }
    public recv_sendFile(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SendFileResult = SendFileResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "sendFile failed: unknown result"));
            }
        }
    }
    public recv_pipeTransfer(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PipeTransferResult = PipeTransferResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pipeTransfer failed: unknown result"));
            }
        }
    }
    public recv_pipeSubscribe(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PipeSubscribeResult = PipeSubscribeResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pipeSubscribe failed: unknown result"));
            }
        }
    }
    public recv_getBackupConfiguration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetBackupConfigurationResult = GetBackupConfigurationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getBackupConfiguration failed: unknown result"));
            }
        }
    }
    public recv_fetchAllConnectionsInfo(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchAllConnectionsInfoResult = FetchAllConnectionsInfoResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchAllConnectionsInfo failed: unknown result"));
            }
        }
    }
    public recv_testConnectionEmptyRPC(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestConnectionEmptyRPCResult = TestConnectionEmptyRPCResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testConnectionEmptyRPC failed: unknown result"));
            }
        }
    }
}
export interface IHandler {
    executeQueryStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeUpdateStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeStatementV2(req: TSExecuteStatementReq.TSExecuteStatementReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeRawDataQueryV2(req: TSRawDataQueryReq.TSRawDataQueryReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeLastDataQueryV2(req: TSLastDataQueryReq.TSLastDataQueryReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeFastLastDataQueryForOneDeviceV2(req: TSFastLastDataQueryForOneDeviceReq.TSFastLastDataQueryForOneDeviceReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeAggregationQueryV2(req: TSAggregationQueryReq.TSAggregationQueryReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeGroupByQueryIntervalQuery(req: TSGroupByQueryIntervalReq.TSGroupByQueryIntervalReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    fetchResultsV2(req: TSFetchResultsReq.TSFetchResultsReq): TSFetchResultsResp.TSFetchResultsResp | Promise<TSFetchResultsResp.TSFetchResultsResp>;
    openSession(req: TSOpenSessionReq.TSOpenSessionReq): TSOpenSessionResp.TSOpenSessionResp | Promise<TSOpenSessionResp.TSOpenSessionResp>;
    closeSession(req: TSCloseSessionReq.TSCloseSessionReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    executeStatement(req: TSExecuteStatementReq.TSExecuteStatementReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeBatchStatement(req: TSExecuteBatchStatementReq.TSExecuteBatchStatementReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    executeQueryStatement(req: TSExecuteStatementReq.TSExecuteStatementReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeUpdateStatement(req: TSExecuteStatementReq.TSExecuteStatementReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    fetchResults(req: TSFetchResultsReq.TSFetchResultsReq): TSFetchResultsResp.TSFetchResultsResp | Promise<TSFetchResultsResp.TSFetchResultsResp>;
    fetchMetadata(req: TSFetchMetadataReq.TSFetchMetadataReq): TSFetchMetadataResp.TSFetchMetadataResp | Promise<TSFetchMetadataResp.TSFetchMetadataResp>;
    cancelOperation(req: TSCancelOperationReq.TSCancelOperationReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    closeOperation(req: TSCloseOperationReq.TSCloseOperationReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    getTimeZone(sessionId: Int64): TSGetTimeZoneResp.TSGetTimeZoneResp | Promise<TSGetTimeZoneResp.TSGetTimeZoneResp>;
    setTimeZone(req: TSSetTimeZoneReq.TSSetTimeZoneReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    getProperties(): ServerProperties.ServerProperties | Promise<ServerProperties.ServerProperties>;
    setStorageGroup(sessionId: Int64, storageGroup: string): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createTimeseries(req: TSCreateTimeseriesReq.TSCreateTimeseriesReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createAlignedTimeseries(req: TSCreateAlignedTimeseriesReq.TSCreateAlignedTimeseriesReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createMultiTimeseries(req: TSCreateMultiTimeseriesReq.TSCreateMultiTimeseriesReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteTimeseries(sessionId: Int64, path: Array<string>): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteStorageGroups(sessionId: Int64, storageGroup: Array<string>): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertRecord(req: TSInsertRecordReq.TSInsertRecordReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertStringRecord(req: TSInsertStringRecordReq.TSInsertStringRecordReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertTablet(req: TSInsertTabletReq.TSInsertTabletReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertTablets(req: TSInsertTabletsReq.TSInsertTabletsReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertRecords(req: TSInsertRecordsReq.TSInsertRecordsReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertRecordsOfOneDevice(req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertStringRecordsOfOneDevice(req: TSInsertStringRecordsOfOneDeviceReq.TSInsertStringRecordsOfOneDeviceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    insertStringRecords(req: TSInsertStringRecordsReq.TSInsertStringRecordsReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    testInsertTablet(req: TSInsertTabletReq.TSInsertTabletReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    testInsertTablets(req: TSInsertTabletsReq.TSInsertTabletsReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    testInsertRecord(req: TSInsertRecordReq.TSInsertRecordReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    testInsertStringRecord(req: TSInsertStringRecordReq.TSInsertStringRecordReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    testInsertRecords(req: TSInsertRecordsReq.TSInsertRecordsReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    testInsertRecordsOfOneDevice(req: TSInsertRecordsOfOneDeviceReq.TSInsertRecordsOfOneDeviceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    testInsertStringRecords(req: TSInsertStringRecordsReq.TSInsertStringRecordsReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteData(req: TSDeleteDataReq.TSDeleteDataReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    executeRawDataQuery(req: TSRawDataQueryReq.TSRawDataQueryReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeLastDataQuery(req: TSLastDataQueryReq.TSLastDataQueryReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    executeAggregationQuery(req: TSAggregationQueryReq.TSAggregationQueryReq): TSExecuteStatementResp.TSExecuteStatementResp | Promise<TSExecuteStatementResp.TSExecuteStatementResp>;
    requestStatementId(sessionId: Int64): Int64 | Promise<Int64>;
    createSchemaTemplate(req: TSCreateSchemaTemplateReq.TSCreateSchemaTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    appendSchemaTemplate(req: TSAppendSchemaTemplateReq.TSAppendSchemaTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    pruneSchemaTemplate(req: TSPruneSchemaTemplateReq.TSPruneSchemaTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    querySchemaTemplate(req: TSQueryTemplateReq.TSQueryTemplateReq): TSQueryTemplateResp.TSQueryTemplateResp | Promise<TSQueryTemplateResp.TSQueryTemplateResp>;
    showConfigurationTemplate(): org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp | Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp>;
    showConfiguration(nodeId: number): org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp | Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp>;
    setSchemaTemplate(req: TSSetSchemaTemplateReq.TSSetSchemaTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    unsetSchemaTemplate(req: TSUnsetSchemaTemplateReq.TSUnsetSchemaTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    dropSchemaTemplate(req: TSDropSchemaTemplateReq.TSDropSchemaTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createTimeseriesUsingSchemaTemplate(req: TCreateTimeseriesUsingSchemaTemplateReq.TCreateTimeseriesUsingSchemaTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    handshake(info: TSyncIdentityInfo.TSyncIdentityInfo): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    sendPipeData(buff: Buffer): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    sendFile(metaInfo: TSyncTransportMetaInfo.TSyncTransportMetaInfo, buff: Buffer): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    pipeTransfer(req: TPipeTransferReq.TPipeTransferReq): TPipeTransferResp.TPipeTransferResp | Promise<TPipeTransferResp.TPipeTransferResp>;
    pipeSubscribe(req: TPipeSubscribeReq.TPipeSubscribeReq): TPipeSubscribeResp.TPipeSubscribeResp | Promise<TPipeSubscribeResp.TPipeSubscribeResp>;
    getBackupConfiguration(): TSBackupConfigurationResp.TSBackupConfigurationResp | Promise<TSBackupConfigurationResp.TSBackupConfigurationResp>;
    fetchAllConnectionsInfo(): TSConnectionInfoResp.TSConnectionInfoResp | Promise<TSConnectionInfoResp.TSConnectionInfoResp>;
    testConnectionEmptyRPC(): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_executeQueryStatementV2": {
                this.process_executeQueryStatementV2(requestId, input, output);
                return;
            }
            case "process_executeUpdateStatementV2": {
                this.process_executeUpdateStatementV2(requestId, input, output);
                return;
            }
            case "process_executeStatementV2": {
                this.process_executeStatementV2(requestId, input, output);
                return;
            }
            case "process_executeRawDataQueryV2": {
                this.process_executeRawDataQueryV2(requestId, input, output);
                return;
            }
            case "process_executeLastDataQueryV2": {
                this.process_executeLastDataQueryV2(requestId, input, output);
                return;
            }
            case "process_executeFastLastDataQueryForOneDeviceV2": {
                this.process_executeFastLastDataQueryForOneDeviceV2(requestId, input, output);
                return;
            }
            case "process_executeAggregationQueryV2": {
                this.process_executeAggregationQueryV2(requestId, input, output);
                return;
            }
            case "process_executeGroupByQueryIntervalQuery": {
                this.process_executeGroupByQueryIntervalQuery(requestId, input, output);
                return;
            }
            case "process_fetchResultsV2": {
                this.process_fetchResultsV2(requestId, input, output);
                return;
            }
            case "process_openSession": {
                this.process_openSession(requestId, input, output);
                return;
            }
            case "process_closeSession": {
                this.process_closeSession(requestId, input, output);
                return;
            }
            case "process_executeStatement": {
                this.process_executeStatement(requestId, input, output);
                return;
            }
            case "process_executeBatchStatement": {
                this.process_executeBatchStatement(requestId, input, output);
                return;
            }
            case "process_executeQueryStatement": {
                this.process_executeQueryStatement(requestId, input, output);
                return;
            }
            case "process_executeUpdateStatement": {
                this.process_executeUpdateStatement(requestId, input, output);
                return;
            }
            case "process_fetchResults": {
                this.process_fetchResults(requestId, input, output);
                return;
            }
            case "process_fetchMetadata": {
                this.process_fetchMetadata(requestId, input, output);
                return;
            }
            case "process_cancelOperation": {
                this.process_cancelOperation(requestId, input, output);
                return;
            }
            case "process_closeOperation": {
                this.process_closeOperation(requestId, input, output);
                return;
            }
            case "process_getTimeZone": {
                this.process_getTimeZone(requestId, input, output);
                return;
            }
            case "process_setTimeZone": {
                this.process_setTimeZone(requestId, input, output);
                return;
            }
            case "process_getProperties": {
                this.process_getProperties(requestId, input, output);
                return;
            }
            case "process_setStorageGroup": {
                this.process_setStorageGroup(requestId, input, output);
                return;
            }
            case "process_createTimeseries": {
                this.process_createTimeseries(requestId, input, output);
                return;
            }
            case "process_createAlignedTimeseries": {
                this.process_createAlignedTimeseries(requestId, input, output);
                return;
            }
            case "process_createMultiTimeseries": {
                this.process_createMultiTimeseries(requestId, input, output);
                return;
            }
            case "process_deleteTimeseries": {
                this.process_deleteTimeseries(requestId, input, output);
                return;
            }
            case "process_deleteStorageGroups": {
                this.process_deleteStorageGroups(requestId, input, output);
                return;
            }
            case "process_insertRecord": {
                this.process_insertRecord(requestId, input, output);
                return;
            }
            case "process_insertStringRecord": {
                this.process_insertStringRecord(requestId, input, output);
                return;
            }
            case "process_insertTablet": {
                this.process_insertTablet(requestId, input, output);
                return;
            }
            case "process_insertTablets": {
                this.process_insertTablets(requestId, input, output);
                return;
            }
            case "process_insertRecords": {
                this.process_insertRecords(requestId, input, output);
                return;
            }
            case "process_insertRecordsOfOneDevice": {
                this.process_insertRecordsOfOneDevice(requestId, input, output);
                return;
            }
            case "process_insertStringRecordsOfOneDevice": {
                this.process_insertStringRecordsOfOneDevice(requestId, input, output);
                return;
            }
            case "process_insertStringRecords": {
                this.process_insertStringRecords(requestId, input, output);
                return;
            }
            case "process_testInsertTablet": {
                this.process_testInsertTablet(requestId, input, output);
                return;
            }
            case "process_testInsertTablets": {
                this.process_testInsertTablets(requestId, input, output);
                return;
            }
            case "process_testInsertRecord": {
                this.process_testInsertRecord(requestId, input, output);
                return;
            }
            case "process_testInsertStringRecord": {
                this.process_testInsertStringRecord(requestId, input, output);
                return;
            }
            case "process_testInsertRecords": {
                this.process_testInsertRecords(requestId, input, output);
                return;
            }
            case "process_testInsertRecordsOfOneDevice": {
                this.process_testInsertRecordsOfOneDevice(requestId, input, output);
                return;
            }
            case "process_testInsertStringRecords": {
                this.process_testInsertStringRecords(requestId, input, output);
                return;
            }
            case "process_deleteData": {
                this.process_deleteData(requestId, input, output);
                return;
            }
            case "process_executeRawDataQuery": {
                this.process_executeRawDataQuery(requestId, input, output);
                return;
            }
            case "process_executeLastDataQuery": {
                this.process_executeLastDataQuery(requestId, input, output);
                return;
            }
            case "process_executeAggregationQuery": {
                this.process_executeAggregationQuery(requestId, input, output);
                return;
            }
            case "process_requestStatementId": {
                this.process_requestStatementId(requestId, input, output);
                return;
            }
            case "process_createSchemaTemplate": {
                this.process_createSchemaTemplate(requestId, input, output);
                return;
            }
            case "process_appendSchemaTemplate": {
                this.process_appendSchemaTemplate(requestId, input, output);
                return;
            }
            case "process_pruneSchemaTemplate": {
                this.process_pruneSchemaTemplate(requestId, input, output);
                return;
            }
            case "process_querySchemaTemplate": {
                this.process_querySchemaTemplate(requestId, input, output);
                return;
            }
            case "process_showConfigurationTemplate": {
                this.process_showConfigurationTemplate(requestId, input, output);
                return;
            }
            case "process_showConfiguration": {
                this.process_showConfiguration(requestId, input, output);
                return;
            }
            case "process_setSchemaTemplate": {
                this.process_setSchemaTemplate(requestId, input, output);
                return;
            }
            case "process_unsetSchemaTemplate": {
                this.process_unsetSchemaTemplate(requestId, input, output);
                return;
            }
            case "process_dropSchemaTemplate": {
                this.process_dropSchemaTemplate(requestId, input, output);
                return;
            }
            case "process_createTimeseriesUsingSchemaTemplate": {
                this.process_createTimeseriesUsingSchemaTemplate(requestId, input, output);
                return;
            }
            case "process_handshake": {
                this.process_handshake(requestId, input, output);
                return;
            }
            case "process_sendPipeData": {
                this.process_sendPipeData(requestId, input, output);
                return;
            }
            case "process_sendFile": {
                this.process_sendFile(requestId, input, output);
                return;
            }
            case "process_pipeTransfer": {
                this.process_pipeTransfer(requestId, input, output);
                return;
            }
            case "process_pipeSubscribe": {
                this.process_pipeSubscribe(requestId, input, output);
                return;
            }
            case "process_getBackupConfiguration": {
                this.process_getBackupConfiguration(requestId, input, output);
                return;
            }
            case "process_fetchAllConnectionsInfo": {
                this.process_fetchAllConnectionsInfo(requestId, input, output);
                return;
            }
            case "process_testConnectionEmptyRPC": {
                this.process_testConnectionEmptyRPC(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_executeQueryStatementV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteQueryStatementV2Args = ExecuteQueryStatementV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeQueryStatementV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteQueryStatementV2Result = new ExecuteQueryStatementV2Result({ success: data });
            output.writeMessageBegin("executeQueryStatementV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeQueryStatementV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeUpdateStatementV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteUpdateStatementV2Args = ExecuteUpdateStatementV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeUpdateStatementV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteUpdateStatementV2Result = new ExecuteUpdateStatementV2Result({ success: data });
            output.writeMessageBegin("executeUpdateStatementV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeUpdateStatementV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeStatementV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteStatementV2Args = ExecuteStatementV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeStatementV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteStatementV2Result = new ExecuteStatementV2Result({ success: data });
            output.writeMessageBegin("executeStatementV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeStatementV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeRawDataQueryV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteRawDataQueryV2Args = ExecuteRawDataQueryV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeRawDataQueryV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteRawDataQueryV2Result = new ExecuteRawDataQueryV2Result({ success: data });
            output.writeMessageBegin("executeRawDataQueryV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeRawDataQueryV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeLastDataQueryV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteLastDataQueryV2Args = ExecuteLastDataQueryV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeLastDataQueryV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteLastDataQueryV2Result = new ExecuteLastDataQueryV2Result({ success: data });
            output.writeMessageBegin("executeLastDataQueryV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeLastDataQueryV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeFastLastDataQueryForOneDeviceV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteFastLastDataQueryForOneDeviceV2Args = ExecuteFastLastDataQueryForOneDeviceV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeFastLastDataQueryForOneDeviceV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteFastLastDataQueryForOneDeviceV2Result = new ExecuteFastLastDataQueryForOneDeviceV2Result({ success: data });
            output.writeMessageBegin("executeFastLastDataQueryForOneDeviceV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeFastLastDataQueryForOneDeviceV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeAggregationQueryV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteAggregationQueryV2Args = ExecuteAggregationQueryV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeAggregationQueryV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteAggregationQueryV2Result = new ExecuteAggregationQueryV2Result({ success: data });
            output.writeMessageBegin("executeAggregationQueryV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeAggregationQueryV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeGroupByQueryIntervalQuery(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteGroupByQueryIntervalQueryArgs = ExecuteGroupByQueryIntervalQueryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeGroupByQueryIntervalQuery(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteGroupByQueryIntervalQueryResult = new ExecuteGroupByQueryIntervalQueryResult({ success: data });
            output.writeMessageBegin("executeGroupByQueryIntervalQuery", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeGroupByQueryIntervalQuery", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchResultsV2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSFetchResultsResp.TSFetchResultsResp>((resolve, reject): void => {
            try {
                const args: FetchResultsV2Args = FetchResultsV2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.fetchResultsV2(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSFetchResultsResp.TSFetchResultsResp): void => {
            const result: FetchResultsV2Result = new FetchResultsV2Result({ success: data });
            output.writeMessageBegin("fetchResultsV2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchResultsV2", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_openSession(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSOpenSessionResp.TSOpenSessionResp>((resolve, reject): void => {
            try {
                const args: OpenSessionArgs = OpenSessionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.openSession(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSOpenSessionResp.TSOpenSessionResp): void => {
            const result: OpenSessionResult = new OpenSessionResult({ success: data });
            output.writeMessageBegin("openSession", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("openSession", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_closeSession(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CloseSessionArgs = CloseSessionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.closeSession(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CloseSessionResult = new CloseSessionResult({ success: data });
            output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeStatement(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteStatementArgs = ExecuteStatementArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeStatement(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteStatementResult = new ExecuteStatementResult({ success: data });
            output.writeMessageBegin("executeStatement", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeStatement", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeBatchStatement(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ExecuteBatchStatementArgs = ExecuteBatchStatementArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeBatchStatement(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ExecuteBatchStatementResult = new ExecuteBatchStatementResult({ success: data });
            output.writeMessageBegin("executeBatchStatement", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeBatchStatement", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeQueryStatement(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteQueryStatementArgs = ExecuteQueryStatementArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeQueryStatement(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteQueryStatementResult = new ExecuteQueryStatementResult({ success: data });
            output.writeMessageBegin("executeQueryStatement", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeQueryStatement", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeUpdateStatement(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteUpdateStatementArgs = ExecuteUpdateStatementArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeUpdateStatement(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteUpdateStatementResult = new ExecuteUpdateStatementResult({ success: data });
            output.writeMessageBegin("executeUpdateStatement", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeUpdateStatement", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchResults(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSFetchResultsResp.TSFetchResultsResp>((resolve, reject): void => {
            try {
                const args: FetchResultsArgs = FetchResultsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.fetchResults(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSFetchResultsResp.TSFetchResultsResp): void => {
            const result: FetchResultsResult = new FetchResultsResult({ success: data });
            output.writeMessageBegin("fetchResults", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchResults", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchMetadata(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSFetchMetadataResp.TSFetchMetadataResp>((resolve, reject): void => {
            try {
                const args: FetchMetadataArgs = FetchMetadataArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.fetchMetadata(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSFetchMetadataResp.TSFetchMetadataResp): void => {
            const result: FetchMetadataResult = new FetchMetadataResult({ success: data });
            output.writeMessageBegin("fetchMetadata", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchMetadata", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_cancelOperation(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CancelOperationArgs = CancelOperationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cancelOperation(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CancelOperationResult = new CancelOperationResult({ success: data });
            output.writeMessageBegin("cancelOperation", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("cancelOperation", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_closeOperation(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CloseOperationArgs = CloseOperationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.closeOperation(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CloseOperationResult = new CloseOperationResult({ success: data });
            output.writeMessageBegin("closeOperation", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("closeOperation", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getTimeZone(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSGetTimeZoneResp.TSGetTimeZoneResp>((resolve, reject): void => {
            try {
                const args: GetTimeZoneArgs = GetTimeZoneArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getTimeZone(args.sessionId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSGetTimeZoneResp.TSGetTimeZoneResp): void => {
            const result: GetTimeZoneResult = new GetTimeZoneResult({ success: data });
            output.writeMessageBegin("getTimeZone", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getTimeZone", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setTimeZone(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetTimeZoneArgs = SetTimeZoneArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setTimeZone(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetTimeZoneResult = new SetTimeZoneResult({ success: data });
            output.writeMessageBegin("setTimeZone", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setTimeZone", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getProperties(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<ServerProperties.ServerProperties>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.getProperties());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ServerProperties.ServerProperties): void => {
            const result: GetPropertiesResult = new GetPropertiesResult({ success: data });
            output.writeMessageBegin("getProperties", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getProperties", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setStorageGroup(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetStorageGroupArgs = SetStorageGroupArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setStorageGroup(args.sessionId, args.storageGroup));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetStorageGroupResult = new SetStorageGroupResult({ success: data });
            output.writeMessageBegin("setStorageGroup", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setStorageGroup", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createTimeseries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateTimeseriesArgs = CreateTimeseriesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createTimeseries(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateTimeseriesResult = new CreateTimeseriesResult({ success: data });
            output.writeMessageBegin("createTimeseries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createTimeseries", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createAlignedTimeseries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateAlignedTimeseriesArgs = CreateAlignedTimeseriesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createAlignedTimeseries(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateAlignedTimeseriesResult = new CreateAlignedTimeseriesResult({ success: data });
            output.writeMessageBegin("createAlignedTimeseries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createAlignedTimeseries", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createMultiTimeseries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateMultiTimeseriesArgs = CreateMultiTimeseriesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createMultiTimeseries(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateMultiTimeseriesResult = new CreateMultiTimeseriesResult({ success: data });
            output.writeMessageBegin("createMultiTimeseries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createMultiTimeseries", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteTimeseries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteTimeseriesArgs = DeleteTimeseriesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteTimeseries(args.sessionId, args.path));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteTimeseriesResult = new DeleteTimeseriesResult({ success: data });
            output.writeMessageBegin("deleteTimeseries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteTimeseries", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteStorageGroups(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteStorageGroupsArgs = DeleteStorageGroupsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteStorageGroups(args.sessionId, args.storageGroup));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteStorageGroupsResult = new DeleteStorageGroupsResult({ success: data });
            output.writeMessageBegin("deleteStorageGroups", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteStorageGroups", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertRecord(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertRecordArgs = InsertRecordArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertRecord(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertRecordResult = new InsertRecordResult({ success: data });
            output.writeMessageBegin("insertRecord", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertRecord", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertStringRecord(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertStringRecordArgs = InsertStringRecordArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertStringRecord(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertStringRecordResult = new InsertStringRecordResult({ success: data });
            output.writeMessageBegin("insertStringRecord", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertStringRecord", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertTablet(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertTabletArgs = InsertTabletArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertTablet(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertTabletResult = new InsertTabletResult({ success: data });
            output.writeMessageBegin("insertTablet", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertTablet", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertTablets(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertTabletsArgs = InsertTabletsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertTablets(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertTabletsResult = new InsertTabletsResult({ success: data });
            output.writeMessageBegin("insertTablets", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertTablets", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertRecords(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertRecordsArgs = InsertRecordsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertRecords(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertRecordsResult = new InsertRecordsResult({ success: data });
            output.writeMessageBegin("insertRecords", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertRecords", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertRecordsOfOneDevice(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertRecordsOfOneDeviceArgs = InsertRecordsOfOneDeviceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertRecordsOfOneDevice(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertRecordsOfOneDeviceResult = new InsertRecordsOfOneDeviceResult({ success: data });
            output.writeMessageBegin("insertRecordsOfOneDevice", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertRecordsOfOneDevice", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertStringRecordsOfOneDevice(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertStringRecordsOfOneDeviceArgs = InsertStringRecordsOfOneDeviceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertStringRecordsOfOneDevice(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertStringRecordsOfOneDeviceResult = new InsertStringRecordsOfOneDeviceResult({ success: data });
            output.writeMessageBegin("insertStringRecordsOfOneDevice", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertStringRecordsOfOneDevice", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_insertStringRecords(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InsertStringRecordsArgs = InsertStringRecordsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.insertStringRecords(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InsertStringRecordsResult = new InsertStringRecordsResult({ success: data });
            output.writeMessageBegin("insertStringRecords", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("insertStringRecords", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testInsertTablet(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: TestInsertTabletArgs = TestInsertTabletArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.testInsertTablet(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestInsertTabletResult = new TestInsertTabletResult({ success: data });
            output.writeMessageBegin("testInsertTablet", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testInsertTablet", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testInsertTablets(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: TestInsertTabletsArgs = TestInsertTabletsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.testInsertTablets(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestInsertTabletsResult = new TestInsertTabletsResult({ success: data });
            output.writeMessageBegin("testInsertTablets", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testInsertTablets", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testInsertRecord(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: TestInsertRecordArgs = TestInsertRecordArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.testInsertRecord(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestInsertRecordResult = new TestInsertRecordResult({ success: data });
            output.writeMessageBegin("testInsertRecord", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testInsertRecord", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testInsertStringRecord(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: TestInsertStringRecordArgs = TestInsertStringRecordArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.testInsertStringRecord(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestInsertStringRecordResult = new TestInsertStringRecordResult({ success: data });
            output.writeMessageBegin("testInsertStringRecord", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testInsertStringRecord", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testInsertRecords(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: TestInsertRecordsArgs = TestInsertRecordsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.testInsertRecords(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestInsertRecordsResult = new TestInsertRecordsResult({ success: data });
            output.writeMessageBegin("testInsertRecords", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testInsertRecords", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testInsertRecordsOfOneDevice(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: TestInsertRecordsOfOneDeviceArgs = TestInsertRecordsOfOneDeviceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.testInsertRecordsOfOneDevice(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestInsertRecordsOfOneDeviceResult = new TestInsertRecordsOfOneDeviceResult({ success: data });
            output.writeMessageBegin("testInsertRecordsOfOneDevice", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testInsertRecordsOfOneDevice", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testInsertStringRecords(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: TestInsertStringRecordsArgs = TestInsertStringRecordsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.testInsertStringRecords(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestInsertStringRecordsResult = new TestInsertStringRecordsResult({ success: data });
            output.writeMessageBegin("testInsertStringRecords", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testInsertStringRecords", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteData(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteDataArgs = DeleteDataArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteData(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteDataResult = new DeleteDataResult({ success: data });
            output.writeMessageBegin("deleteData", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteData", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeRawDataQuery(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteRawDataQueryArgs = ExecuteRawDataQueryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeRawDataQuery(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteRawDataQueryResult = new ExecuteRawDataQueryResult({ success: data });
            output.writeMessageBegin("executeRawDataQuery", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeRawDataQuery", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeLastDataQuery(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteLastDataQueryArgs = ExecuteLastDataQueryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeLastDataQuery(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteLastDataQueryResult = new ExecuteLastDataQueryResult({ success: data });
            output.writeMessageBegin("executeLastDataQuery", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeLastDataQuery", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeAggregationQuery(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSExecuteStatementResp.TSExecuteStatementResp>((resolve, reject): void => {
            try {
                const args: ExecuteAggregationQueryArgs = ExecuteAggregationQueryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeAggregationQuery(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSExecuteStatementResp.TSExecuteStatementResp): void => {
            const result: ExecuteAggregationQueryResult = new ExecuteAggregationQueryResult({ success: data });
            output.writeMessageBegin("executeAggregationQuery", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeAggregationQuery", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_requestStatementId(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Int64>((resolve, reject): void => {
            try {
                const args: RequestStatementIdArgs = RequestStatementIdArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.requestStatementId(args.sessionId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Int64): void => {
            const result: RequestStatementIdResult = new RequestStatementIdResult({ success: data });
            output.writeMessageBegin("requestStatementId", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("requestStatementId", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createSchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateSchemaTemplateArgs = CreateSchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createSchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateSchemaTemplateResult = new CreateSchemaTemplateResult({ success: data });
            output.writeMessageBegin("createSchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createSchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_appendSchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: AppendSchemaTemplateArgs = AppendSchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.appendSchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: AppendSchemaTemplateResult = new AppendSchemaTemplateResult({ success: data });
            output.writeMessageBegin("appendSchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("appendSchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pruneSchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: PruneSchemaTemplateArgs = PruneSchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pruneSchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: PruneSchemaTemplateResult = new PruneSchemaTemplateResult({ success: data });
            output.writeMessageBegin("pruneSchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pruneSchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_querySchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSQueryTemplateResp.TSQueryTemplateResp>((resolve, reject): void => {
            try {
                const args: QuerySchemaTemplateArgs = QuerySchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.querySchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSQueryTemplateResp.TSQueryTemplateResp): void => {
            const result: QuerySchemaTemplateResult = new QuerySchemaTemplateResult({ success: data });
            output.writeMessageBegin("querySchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("querySchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_showConfigurationTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.showConfigurationTemplate());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TShowConfigurationTemplateResp): void => {
            const result: ShowConfigurationTemplateResult = new ShowConfigurationTemplateResult({ success: data });
            output.writeMessageBegin("showConfigurationTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("showConfigurationTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_showConfiguration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp>((resolve, reject): void => {
            try {
                const args: ShowConfigurationArgs = ShowConfigurationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.showConfiguration(args.nodeId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp): void => {
            const result: ShowConfigurationResult = new ShowConfigurationResult({ success: data });
            output.writeMessageBegin("showConfiguration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("showConfiguration", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setSchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetSchemaTemplateArgs = SetSchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setSchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetSchemaTemplateResult = new SetSchemaTemplateResult({ success: data });
            output.writeMessageBegin("setSchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setSchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_unsetSchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: UnsetSchemaTemplateArgs = UnsetSchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.unsetSchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: UnsetSchemaTemplateResult = new UnsetSchemaTemplateResult({ success: data });
            output.writeMessageBegin("unsetSchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("unsetSchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_dropSchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DropSchemaTemplateArgs = DropSchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.dropSchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DropSchemaTemplateResult = new DropSchemaTemplateResult({ success: data });
            output.writeMessageBegin("dropSchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("dropSchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createTimeseriesUsingSchemaTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateTimeseriesUsingSchemaTemplateArgs = CreateTimeseriesUsingSchemaTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createTimeseriesUsingSchemaTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateTimeseriesUsingSchemaTemplateResult = new CreateTimeseriesUsingSchemaTemplateResult({ success: data });
            output.writeMessageBegin("createTimeseriesUsingSchemaTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createTimeseriesUsingSchemaTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_handshake(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: HandshakeArgs = HandshakeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.handshake(args.info));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: HandshakeResult = new HandshakeResult({ success: data });
            output.writeMessageBegin("handshake", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("handshake", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_sendPipeData(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SendPipeDataArgs = SendPipeDataArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.sendPipeData(args.buff));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SendPipeDataResult = new SendPipeDataResult({ success: data });
            output.writeMessageBegin("sendPipeData", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("sendPipeData", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_sendFile(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SendFileArgs = SendFileArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.sendFile(args.metaInfo, args.buff));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SendFileResult = new SendFileResult({ success: data });
            output.writeMessageBegin("sendFile", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("sendFile", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pipeTransfer(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPipeTransferResp.TPipeTransferResp>((resolve, reject): void => {
            try {
                const args: PipeTransferArgs = PipeTransferArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pipeTransfer(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPipeTransferResp.TPipeTransferResp): void => {
            const result: PipeTransferResult = new PipeTransferResult({ success: data });
            output.writeMessageBegin("pipeTransfer", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pipeTransfer", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pipeSubscribe(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPipeSubscribeResp.TPipeSubscribeResp>((resolve, reject): void => {
            try {
                const args: PipeSubscribeArgs = PipeSubscribeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pipeSubscribe(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPipeSubscribeResp.TPipeSubscribeResp): void => {
            const result: PipeSubscribeResult = new PipeSubscribeResult({ success: data });
            output.writeMessageBegin("pipeSubscribe", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pipeSubscribe", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getBackupConfiguration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSBackupConfigurationResp.TSBackupConfigurationResp>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.getBackupConfiguration());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSBackupConfigurationResp.TSBackupConfigurationResp): void => {
            const result: GetBackupConfigurationResult = new GetBackupConfigurationResult({ success: data });
            output.writeMessageBegin("getBackupConfiguration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getBackupConfiguration", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchAllConnectionsInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSConnectionInfoResp.TSConnectionInfoResp>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.fetchAllConnectionsInfo());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSConnectionInfoResp.TSConnectionInfoResp): void => {
            const result: FetchAllConnectionsInfoResult = new FetchAllConnectionsInfoResult({ success: data });
            output.writeMessageBegin("fetchAllConnectionsInfo", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchAllConnectionsInfo", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testConnectionEmptyRPC(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.testConnectionEmptyRPC());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestConnectionEmptyRPCResult = new TestConnectionEmptyRPCResult({ success: data });
            output.writeMessageBegin("testConnectionEmptyRPC", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testConnectionEmptyRPC", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
}
