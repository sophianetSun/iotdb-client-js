/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import Int64 = require("node-int64");
import * as thrift from "thrift";
import * as TSendFragmentInstanceReq from "./TSendFragmentInstanceReq";
import * as TSendFragmentInstanceResp from "./TSendFragmentInstanceResp";
import * as TSendBatchPlanNodeReq from "./TSendBatchPlanNodeReq";
import * as TSendBatchPlanNodeResp from "./TSendBatchPlanNodeResp";
import * as TFetchFragmentInstanceInfoReq from "./TFetchFragmentInstanceInfoReq";
import * as TFragmentInstanceInfoResp from "./TFragmentInstanceInfoResp";
import * as TCancelQueryReq from "./TCancelQueryReq";
import * as TCancelResp from "./TCancelResp";
import * as TCancelPlanFragmentReq from "./TCancelPlanFragmentReq";
import * as TCancelFragmentInstanceReq from "./TCancelFragmentInstanceReq";
import * as TSchemaFetchRequest from "./TSchemaFetchRequest";
import * as TSchemaFetchResponse from "./TSchemaFetchResponse";
import * as TTsFilePieceReq from "./TTsFilePieceReq";
import * as TLoadResp from "./TLoadResp";
import * as TLoadCommandReq from "./TLoadCommandReq";
import * as TAttributeUpdateReq from "./TAttributeUpdateReq";
import * as org_apache_iotdb_common_rpc_thrift from "./../../../common/rpc/thrift";
import * as TCreateSchemaRegionReq from "./TCreateSchemaRegionReq";
import * as TCreateDataRegionReq from "./TCreateDataRegionReq";
import * as TInvalidateCacheReq from "./TInvalidateCacheReq";
import * as TRegionLeaderChangeReq from "./TRegionLeaderChangeReq";
import * as TRegionLeaderChangeResp from "./TRegionLeaderChangeResp";
import * as TCreatePeerReq from "./TCreatePeerReq";
import * as TMaintainPeerReq from "./TMaintainPeerReq";
import * as TResetPeerListReq from "./TResetPeerListReq";
import * as TRegionMigrateResult from "./TRegionMigrateResult";
import * as TNotifyRegionMigrationReq from "./TNotifyRegionMigrationReq";
import * as TCleanDataNodeCacheReq from "./TCleanDataNodeCacheReq";
import * as TDataNodeHeartbeatReq from "./TDataNodeHeartbeatReq";
import * as TDataNodeHeartbeatResp from "./TDataNodeHeartbeatResp";
import * as TRegionRouteReq from "./TRegionRouteReq";
import * as TCreateFunctionInstanceReq from "./TCreateFunctionInstanceReq";
import * as TDropFunctionInstanceReq from "./TDropFunctionInstanceReq";
import * as TCreateTriggerInstanceReq from "./TCreateTriggerInstanceReq";
import * as TActiveTriggerInstanceReq from "./TActiveTriggerInstanceReq";
import * as TInactiveTriggerInstanceReq from "./TInactiveTriggerInstanceReq";
import * as TDropTriggerInstanceReq from "./TDropTriggerInstanceReq";
import * as TUpdateTriggerLocationReq from "./TUpdateTriggerLocationReq";
import * as TFireTriggerReq from "./TFireTriggerReq";
import * as TFireTriggerResp from "./TFireTriggerResp";
import * as TInvalidatePermissionCacheReq from "./TInvalidatePermissionCacheReq";
import * as TCreatePipePluginInstanceReq from "./TCreatePipePluginInstanceReq";
import * as TDropPipePluginInstanceReq from "./TDropPipePluginInstanceReq";
import * as TUpdateTemplateReq from "./TUpdateTemplateReq";
import * as TConstructSchemaBlackListReq from "./TConstructSchemaBlackListReq";
import * as TRollbackSchemaBlackListReq from "./TRollbackSchemaBlackListReq";
import * as TInvalidateMatchedSchemaCacheReq from "./TInvalidateMatchedSchemaCacheReq";
import * as TFetchSchemaBlackListReq from "./TFetchSchemaBlackListReq";
import * as TFetchSchemaBlackListResp from "./TFetchSchemaBlackListResp";
import * as TDeleteDataForDeleteSchemaReq from "./TDeleteDataForDeleteSchemaReq";
import * as TDeleteTimeSeriesReq from "./TDeleteTimeSeriesReq";
import * as TConstructSchemaBlackListWithTemplateReq from "./TConstructSchemaBlackListWithTemplateReq";
import * as TRollbackSchemaBlackListWithTemplateReq from "./TRollbackSchemaBlackListWithTemplateReq";
import * as TDeactivateTemplateReq from "./TDeactivateTemplateReq";
import * as TCountPathsUsingTemplateReq from "./TCountPathsUsingTemplateReq";
import * as TCountPathsUsingTemplateResp from "./TCountPathsUsingTemplateResp";
import * as TCheckSchemaRegionUsingTemplateReq from "./TCheckSchemaRegionUsingTemplateReq";
import * as TCheckSchemaRegionUsingTemplateResp from "./TCheckSchemaRegionUsingTemplateResp";
import * as TCheckTimeSeriesExistenceReq from "./TCheckTimeSeriesExistenceReq";
import * as TCheckTimeSeriesExistenceResp from "./TCheckTimeSeriesExistenceResp";
import * as TConstructViewSchemaBlackListReq from "./TConstructViewSchemaBlackListReq";
import * as TRollbackViewSchemaBlackListReq from "./TRollbackViewSchemaBlackListReq";
import * as TDeleteViewSchemaReq from "./TDeleteViewSchemaReq";
import * as TAlterViewReq from "./TAlterViewReq";
import * as TPushPipeMetaReq from "./TPushPipeMetaReq";
import * as TPushPipeMetaResp from "./TPushPipeMetaResp";
import * as TPushSinglePipeMetaReq from "./TPushSinglePipeMetaReq";
import * as TPushMultiPipeMetaReq from "./TPushMultiPipeMetaReq";
import * as TPushTopicMetaReq from "./TPushTopicMetaReq";
import * as TPushTopicMetaResp from "./TPushTopicMetaResp";
import * as TPushSingleTopicMetaReq from "./TPushSingleTopicMetaReq";
import * as TPushMultiTopicMetaReq from "./TPushMultiTopicMetaReq";
import * as TPushConsumerGroupMetaReq from "./TPushConsumerGroupMetaReq";
import * as TPushConsumerGroupMetaResp from "./TPushConsumerGroupMetaResp";
import * as TPushSingleConsumerGroupMetaReq from "./TPushSingleConsumerGroupMetaReq";
import * as TPipeHeartbeatReq from "./TPipeHeartbeatReq";
import * as TPipeHeartbeatResp from "./TPipeHeartbeatResp";
import * as TExecuteCQ from "./TExecuteCQ";
import * as TFetchFragmentInstanceStatisticsReq from "./TFetchFragmentInstanceStatisticsReq";
import * as TFetchFragmentInstanceStatisticsResp from "./TFetchFragmentInstanceStatisticsResp";
import * as TUpdateTableReq from "./TUpdateTableReq";
import * as TInvalidateTableCacheReq from "./TInvalidateTableCacheReq";
import * as TDeleteDataOrDevicesForDropTableReq from "./TDeleteDataOrDevicesForDropTableReq";
import * as TInvalidateColumnCacheReq from "./TInvalidateColumnCacheReq";
import * as TDeleteColumnDataReq from "./TDeleteColumnDataReq";
import * as TTableDeviceDeletionWithPatternAndFilterReq from "./TTableDeviceDeletionWithPatternAndFilterReq";
import * as TTableDeviceDeletionWithPatternOrModReq from "./TTableDeviceDeletionWithPatternOrModReq";
import * as TTableDeviceInvalidateCacheReq from "./TTableDeviceInvalidateCacheReq";
export interface ISendFragmentInstanceArgsArgs {
    req: TSendFragmentInstanceReq.TSendFragmentInstanceReq;
}
export class SendFragmentInstanceArgs {
    public req: TSendFragmentInstanceReq.TSendFragmentInstanceReq;
    constructor(args: ISendFragmentInstanceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendFragmentInstanceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendFragmentInstanceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1: TSendFragmentInstanceReq.TSendFragmentInstanceReq = TSendFragmentInstanceReq.TSendFragmentInstanceReq.read(input);
                        _args.req = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SendFragmentInstanceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SendFragmentInstanceArgs from input");
        }
    }
}
export interface ISendBatchPlanNodeArgsArgs {
    req: TSendBatchPlanNodeReq.TSendBatchPlanNodeReq;
}
export class SendBatchPlanNodeArgs {
    public req: TSendBatchPlanNodeReq.TSendBatchPlanNodeReq;
    constructor(args: ISendBatchPlanNodeArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendBatchPlanNodeArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendBatchPlanNodeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_2: TSendBatchPlanNodeReq.TSendBatchPlanNodeReq = TSendBatchPlanNodeReq.TSendBatchPlanNodeReq.read(input);
                        _args.req = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SendBatchPlanNodeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SendBatchPlanNodeArgs from input");
        }
    }
}
export interface IFetchFragmentInstanceInfoArgsArgs {
    req: TFetchFragmentInstanceInfoReq.TFetchFragmentInstanceInfoReq;
}
export class FetchFragmentInstanceInfoArgs {
    public req: TFetchFragmentInstanceInfoReq.TFetchFragmentInstanceInfoReq;
    constructor(args: IFetchFragmentInstanceInfoArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchFragmentInstanceInfoArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchFragmentInstanceInfoArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_3: TFetchFragmentInstanceInfoReq.TFetchFragmentInstanceInfoReq = TFetchFragmentInstanceInfoReq.TFetchFragmentInstanceInfoReq.read(input);
                        _args.req = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FetchFragmentInstanceInfoArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FetchFragmentInstanceInfoArgs from input");
        }
    }
}
export interface ICancelQueryArgsArgs {
    req: TCancelQueryReq.TCancelQueryReq;
}
export class CancelQueryArgs {
    public req: TCancelQueryReq.TCancelQueryReq;
    constructor(args: ICancelQueryArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelQueryArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelQueryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_4: TCancelQueryReq.TCancelQueryReq = TCancelQueryReq.TCancelQueryReq.read(input);
                        _args.req = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CancelQueryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CancelQueryArgs from input");
        }
    }
}
export interface ICancelPlanFragmentArgsArgs {
    req: TCancelPlanFragmentReq.TCancelPlanFragmentReq;
}
export class CancelPlanFragmentArgs {
    public req: TCancelPlanFragmentReq.TCancelPlanFragmentReq;
    constructor(args: ICancelPlanFragmentArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelPlanFragmentArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelPlanFragmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_5: TCancelPlanFragmentReq.TCancelPlanFragmentReq = TCancelPlanFragmentReq.TCancelPlanFragmentReq.read(input);
                        _args.req = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CancelPlanFragmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CancelPlanFragmentArgs from input");
        }
    }
}
export interface ICancelFragmentInstanceArgsArgs {
    req: TCancelFragmentInstanceReq.TCancelFragmentInstanceReq;
}
export class CancelFragmentInstanceArgs {
    public req: TCancelFragmentInstanceReq.TCancelFragmentInstanceReq;
    constructor(args: ICancelFragmentInstanceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelFragmentInstanceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelFragmentInstanceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_6: TCancelFragmentInstanceReq.TCancelFragmentInstanceReq = TCancelFragmentInstanceReq.TCancelFragmentInstanceReq.read(input);
                        _args.req = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CancelFragmentInstanceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CancelFragmentInstanceArgs from input");
        }
    }
}
export interface IFetchSchemaArgsArgs {
    req: TSchemaFetchRequest.TSchemaFetchRequest;
}
export class FetchSchemaArgs {
    public req: TSchemaFetchRequest.TSchemaFetchRequest;
    constructor(args: IFetchSchemaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchSchemaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchSchemaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_7: TSchemaFetchRequest.TSchemaFetchRequest = TSchemaFetchRequest.TSchemaFetchRequest.read(input);
                        _args.req = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FetchSchemaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FetchSchemaArgs from input");
        }
    }
}
export interface ISendTsFilePieceNodeArgsArgs {
    req: TTsFilePieceReq.TTsFilePieceReq;
}
export class SendTsFilePieceNodeArgs {
    public req: TTsFilePieceReq.TTsFilePieceReq;
    constructor(args: ISendTsFilePieceNodeArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendTsFilePieceNodeArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendTsFilePieceNodeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_8: TTsFilePieceReq.TTsFilePieceReq = TTsFilePieceReq.TTsFilePieceReq.read(input);
                        _args.req = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SendTsFilePieceNodeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SendTsFilePieceNodeArgs from input");
        }
    }
}
export interface ISendLoadCommandArgsArgs {
    req: TLoadCommandReq.TLoadCommandReq;
}
export class SendLoadCommandArgs {
    public req: TLoadCommandReq.TLoadCommandReq;
    constructor(args: ISendLoadCommandArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendLoadCommandArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendLoadCommandArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_9: TLoadCommandReq.TLoadCommandReq = TLoadCommandReq.TLoadCommandReq.read(input);
                        _args.req = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SendLoadCommandArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SendLoadCommandArgs from input");
        }
    }
}
export interface IUpdateAttributeArgsArgs {
    req: TAttributeUpdateReq.TAttributeUpdateReq;
}
export class UpdateAttributeArgs {
    public req: TAttributeUpdateReq.TAttributeUpdateReq;
    constructor(args: IUpdateAttributeArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateAttributeArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateAttributeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_10: TAttributeUpdateReq.TAttributeUpdateReq = TAttributeUpdateReq.TAttributeUpdateReq.read(input);
                        _args.req = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new UpdateAttributeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateAttributeArgs from input");
        }
    }
}
export interface ICreateSchemaRegionArgsArgs {
    req: TCreateSchemaRegionReq.TCreateSchemaRegionReq;
}
export class CreateSchemaRegionArgs {
    public req: TCreateSchemaRegionReq.TCreateSchemaRegionReq;
    constructor(args: ICreateSchemaRegionArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateSchemaRegionArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateSchemaRegionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_11: TCreateSchemaRegionReq.TCreateSchemaRegionReq = TCreateSchemaRegionReq.TCreateSchemaRegionReq.read(input);
                        _args.req = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateSchemaRegionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateSchemaRegionArgs from input");
        }
    }
}
export interface ICreateDataRegionArgsArgs {
    req: TCreateDataRegionReq.TCreateDataRegionReq;
}
export class CreateDataRegionArgs {
    public req: TCreateDataRegionReq.TCreateDataRegionReq;
    constructor(args: ICreateDataRegionArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateDataRegionArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateDataRegionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_12: TCreateDataRegionReq.TCreateDataRegionReq = TCreateDataRegionReq.TCreateDataRegionReq.read(input);
                        _args.req = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateDataRegionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateDataRegionArgs from input");
        }
    }
}
export interface IInvalidatePartitionCacheArgsArgs {
    req: TInvalidateCacheReq.TInvalidateCacheReq;
}
export class InvalidatePartitionCacheArgs {
    public req: TInvalidateCacheReq.TInvalidateCacheReq;
    constructor(args: IInvalidatePartitionCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidatePartitionCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidatePartitionCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_13: TInvalidateCacheReq.TInvalidateCacheReq = TInvalidateCacheReq.TInvalidateCacheReq.read(input);
                        _args.req = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InvalidatePartitionCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidatePartitionCacheArgs from input");
        }
    }
}
export interface IInvalidateLastCacheArgsArgs {
    database: string;
}
export class InvalidateLastCacheArgs {
    public database: string;
    constructor(args: IInvalidateLastCacheArgsArgs) {
        if (args != null && args.database != null) {
            this.database = args.database;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[database] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateLastCacheArgs");
        if (this.database != null) {
            output.writeFieldBegin("database", thrift.Thrift.Type.STRING, -1);
            output.writeString(this.database);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateLastCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_14: string = input.readString();
                        _args.database = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.database !== undefined) {
            return new InvalidateLastCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidateLastCacheArgs from input");
        }
    }
}
export interface IInvalidateSchemaCacheArgsArgs {
    req: TInvalidateCacheReq.TInvalidateCacheReq;
}
export class InvalidateSchemaCacheArgs {
    public req: TInvalidateCacheReq.TInvalidateCacheReq;
    constructor(args: IInvalidateSchemaCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateSchemaCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateSchemaCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_15: TInvalidateCacheReq.TInvalidateCacheReq = TInvalidateCacheReq.TInvalidateCacheReq.read(input);
                        _args.req = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InvalidateSchemaCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidateSchemaCacheArgs from input");
        }
    }
}
export interface IDeleteRegionArgsArgs {
    consensusGroupId: org_apache_iotdb_common_rpc_thrift.TConsensusGroupId;
}
export class DeleteRegionArgs {
    public consensusGroupId: org_apache_iotdb_common_rpc_thrift.TConsensusGroupId;
    constructor(args: IDeleteRegionArgsArgs) {
        if (args != null && args.consensusGroupId != null) {
            this.consensusGroupId = args.consensusGroupId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[consensusGroupId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteRegionArgs");
        if (this.consensusGroupId != null) {
            output.writeFieldBegin("consensusGroupId", thrift.Thrift.Type.STRUCT, -1);
            this.consensusGroupId.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteRegionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_16: org_apache_iotdb_common_rpc_thrift.TConsensusGroupId = org_apache_iotdb_common_rpc_thrift.TConsensusGroupId.read(input);
                        _args.consensusGroupId = value_16;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.consensusGroupId !== undefined) {
            return new DeleteRegionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteRegionArgs from input");
        }
    }
}
export interface IChangeRegionLeaderArgsArgs {
    req: TRegionLeaderChangeReq.TRegionLeaderChangeReq;
}
export class ChangeRegionLeaderArgs {
    public req: TRegionLeaderChangeReq.TRegionLeaderChangeReq;
    constructor(args: IChangeRegionLeaderArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeRegionLeaderArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeRegionLeaderArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_17: TRegionLeaderChangeReq.TRegionLeaderChangeReq = TRegionLeaderChangeReq.TRegionLeaderChangeReq.read(input);
                        _args.req = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ChangeRegionLeaderArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeRegionLeaderArgs from input");
        }
    }
}
export interface ICreateNewRegionPeerArgsArgs {
    req: TCreatePeerReq.TCreatePeerReq;
}
export class CreateNewRegionPeerArgs {
    public req: TCreatePeerReq.TCreatePeerReq;
    constructor(args: ICreateNewRegionPeerArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateNewRegionPeerArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateNewRegionPeerArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_18: TCreatePeerReq.TCreatePeerReq = TCreatePeerReq.TCreatePeerReq.read(input);
                        _args.req = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateNewRegionPeerArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateNewRegionPeerArgs from input");
        }
    }
}
export interface IAddRegionPeerArgsArgs {
    req: TMaintainPeerReq.TMaintainPeerReq;
}
export class AddRegionPeerArgs {
    public req: TMaintainPeerReq.TMaintainPeerReq;
    constructor(args: IAddRegionPeerArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddRegionPeerArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddRegionPeerArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_19: TMaintainPeerReq.TMaintainPeerReq = TMaintainPeerReq.TMaintainPeerReq.read(input);
                        _args.req = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new AddRegionPeerArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddRegionPeerArgs from input");
        }
    }
}
export interface IRemoveRegionPeerArgsArgs {
    req: TMaintainPeerReq.TMaintainPeerReq;
}
export class RemoveRegionPeerArgs {
    public req: TMaintainPeerReq.TMaintainPeerReq;
    constructor(args: IRemoveRegionPeerArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveRegionPeerArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveRegionPeerArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_20: TMaintainPeerReq.TMaintainPeerReq = TMaintainPeerReq.TMaintainPeerReq.read(input);
                        _args.req = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new RemoveRegionPeerArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveRegionPeerArgs from input");
        }
    }
}
export interface IDeleteOldRegionPeerArgsArgs {
    req: TMaintainPeerReq.TMaintainPeerReq;
}
export class DeleteOldRegionPeerArgs {
    public req: TMaintainPeerReq.TMaintainPeerReq;
    constructor(args: IDeleteOldRegionPeerArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteOldRegionPeerArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteOldRegionPeerArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_21: TMaintainPeerReq.TMaintainPeerReq = TMaintainPeerReq.TMaintainPeerReq.read(input);
                        _args.req = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteOldRegionPeerArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteOldRegionPeerArgs from input");
        }
    }
}
export interface IResetPeerListArgsArgs {
    req: TResetPeerListReq.TResetPeerListReq;
}
export class ResetPeerListArgs {
    public req: TResetPeerListReq.TResetPeerListReq;
    constructor(args: IResetPeerListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResetPeerListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResetPeerListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_22: TResetPeerListReq.TResetPeerListReq = TResetPeerListReq.TResetPeerListReq.read(input);
                        _args.req = value_22;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ResetPeerListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResetPeerListArgs from input");
        }
    }
}
export interface IGetRegionMaintainResultArgsArgs {
    taskId: number | Int64;
}
export class GetRegionMaintainResultArgs {
    public taskId: Int64;
    constructor(args: IGetRegionMaintainResultArgsArgs) {
        if (args != null && args.taskId != null) {
            if (typeof args.taskId === "number") {
                this.taskId = new Int64(args.taskId);
            }
            else {
                this.taskId = args.taskId;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[taskId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetRegionMaintainResultArgs");
        if (this.taskId != null) {
            output.writeFieldBegin("taskId", thrift.Thrift.Type.I64, -1);
            output.writeI64(this.taskId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetRegionMaintainResultArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_23: Int64 = input.readI64();
                        _args.taskId = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.taskId !== undefined) {
            return new GetRegionMaintainResultArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetRegionMaintainResultArgs from input");
        }
    }
}
export interface INotifyRegionMigrationArgsArgs {
    req: TNotifyRegionMigrationReq.TNotifyRegionMigrationReq;
}
export class NotifyRegionMigrationArgs {
    public req: TNotifyRegionMigrationReq.TNotifyRegionMigrationReq;
    constructor(args: INotifyRegionMigrationArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("NotifyRegionMigrationArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): NotifyRegionMigrationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_24: TNotifyRegionMigrationReq.TNotifyRegionMigrationReq = TNotifyRegionMigrationReq.TNotifyRegionMigrationReq.read(input);
                        _args.req = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new NotifyRegionMigrationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read NotifyRegionMigrationArgs from input");
        }
    }
}
export interface ICleanDataNodeCacheArgsArgs {
    req: TCleanDataNodeCacheReq.TCleanDataNodeCacheReq;
}
export class CleanDataNodeCacheArgs {
    public req: TCleanDataNodeCacheReq.TCleanDataNodeCacheReq;
    constructor(args: ICleanDataNodeCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CleanDataNodeCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CleanDataNodeCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_25: TCleanDataNodeCacheReq.TCleanDataNodeCacheReq = TCleanDataNodeCacheReq.TCleanDataNodeCacheReq.read(input);
                        _args.req = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CleanDataNodeCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CleanDataNodeCacheArgs from input");
        }
    }
}
export interface IStopAndClearDataNodeArgsArgs {
}
export class StopAndClearDataNodeArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("StopAndClearDataNodeArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): StopAndClearDataNodeArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new StopAndClearDataNodeArgs();
    }
}
export interface IGetDataNodeHeartBeatArgsArgs {
    req: TDataNodeHeartbeatReq.TDataNodeHeartbeatReq;
}
export class GetDataNodeHeartBeatArgs {
    public req: TDataNodeHeartbeatReq.TDataNodeHeartbeatReq;
    constructor(args: IGetDataNodeHeartBeatArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDataNodeHeartBeatArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDataNodeHeartBeatArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_26: TDataNodeHeartbeatReq.TDataNodeHeartbeatReq = TDataNodeHeartbeatReq.TDataNodeHeartbeatReq.read(input);
                        _args.req = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new GetDataNodeHeartBeatArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDataNodeHeartBeatArgs from input");
        }
    }
}
export interface IUpdateRegionCacheArgsArgs {
    req: TRegionRouteReq.TRegionRouteReq;
}
export class UpdateRegionCacheArgs {
    public req: TRegionRouteReq.TRegionRouteReq;
    constructor(args: IUpdateRegionCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateRegionCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateRegionCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_27: TRegionRouteReq.TRegionRouteReq = TRegionRouteReq.TRegionRouteReq.read(input);
                        _args.req = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new UpdateRegionCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateRegionCacheArgs from input");
        }
    }
}
export interface ICreateFunctionArgsArgs {
    req: TCreateFunctionInstanceReq.TCreateFunctionInstanceReq;
}
export class CreateFunctionArgs {
    public req: TCreateFunctionInstanceReq.TCreateFunctionInstanceReq;
    constructor(args: ICreateFunctionArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateFunctionArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateFunctionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_28: TCreateFunctionInstanceReq.TCreateFunctionInstanceReq = TCreateFunctionInstanceReq.TCreateFunctionInstanceReq.read(input);
                        _args.req = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateFunctionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateFunctionArgs from input");
        }
    }
}
export interface IDropFunctionArgsArgs {
    req: TDropFunctionInstanceReq.TDropFunctionInstanceReq;
}
export class DropFunctionArgs {
    public req: TDropFunctionInstanceReq.TDropFunctionInstanceReq;
    constructor(args: IDropFunctionArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropFunctionArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropFunctionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_29: TDropFunctionInstanceReq.TDropFunctionInstanceReq = TDropFunctionInstanceReq.TDropFunctionInstanceReq.read(input);
                        _args.req = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DropFunctionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DropFunctionArgs from input");
        }
    }
}
export interface ICreateTriggerInstanceArgsArgs {
    req: TCreateTriggerInstanceReq.TCreateTriggerInstanceReq;
}
export class CreateTriggerInstanceArgs {
    public req: TCreateTriggerInstanceReq.TCreateTriggerInstanceReq;
    constructor(args: ICreateTriggerInstanceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateTriggerInstanceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateTriggerInstanceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_30: TCreateTriggerInstanceReq.TCreateTriggerInstanceReq = TCreateTriggerInstanceReq.TCreateTriggerInstanceReq.read(input);
                        _args.req = value_30;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreateTriggerInstanceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateTriggerInstanceArgs from input");
        }
    }
}
export interface IActiveTriggerInstanceArgsArgs {
    req: TActiveTriggerInstanceReq.TActiveTriggerInstanceReq;
}
export class ActiveTriggerInstanceArgs {
    public req: TActiveTriggerInstanceReq.TActiveTriggerInstanceReq;
    constructor(args: IActiveTriggerInstanceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ActiveTriggerInstanceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ActiveTriggerInstanceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_31: TActiveTriggerInstanceReq.TActiveTriggerInstanceReq = TActiveTriggerInstanceReq.TActiveTriggerInstanceReq.read(input);
                        _args.req = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ActiveTriggerInstanceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ActiveTriggerInstanceArgs from input");
        }
    }
}
export interface IInactiveTriggerInstanceArgsArgs {
    req: TInactiveTriggerInstanceReq.TInactiveTriggerInstanceReq;
}
export class InactiveTriggerInstanceArgs {
    public req: TInactiveTriggerInstanceReq.TInactiveTriggerInstanceReq;
    constructor(args: IInactiveTriggerInstanceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InactiveTriggerInstanceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InactiveTriggerInstanceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_32: TInactiveTriggerInstanceReq.TInactiveTriggerInstanceReq = TInactiveTriggerInstanceReq.TInactiveTriggerInstanceReq.read(input);
                        _args.req = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InactiveTriggerInstanceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InactiveTriggerInstanceArgs from input");
        }
    }
}
export interface IDropTriggerInstanceArgsArgs {
    req: TDropTriggerInstanceReq.TDropTriggerInstanceReq;
}
export class DropTriggerInstanceArgs {
    public req: TDropTriggerInstanceReq.TDropTriggerInstanceReq;
    constructor(args: IDropTriggerInstanceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropTriggerInstanceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropTriggerInstanceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_33: TDropTriggerInstanceReq.TDropTriggerInstanceReq = TDropTriggerInstanceReq.TDropTriggerInstanceReq.read(input);
                        _args.req = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DropTriggerInstanceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DropTriggerInstanceArgs from input");
        }
    }
}
export interface IUpdateTriggerLocationArgsArgs {
    req: TUpdateTriggerLocationReq.TUpdateTriggerLocationReq;
}
export class UpdateTriggerLocationArgs {
    public req: TUpdateTriggerLocationReq.TUpdateTriggerLocationReq;
    constructor(args: IUpdateTriggerLocationArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTriggerLocationArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTriggerLocationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_34: TUpdateTriggerLocationReq.TUpdateTriggerLocationReq = TUpdateTriggerLocationReq.TUpdateTriggerLocationReq.read(input);
                        _args.req = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new UpdateTriggerLocationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateTriggerLocationArgs from input");
        }
    }
}
export interface IFireTriggerArgsArgs {
    req: TFireTriggerReq.TFireTriggerReq;
}
export class FireTriggerArgs {
    public req: TFireTriggerReq.TFireTriggerReq;
    constructor(args: IFireTriggerArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FireTriggerArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FireTriggerArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_35: TFireTriggerReq.TFireTriggerReq = TFireTriggerReq.TFireTriggerReq.read(input);
                        _args.req = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FireTriggerArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FireTriggerArgs from input");
        }
    }
}
export interface IInvalidatePermissionCacheArgsArgs {
    req: TInvalidatePermissionCacheReq.TInvalidatePermissionCacheReq;
}
export class InvalidatePermissionCacheArgs {
    public req: TInvalidatePermissionCacheReq.TInvalidatePermissionCacheReq;
    constructor(args: IInvalidatePermissionCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidatePermissionCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidatePermissionCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_36: TInvalidatePermissionCacheReq.TInvalidatePermissionCacheReq = TInvalidatePermissionCacheReq.TInvalidatePermissionCacheReq.read(input);
                        _args.req = value_36;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InvalidatePermissionCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidatePermissionCacheArgs from input");
        }
    }
}
export interface ICreatePipePluginArgsArgs {
    req: TCreatePipePluginInstanceReq.TCreatePipePluginInstanceReq;
}
export class CreatePipePluginArgs {
    public req: TCreatePipePluginInstanceReq.TCreatePipePluginInstanceReq;
    constructor(args: ICreatePipePluginArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreatePipePluginArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreatePipePluginArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_37: TCreatePipePluginInstanceReq.TCreatePipePluginInstanceReq = TCreatePipePluginInstanceReq.TCreatePipePluginInstanceReq.read(input);
                        _args.req = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CreatePipePluginArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreatePipePluginArgs from input");
        }
    }
}
export interface IDropPipePluginArgsArgs {
    req: TDropPipePluginInstanceReq.TDropPipePluginInstanceReq;
}
export class DropPipePluginArgs {
    public req: TDropPipePluginInstanceReq.TDropPipePluginInstanceReq;
    constructor(args: IDropPipePluginArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropPipePluginArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropPipePluginArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_38: TDropPipePluginInstanceReq.TDropPipePluginInstanceReq = TDropPipePluginInstanceReq.TDropPipePluginInstanceReq.read(input);
                        _args.req = value_38;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DropPipePluginArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DropPipePluginArgs from input");
        }
    }
}
export interface IMergeArgsArgs {
}
export class MergeArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MergeArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MergeArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MergeArgs();
    }
}
export interface IFlushArgsArgs {
    req: org_apache_iotdb_common_rpc_thrift.TFlushReq;
}
export class FlushArgs {
    public req: org_apache_iotdb_common_rpc_thrift.TFlushReq;
    constructor(args: IFlushArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FlushArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FlushArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_39: org_apache_iotdb_common_rpc_thrift.TFlushReq = org_apache_iotdb_common_rpc_thrift.TFlushReq.read(input);
                        _args.req = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FlushArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FlushArgs from input");
        }
    }
}
export interface ISettleArgsArgs {
    req: org_apache_iotdb_common_rpc_thrift.TSettleReq;
}
export class SettleArgs {
    public req: org_apache_iotdb_common_rpc_thrift.TSettleReq;
    constructor(args: ISettleArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SettleArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SettleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_40: org_apache_iotdb_common_rpc_thrift.TSettleReq = org_apache_iotdb_common_rpc_thrift.TSettleReq.read(input);
                        _args.req = value_40;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SettleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SettleArgs from input");
        }
    }
}
export interface IStartRepairDataArgsArgs {
}
export class StartRepairDataArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("StartRepairDataArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): StartRepairDataArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new StartRepairDataArgs();
    }
}
export interface IStopRepairDataArgsArgs {
}
export class StopRepairDataArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("StopRepairDataArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): StopRepairDataArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new StopRepairDataArgs();
    }
}
export interface IClearCacheArgsArgs {
    cacheClearOptions: Set<number>;
}
export class ClearCacheArgs {
    public cacheClearOptions: Set<number>;
    constructor(args: IClearCacheArgsArgs) {
        if (args != null && args.cacheClearOptions != null) {
            this.cacheClearOptions = args.cacheClearOptions;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cacheClearOptions] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ClearCacheArgs");
        if (this.cacheClearOptions != null) {
            output.writeFieldBegin("cacheClearOptions", thrift.Thrift.Type.SET, -1);
            output.writeSetBegin(thrift.Thrift.Type.I32, this.cacheClearOptions.size);
            this.cacheClearOptions.forEach((value_41: number): void => {
                output.writeI32(value_41);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ClearCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_42: Set<number> = new Set<number>();
                        const metadata_1: thrift.TSet = input.readSetBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_43: number = input.readI32();
                            value_42.add(value_43);
                        }
                        input.readSetEnd();
                        _args.cacheClearOptions = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.cacheClearOptions !== undefined) {
            return new ClearCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ClearCacheArgs from input");
        }
    }
}
export interface IShowConfigurationArgsArgs {
}
export class ShowConfigurationArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShowConfigurationArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShowConfigurationArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ShowConfigurationArgs();
    }
}
export interface ISetConfigurationArgsArgs {
    req: org_apache_iotdb_common_rpc_thrift.TSetConfigurationReq;
}
export class SetConfigurationArgs {
    public req: org_apache_iotdb_common_rpc_thrift.TSetConfigurationReq;
    constructor(args: ISetConfigurationArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetConfigurationArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetConfigurationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_44: org_apache_iotdb_common_rpc_thrift.TSetConfigurationReq = org_apache_iotdb_common_rpc_thrift.TSetConfigurationReq.read(input);
                        _args.req = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SetConfigurationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetConfigurationArgs from input");
        }
    }
}
export interface ILoadConfigurationArgsArgs {
}
export class LoadConfigurationArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("LoadConfigurationArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): LoadConfigurationArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new LoadConfigurationArgs();
    }
}
export interface ISetSystemStatusArgsArgs {
    status: string;
}
export class SetSystemStatusArgs {
    public status: string;
    constructor(args: ISetSystemStatusArgsArgs) {
        if (args != null && args.status != null) {
            this.status = args.status;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[status] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetSystemStatusArgs");
        if (this.status != null) {
            output.writeFieldBegin("status", thrift.Thrift.Type.STRING, -1);
            output.writeString(this.status);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetSystemStatusArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_45: string = input.readString();
                        _args.status = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.status !== undefined) {
            return new SetSystemStatusArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetSystemStatusArgs from input");
        }
    }
}
export interface IKillQueryInstanceArgsArgs {
    queryId: string;
}
export class KillQueryInstanceArgs {
    public queryId: string;
    constructor(args: IKillQueryInstanceArgsArgs) {
        if (args != null && args.queryId != null) {
            this.queryId = args.queryId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[queryId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("KillQueryInstanceArgs");
        if (this.queryId != null) {
            output.writeFieldBegin("queryId", thrift.Thrift.Type.STRING, -1);
            output.writeString(this.queryId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): KillQueryInstanceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_46: string = input.readString();
                        _args.queryId = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.queryId !== undefined) {
            return new KillQueryInstanceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read KillQueryInstanceArgs from input");
        }
    }
}
export interface ISetTTLArgsArgs {
    req: org_apache_iotdb_common_rpc_thrift.TSetTTLReq;
}
export class SetTTLArgs {
    public req: org_apache_iotdb_common_rpc_thrift.TSetTTLReq;
    constructor(args: ISetTTLArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetTTLArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetTTLArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_47: org_apache_iotdb_common_rpc_thrift.TSetTTLReq = org_apache_iotdb_common_rpc_thrift.TSetTTLReq.read(input);
                        _args.req = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SetTTLArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetTTLArgs from input");
        }
    }
}
export interface IUpdateTemplateArgsArgs {
    req: TUpdateTemplateReq.TUpdateTemplateReq;
}
export class UpdateTemplateArgs {
    public req: TUpdateTemplateReq.TUpdateTemplateReq;
    constructor(args: IUpdateTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_48: TUpdateTemplateReq.TUpdateTemplateReq = TUpdateTemplateReq.TUpdateTemplateReq.read(input);
                        _args.req = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new UpdateTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateTemplateArgs from input");
        }
    }
}
export interface IConstructSchemaBlackListArgsArgs {
    req: TConstructSchemaBlackListReq.TConstructSchemaBlackListReq;
}
export class ConstructSchemaBlackListArgs {
    public req: TConstructSchemaBlackListReq.TConstructSchemaBlackListReq;
    constructor(args: IConstructSchemaBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructSchemaBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructSchemaBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_49: TConstructSchemaBlackListReq.TConstructSchemaBlackListReq = TConstructSchemaBlackListReq.TConstructSchemaBlackListReq.read(input);
                        _args.req = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ConstructSchemaBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ConstructSchemaBlackListArgs from input");
        }
    }
}
export interface IRollbackSchemaBlackListArgsArgs {
    req: TRollbackSchemaBlackListReq.TRollbackSchemaBlackListReq;
}
export class RollbackSchemaBlackListArgs {
    public req: TRollbackSchemaBlackListReq.TRollbackSchemaBlackListReq;
    constructor(args: IRollbackSchemaBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackSchemaBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackSchemaBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_50: TRollbackSchemaBlackListReq.TRollbackSchemaBlackListReq = TRollbackSchemaBlackListReq.TRollbackSchemaBlackListReq.read(input);
                        _args.req = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new RollbackSchemaBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RollbackSchemaBlackListArgs from input");
        }
    }
}
export interface IInvalidateMatchedSchemaCacheArgsArgs {
    req: TInvalidateMatchedSchemaCacheReq.TInvalidateMatchedSchemaCacheReq;
}
export class InvalidateMatchedSchemaCacheArgs {
    public req: TInvalidateMatchedSchemaCacheReq.TInvalidateMatchedSchemaCacheReq;
    constructor(args: IInvalidateMatchedSchemaCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateMatchedSchemaCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateMatchedSchemaCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_51: TInvalidateMatchedSchemaCacheReq.TInvalidateMatchedSchemaCacheReq = TInvalidateMatchedSchemaCacheReq.TInvalidateMatchedSchemaCacheReq.read(input);
                        _args.req = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InvalidateMatchedSchemaCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidateMatchedSchemaCacheArgs from input");
        }
    }
}
export interface IFetchSchemaBlackListArgsArgs {
    req: TFetchSchemaBlackListReq.TFetchSchemaBlackListReq;
}
export class FetchSchemaBlackListArgs {
    public req: TFetchSchemaBlackListReq.TFetchSchemaBlackListReq;
    constructor(args: IFetchSchemaBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchSchemaBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchSchemaBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_52: TFetchSchemaBlackListReq.TFetchSchemaBlackListReq = TFetchSchemaBlackListReq.TFetchSchemaBlackListReq.read(input);
                        _args.req = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FetchSchemaBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FetchSchemaBlackListArgs from input");
        }
    }
}
export interface IDeleteDataForDeleteSchemaArgsArgs {
    req: TDeleteDataForDeleteSchemaReq.TDeleteDataForDeleteSchemaReq;
}
export class DeleteDataForDeleteSchemaArgs {
    public req: TDeleteDataForDeleteSchemaReq.TDeleteDataForDeleteSchemaReq;
    constructor(args: IDeleteDataForDeleteSchemaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataForDeleteSchemaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataForDeleteSchemaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_53: TDeleteDataForDeleteSchemaReq.TDeleteDataForDeleteSchemaReq = TDeleteDataForDeleteSchemaReq.TDeleteDataForDeleteSchemaReq.read(input);
                        _args.req = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteDataForDeleteSchemaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteDataForDeleteSchemaArgs from input");
        }
    }
}
export interface IDeleteTimeSeriesArgsArgs {
    req: TDeleteTimeSeriesReq.TDeleteTimeSeriesReq;
}
export class DeleteTimeSeriesArgs {
    public req: TDeleteTimeSeriesReq.TDeleteTimeSeriesReq;
    constructor(args: IDeleteTimeSeriesArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteTimeSeriesArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteTimeSeriesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_54: TDeleteTimeSeriesReq.TDeleteTimeSeriesReq = TDeleteTimeSeriesReq.TDeleteTimeSeriesReq.read(input);
                        _args.req = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteTimeSeriesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteTimeSeriesArgs from input");
        }
    }
}
export interface IConstructSchemaBlackListWithTemplateArgsArgs {
    req: TConstructSchemaBlackListWithTemplateReq.TConstructSchemaBlackListWithTemplateReq;
}
export class ConstructSchemaBlackListWithTemplateArgs {
    public req: TConstructSchemaBlackListWithTemplateReq.TConstructSchemaBlackListWithTemplateReq;
    constructor(args: IConstructSchemaBlackListWithTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructSchemaBlackListWithTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructSchemaBlackListWithTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_55: TConstructSchemaBlackListWithTemplateReq.TConstructSchemaBlackListWithTemplateReq = TConstructSchemaBlackListWithTemplateReq.TConstructSchemaBlackListWithTemplateReq.read(input);
                        _args.req = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ConstructSchemaBlackListWithTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ConstructSchemaBlackListWithTemplateArgs from input");
        }
    }
}
export interface IRollbackSchemaBlackListWithTemplateArgsArgs {
    req: TRollbackSchemaBlackListWithTemplateReq.TRollbackSchemaBlackListWithTemplateReq;
}
export class RollbackSchemaBlackListWithTemplateArgs {
    public req: TRollbackSchemaBlackListWithTemplateReq.TRollbackSchemaBlackListWithTemplateReq;
    constructor(args: IRollbackSchemaBlackListWithTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackSchemaBlackListWithTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackSchemaBlackListWithTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_56: TRollbackSchemaBlackListWithTemplateReq.TRollbackSchemaBlackListWithTemplateReq = TRollbackSchemaBlackListWithTemplateReq.TRollbackSchemaBlackListWithTemplateReq.read(input);
                        _args.req = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new RollbackSchemaBlackListWithTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RollbackSchemaBlackListWithTemplateArgs from input");
        }
    }
}
export interface IDeactivateTemplateArgsArgs {
    req: TDeactivateTemplateReq.TDeactivateTemplateReq;
}
export class DeactivateTemplateArgs {
    public req: TDeactivateTemplateReq.TDeactivateTemplateReq;
    constructor(args: IDeactivateTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeactivateTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeactivateTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_57: TDeactivateTemplateReq.TDeactivateTemplateReq = TDeactivateTemplateReq.TDeactivateTemplateReq.read(input);
                        _args.req = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeactivateTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeactivateTemplateArgs from input");
        }
    }
}
export interface ICountPathsUsingTemplateArgsArgs {
    req: TCountPathsUsingTemplateReq.TCountPathsUsingTemplateReq;
}
export class CountPathsUsingTemplateArgs {
    public req: TCountPathsUsingTemplateReq.TCountPathsUsingTemplateReq;
    constructor(args: ICountPathsUsingTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CountPathsUsingTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CountPathsUsingTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_58: TCountPathsUsingTemplateReq.TCountPathsUsingTemplateReq = TCountPathsUsingTemplateReq.TCountPathsUsingTemplateReq.read(input);
                        _args.req = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CountPathsUsingTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CountPathsUsingTemplateArgs from input");
        }
    }
}
export interface ICheckSchemaRegionUsingTemplateArgsArgs {
    req: TCheckSchemaRegionUsingTemplateReq.TCheckSchemaRegionUsingTemplateReq;
}
export class CheckSchemaRegionUsingTemplateArgs {
    public req: TCheckSchemaRegionUsingTemplateReq.TCheckSchemaRegionUsingTemplateReq;
    constructor(args: ICheckSchemaRegionUsingTemplateArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckSchemaRegionUsingTemplateArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckSchemaRegionUsingTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_59: TCheckSchemaRegionUsingTemplateReq.TCheckSchemaRegionUsingTemplateReq = TCheckSchemaRegionUsingTemplateReq.TCheckSchemaRegionUsingTemplateReq.read(input);
                        _args.req = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CheckSchemaRegionUsingTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckSchemaRegionUsingTemplateArgs from input");
        }
    }
}
export interface ICheckTimeSeriesExistenceArgsArgs {
    req: TCheckTimeSeriesExistenceReq.TCheckTimeSeriesExistenceReq;
}
export class CheckTimeSeriesExistenceArgs {
    public req: TCheckTimeSeriesExistenceReq.TCheckTimeSeriesExistenceReq;
    constructor(args: ICheckTimeSeriesExistenceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckTimeSeriesExistenceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckTimeSeriesExistenceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_60: TCheckTimeSeriesExistenceReq.TCheckTimeSeriesExistenceReq = TCheckTimeSeriesExistenceReq.TCheckTimeSeriesExistenceReq.read(input);
                        _args.req = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new CheckTimeSeriesExistenceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckTimeSeriesExistenceArgs from input");
        }
    }
}
export interface IConstructViewSchemaBlackListArgsArgs {
    req: TConstructViewSchemaBlackListReq.TConstructViewSchemaBlackListReq;
}
export class ConstructViewSchemaBlackListArgs {
    public req: TConstructViewSchemaBlackListReq.TConstructViewSchemaBlackListReq;
    constructor(args: IConstructViewSchemaBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructViewSchemaBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructViewSchemaBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_61: TConstructViewSchemaBlackListReq.TConstructViewSchemaBlackListReq = TConstructViewSchemaBlackListReq.TConstructViewSchemaBlackListReq.read(input);
                        _args.req = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ConstructViewSchemaBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ConstructViewSchemaBlackListArgs from input");
        }
    }
}
export interface IRollbackViewSchemaBlackListArgsArgs {
    req: TRollbackViewSchemaBlackListReq.TRollbackViewSchemaBlackListReq;
}
export class RollbackViewSchemaBlackListArgs {
    public req: TRollbackViewSchemaBlackListReq.TRollbackViewSchemaBlackListReq;
    constructor(args: IRollbackViewSchemaBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackViewSchemaBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackViewSchemaBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_62: TRollbackViewSchemaBlackListReq.TRollbackViewSchemaBlackListReq = TRollbackViewSchemaBlackListReq.TRollbackViewSchemaBlackListReq.read(input);
                        _args.req = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new RollbackViewSchemaBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RollbackViewSchemaBlackListArgs from input");
        }
    }
}
export interface IDeleteViewSchemaArgsArgs {
    req: TDeleteViewSchemaReq.TDeleteViewSchemaReq;
}
export class DeleteViewSchemaArgs {
    public req: TDeleteViewSchemaReq.TDeleteViewSchemaReq;
    constructor(args: IDeleteViewSchemaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteViewSchemaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteViewSchemaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_63: TDeleteViewSchemaReq.TDeleteViewSchemaReq = TDeleteViewSchemaReq.TDeleteViewSchemaReq.read(input);
                        _args.req = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteViewSchemaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteViewSchemaArgs from input");
        }
    }
}
export interface IAlterViewArgsArgs {
    req: TAlterViewReq.TAlterViewReq;
}
export class AlterViewArgs {
    public req: TAlterViewReq.TAlterViewReq;
    constructor(args: IAlterViewArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AlterViewArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AlterViewArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_64: TAlterViewReq.TAlterViewReq = TAlterViewReq.TAlterViewReq.read(input);
                        _args.req = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new AlterViewArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AlterViewArgs from input");
        }
    }
}
export interface IPushPipeMetaArgsArgs {
    req: TPushPipeMetaReq.TPushPipeMetaReq;
}
export class PushPipeMetaArgs {
    public req: TPushPipeMetaReq.TPushPipeMetaReq;
    constructor(args: IPushPipeMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushPipeMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushPipeMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_65: TPushPipeMetaReq.TPushPipeMetaReq = TPushPipeMetaReq.TPushPipeMetaReq.read(input);
                        _args.req = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushPipeMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushPipeMetaArgs from input");
        }
    }
}
export interface IPushSinglePipeMetaArgsArgs {
    req: TPushSinglePipeMetaReq.TPushSinglePipeMetaReq;
}
export class PushSinglePipeMetaArgs {
    public req: TPushSinglePipeMetaReq.TPushSinglePipeMetaReq;
    constructor(args: IPushSinglePipeMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushSinglePipeMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushSinglePipeMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_66: TPushSinglePipeMetaReq.TPushSinglePipeMetaReq = TPushSinglePipeMetaReq.TPushSinglePipeMetaReq.read(input);
                        _args.req = value_66;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushSinglePipeMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushSinglePipeMetaArgs from input");
        }
    }
}
export interface IPushMultiPipeMetaArgsArgs {
    req: TPushMultiPipeMetaReq.TPushMultiPipeMetaReq;
}
export class PushMultiPipeMetaArgs {
    public req: TPushMultiPipeMetaReq.TPushMultiPipeMetaReq;
    constructor(args: IPushMultiPipeMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushMultiPipeMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushMultiPipeMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_67: TPushMultiPipeMetaReq.TPushMultiPipeMetaReq = TPushMultiPipeMetaReq.TPushMultiPipeMetaReq.read(input);
                        _args.req = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushMultiPipeMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushMultiPipeMetaArgs from input");
        }
    }
}
export interface IPushTopicMetaArgsArgs {
    req: TPushTopicMetaReq.TPushTopicMetaReq;
}
export class PushTopicMetaArgs {
    public req: TPushTopicMetaReq.TPushTopicMetaReq;
    constructor(args: IPushTopicMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushTopicMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushTopicMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_68: TPushTopicMetaReq.TPushTopicMetaReq = TPushTopicMetaReq.TPushTopicMetaReq.read(input);
                        _args.req = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushTopicMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushTopicMetaArgs from input");
        }
    }
}
export interface IPushSingleTopicMetaArgsArgs {
    req: TPushSingleTopicMetaReq.TPushSingleTopicMetaReq;
}
export class PushSingleTopicMetaArgs {
    public req: TPushSingleTopicMetaReq.TPushSingleTopicMetaReq;
    constructor(args: IPushSingleTopicMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushSingleTopicMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushSingleTopicMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_69: TPushSingleTopicMetaReq.TPushSingleTopicMetaReq = TPushSingleTopicMetaReq.TPushSingleTopicMetaReq.read(input);
                        _args.req = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushSingleTopicMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushSingleTopicMetaArgs from input");
        }
    }
}
export interface IPushMultiTopicMetaArgsArgs {
    req: TPushMultiTopicMetaReq.TPushMultiTopicMetaReq;
}
export class PushMultiTopicMetaArgs {
    public req: TPushMultiTopicMetaReq.TPushMultiTopicMetaReq;
    constructor(args: IPushMultiTopicMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushMultiTopicMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushMultiTopicMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_70: TPushMultiTopicMetaReq.TPushMultiTopicMetaReq = TPushMultiTopicMetaReq.TPushMultiTopicMetaReq.read(input);
                        _args.req = value_70;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushMultiTopicMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushMultiTopicMetaArgs from input");
        }
    }
}
export interface IPushConsumerGroupMetaArgsArgs {
    req: TPushConsumerGroupMetaReq.TPushConsumerGroupMetaReq;
}
export class PushConsumerGroupMetaArgs {
    public req: TPushConsumerGroupMetaReq.TPushConsumerGroupMetaReq;
    constructor(args: IPushConsumerGroupMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushConsumerGroupMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushConsumerGroupMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_71: TPushConsumerGroupMetaReq.TPushConsumerGroupMetaReq = TPushConsumerGroupMetaReq.TPushConsumerGroupMetaReq.read(input);
                        _args.req = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushConsumerGroupMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushConsumerGroupMetaArgs from input");
        }
    }
}
export interface IPushSingleConsumerGroupMetaArgsArgs {
    req: TPushSingleConsumerGroupMetaReq.TPushSingleConsumerGroupMetaReq;
}
export class PushSingleConsumerGroupMetaArgs {
    public req: TPushSingleConsumerGroupMetaReq.TPushSingleConsumerGroupMetaReq;
    constructor(args: IPushSingleConsumerGroupMetaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushSingleConsumerGroupMetaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushSingleConsumerGroupMetaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_72: TPushSingleConsumerGroupMetaReq.TPushSingleConsumerGroupMetaReq = TPushSingleConsumerGroupMetaReq.TPushSingleConsumerGroupMetaReq.read(input);
                        _args.req = value_72;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PushSingleConsumerGroupMetaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PushSingleConsumerGroupMetaArgs from input");
        }
    }
}
export interface IPipeHeartbeatArgsArgs {
    req: TPipeHeartbeatReq.TPipeHeartbeatReq;
}
export class PipeHeartbeatArgs {
    public req: TPipeHeartbeatReq.TPipeHeartbeatReq;
    constructor(args: IPipeHeartbeatArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PipeHeartbeatArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PipeHeartbeatArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_73: TPipeHeartbeatReq.TPipeHeartbeatReq = TPipeHeartbeatReq.TPipeHeartbeatReq.read(input);
                        _args.req = value_73;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new PipeHeartbeatArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PipeHeartbeatArgs from input");
        }
    }
}
export interface IExecuteCQArgsArgs {
    req: TExecuteCQ.TExecuteCQ;
}
export class ExecuteCQArgs {
    public req: TExecuteCQ.TExecuteCQ;
    constructor(args: IExecuteCQArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteCQArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteCQArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_74: TExecuteCQ.TExecuteCQ = TExecuteCQ.TExecuteCQ.read(input);
                        _args.req = value_74;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ExecuteCQArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteCQArgs from input");
        }
    }
}
export interface ISetSpaceQuotaArgsArgs {
    req: org_apache_iotdb_common_rpc_thrift.TSetSpaceQuotaReq;
}
export class SetSpaceQuotaArgs {
    public req: org_apache_iotdb_common_rpc_thrift.TSetSpaceQuotaReq;
    constructor(args: ISetSpaceQuotaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetSpaceQuotaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetSpaceQuotaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_75: org_apache_iotdb_common_rpc_thrift.TSetSpaceQuotaReq = org_apache_iotdb_common_rpc_thrift.TSetSpaceQuotaReq.read(input);
                        _args.req = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SetSpaceQuotaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetSpaceQuotaArgs from input");
        }
    }
}
export interface ISetThrottleQuotaArgsArgs {
    req: org_apache_iotdb_common_rpc_thrift.TSetThrottleQuotaReq;
}
export class SetThrottleQuotaArgs {
    public req: org_apache_iotdb_common_rpc_thrift.TSetThrottleQuotaReq;
    constructor(args: ISetThrottleQuotaArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetThrottleQuotaArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetThrottleQuotaArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_76: org_apache_iotdb_common_rpc_thrift.TSetThrottleQuotaReq = org_apache_iotdb_common_rpc_thrift.TSetThrottleQuotaReq.read(input);
                        _args.req = value_76;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new SetThrottleQuotaArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetThrottleQuotaArgs from input");
        }
    }
}
export interface IFetchFragmentInstanceStatisticsArgsArgs {
    req: TFetchFragmentInstanceStatisticsReq.TFetchFragmentInstanceStatisticsReq;
}
export class FetchFragmentInstanceStatisticsArgs {
    public req: TFetchFragmentInstanceStatisticsReq.TFetchFragmentInstanceStatisticsReq;
    constructor(args: IFetchFragmentInstanceStatisticsArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchFragmentInstanceStatisticsArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchFragmentInstanceStatisticsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_77: TFetchFragmentInstanceStatisticsReq.TFetchFragmentInstanceStatisticsReq = TFetchFragmentInstanceStatisticsReq.TFetchFragmentInstanceStatisticsReq.read(input);
                        _args.req = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new FetchFragmentInstanceStatisticsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FetchFragmentInstanceStatisticsArgs from input");
        }
    }
}
export interface IUpdateTableArgsArgs {
    req: TUpdateTableReq.TUpdateTableReq;
}
export class UpdateTableArgs {
    public req: TUpdateTableReq.TUpdateTableReq;
    constructor(args: IUpdateTableArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTableArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTableArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_78: TUpdateTableReq.TUpdateTableReq = TUpdateTableReq.TUpdateTableReq.read(input);
                        _args.req = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new UpdateTableArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateTableArgs from input");
        }
    }
}
export interface IInvalidateTableCacheArgsArgs {
    req: TInvalidateTableCacheReq.TInvalidateTableCacheReq;
}
export class InvalidateTableCacheArgs {
    public req: TInvalidateTableCacheReq.TInvalidateTableCacheReq;
    constructor(args: IInvalidateTableCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateTableCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateTableCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_79: TInvalidateTableCacheReq.TInvalidateTableCacheReq = TInvalidateTableCacheReq.TInvalidateTableCacheReq.read(input);
                        _args.req = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InvalidateTableCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidateTableCacheArgs from input");
        }
    }
}
export interface IDeleteDataForDropTableArgsArgs {
    req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq;
}
export class DeleteDataForDropTableArgs {
    public req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq;
    constructor(args: IDeleteDataForDropTableArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataForDropTableArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataForDropTableArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_80: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq = TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq.read(input);
                        _args.req = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteDataForDropTableArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteDataForDropTableArgs from input");
        }
    }
}
export interface IDeleteDevicesForDropTableArgsArgs {
    req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq;
}
export class DeleteDevicesForDropTableArgs {
    public req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq;
    constructor(args: IDeleteDevicesForDropTableArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDevicesForDropTableArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDevicesForDropTableArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_81: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq = TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq.read(input);
                        _args.req = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteDevicesForDropTableArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteDevicesForDropTableArgs from input");
        }
    }
}
export interface IInvalidateColumnCacheArgsArgs {
    req: TInvalidateColumnCacheReq.TInvalidateColumnCacheReq;
}
export class InvalidateColumnCacheArgs {
    public req: TInvalidateColumnCacheReq.TInvalidateColumnCacheReq;
    constructor(args: IInvalidateColumnCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateColumnCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateColumnCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_82: TInvalidateColumnCacheReq.TInvalidateColumnCacheReq = TInvalidateColumnCacheReq.TInvalidateColumnCacheReq.read(input);
                        _args.req = value_82;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InvalidateColumnCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidateColumnCacheArgs from input");
        }
    }
}
export interface IDeleteColumnDataArgsArgs {
    req: TDeleteColumnDataReq.TDeleteColumnDataReq;
}
export class DeleteColumnDataArgs {
    public req: TDeleteColumnDataReq.TDeleteColumnDataReq;
    constructor(args: IDeleteColumnDataArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteColumnDataArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteColumnDataArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_83: TDeleteColumnDataReq.TDeleteColumnDataReq = TDeleteColumnDataReq.TDeleteColumnDataReq.read(input);
                        _args.req = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteColumnDataArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteColumnDataArgs from input");
        }
    }
}
export interface IConstructTableDeviceBlackListArgsArgs {
    req: TTableDeviceDeletionWithPatternAndFilterReq.TTableDeviceDeletionWithPatternAndFilterReq;
}
export class ConstructTableDeviceBlackListArgs {
    public req: TTableDeviceDeletionWithPatternAndFilterReq.TTableDeviceDeletionWithPatternAndFilterReq;
    constructor(args: IConstructTableDeviceBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructTableDeviceBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructTableDeviceBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_84: TTableDeviceDeletionWithPatternAndFilterReq.TTableDeviceDeletionWithPatternAndFilterReq = TTableDeviceDeletionWithPatternAndFilterReq.TTableDeviceDeletionWithPatternAndFilterReq.read(input);
                        _args.req = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new ConstructTableDeviceBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ConstructTableDeviceBlackListArgs from input");
        }
    }
}
export interface IRollbackTableDeviceBlackListArgsArgs {
    req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq;
}
export class RollbackTableDeviceBlackListArgs {
    public req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq;
    constructor(args: IRollbackTableDeviceBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackTableDeviceBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackTableDeviceBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_85: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq = TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq.read(input);
                        _args.req = value_85;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new RollbackTableDeviceBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RollbackTableDeviceBlackListArgs from input");
        }
    }
}
export interface IInvalidateMatchedTableDeviceCacheArgsArgs {
    req: TTableDeviceInvalidateCacheReq.TTableDeviceInvalidateCacheReq;
}
export class InvalidateMatchedTableDeviceCacheArgs {
    public req: TTableDeviceInvalidateCacheReq.TTableDeviceInvalidateCacheReq;
    constructor(args: IInvalidateMatchedTableDeviceCacheArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateMatchedTableDeviceCacheArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateMatchedTableDeviceCacheArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_86: TTableDeviceInvalidateCacheReq.TTableDeviceInvalidateCacheReq = TTableDeviceInvalidateCacheReq.TTableDeviceInvalidateCacheReq.read(input);
                        _args.req = value_86;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new InvalidateMatchedTableDeviceCacheArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read InvalidateMatchedTableDeviceCacheArgs from input");
        }
    }
}
export interface IDeleteDataForTableDeviceArgsArgs {
    req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq;
}
export class DeleteDataForTableDeviceArgs {
    public req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq;
    constructor(args: IDeleteDataForTableDeviceArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataForTableDeviceArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataForTableDeviceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_87: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq = TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq.read(input);
                        _args.req = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteDataForTableDeviceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteDataForTableDeviceArgs from input");
        }
    }
}
export interface IDeleteTableDeviceInBlackListArgsArgs {
    req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq;
}
export class DeleteTableDeviceInBlackListArgs {
    public req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq;
    constructor(args: IDeleteTableDeviceInBlackListArgsArgs) {
        if (args != null && args.req != null) {
            this.req = args.req;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteTableDeviceInBlackListArgs");
        if (this.req != null) {
            output.writeFieldBegin("req", thrift.Thrift.Type.STRUCT, -1);
            this.req.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteTableDeviceInBlackListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_88: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq = TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq.read(input);
                        _args.req = value_88;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return new DeleteTableDeviceInBlackListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteTableDeviceInBlackListArgs from input");
        }
    }
}
export interface ISubmitTestConnectionTaskArgsArgs {
    nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations;
}
export class SubmitTestConnectionTaskArgs {
    public nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations;
    constructor(args: ISubmitTestConnectionTaskArgsArgs) {
        if (args != null && args.nodeLocations != null) {
            this.nodeLocations = args.nodeLocations;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[nodeLocations] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SubmitTestConnectionTaskArgs");
        if (this.nodeLocations != null) {
            output.writeFieldBegin("nodeLocations", thrift.Thrift.Type.STRUCT, -1);
            this.nodeLocations.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SubmitTestConnectionTaskArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_89: org_apache_iotdb_common_rpc_thrift.TNodeLocations = org_apache_iotdb_common_rpc_thrift.TNodeLocations.read(input);
                        _args.nodeLocations = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.nodeLocations !== undefined) {
            return new SubmitTestConnectionTaskArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SubmitTestConnectionTaskArgs from input");
        }
    }
}
export interface ISubmitInternalTestConnectionTaskArgsArgs {
    nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations;
}
export class SubmitInternalTestConnectionTaskArgs {
    public nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations;
    constructor(args: ISubmitInternalTestConnectionTaskArgsArgs) {
        if (args != null && args.nodeLocations != null) {
            this.nodeLocations = args.nodeLocations;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[nodeLocations] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SubmitInternalTestConnectionTaskArgs");
        if (this.nodeLocations != null) {
            output.writeFieldBegin("nodeLocations", thrift.Thrift.Type.STRUCT, -1);
            this.nodeLocations.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SubmitInternalTestConnectionTaskArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case -1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_90: org_apache_iotdb_common_rpc_thrift.TNodeLocations = org_apache_iotdb_common_rpc_thrift.TNodeLocations.read(input);
                        _args.nodeLocations = value_90;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.nodeLocations !== undefined) {
            return new SubmitInternalTestConnectionTaskArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SubmitInternalTestConnectionTaskArgs from input");
        }
    }
}
export interface ITestConnectionEmptyRPCArgsArgs {
}
export class TestConnectionEmptyRPCArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestConnectionEmptyRPCArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestConnectionEmptyRPCArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestConnectionEmptyRPCArgs();
    }
}
export interface ISendFragmentInstanceResultArgs {
    success?: TSendFragmentInstanceResp.TSendFragmentInstanceResp;
}
export class SendFragmentInstanceResult {
    public success?: TSendFragmentInstanceResp.TSendFragmentInstanceResp;
    constructor(args?: ISendFragmentInstanceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendFragmentInstanceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendFragmentInstanceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_91: TSendFragmentInstanceResp.TSendFragmentInstanceResp = TSendFragmentInstanceResp.TSendFragmentInstanceResp.read(input);
                        _args.success = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SendFragmentInstanceResult(_args);
    }
}
export interface ISendBatchPlanNodeResultArgs {
    success?: TSendBatchPlanNodeResp.TSendBatchPlanNodeResp;
}
export class SendBatchPlanNodeResult {
    public success?: TSendBatchPlanNodeResp.TSendBatchPlanNodeResp;
    constructor(args?: ISendBatchPlanNodeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendBatchPlanNodeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendBatchPlanNodeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_92: TSendBatchPlanNodeResp.TSendBatchPlanNodeResp = TSendBatchPlanNodeResp.TSendBatchPlanNodeResp.read(input);
                        _args.success = value_92;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SendBatchPlanNodeResult(_args);
    }
}
export interface IFetchFragmentInstanceInfoResultArgs {
    success?: TFragmentInstanceInfoResp.TFragmentInstanceInfoResp;
}
export class FetchFragmentInstanceInfoResult {
    public success?: TFragmentInstanceInfoResp.TFragmentInstanceInfoResp;
    constructor(args?: IFetchFragmentInstanceInfoResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchFragmentInstanceInfoResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchFragmentInstanceInfoResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_93: TFragmentInstanceInfoResp.TFragmentInstanceInfoResp = TFragmentInstanceInfoResp.TFragmentInstanceInfoResp.read(input);
                        _args.success = value_93;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchFragmentInstanceInfoResult(_args);
    }
}
export interface ICancelQueryResultArgs {
    success?: TCancelResp.TCancelResp;
}
export class CancelQueryResult {
    public success?: TCancelResp.TCancelResp;
    constructor(args?: ICancelQueryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelQueryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelQueryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_94: TCancelResp.TCancelResp = TCancelResp.TCancelResp.read(input);
                        _args.success = value_94;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CancelQueryResult(_args);
    }
}
export interface ICancelPlanFragmentResultArgs {
    success?: TCancelResp.TCancelResp;
}
export class CancelPlanFragmentResult {
    public success?: TCancelResp.TCancelResp;
    constructor(args?: ICancelPlanFragmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelPlanFragmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelPlanFragmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_95: TCancelResp.TCancelResp = TCancelResp.TCancelResp.read(input);
                        _args.success = value_95;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CancelPlanFragmentResult(_args);
    }
}
export interface ICancelFragmentInstanceResultArgs {
    success?: TCancelResp.TCancelResp;
}
export class CancelFragmentInstanceResult {
    public success?: TCancelResp.TCancelResp;
    constructor(args?: ICancelFragmentInstanceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelFragmentInstanceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelFragmentInstanceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_96: TCancelResp.TCancelResp = TCancelResp.TCancelResp.read(input);
                        _args.success = value_96;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CancelFragmentInstanceResult(_args);
    }
}
export interface IFetchSchemaResultArgs {
    success?: TSchemaFetchResponse.TSchemaFetchResponse;
}
export class FetchSchemaResult {
    public success?: TSchemaFetchResponse.TSchemaFetchResponse;
    constructor(args?: IFetchSchemaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchSchemaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchSchemaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_97: TSchemaFetchResponse.TSchemaFetchResponse = TSchemaFetchResponse.TSchemaFetchResponse.read(input);
                        _args.success = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchSchemaResult(_args);
    }
}
export interface ISendTsFilePieceNodeResultArgs {
    success?: TLoadResp.TLoadResp;
}
export class SendTsFilePieceNodeResult {
    public success?: TLoadResp.TLoadResp;
    constructor(args?: ISendTsFilePieceNodeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendTsFilePieceNodeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendTsFilePieceNodeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_98: TLoadResp.TLoadResp = TLoadResp.TLoadResp.read(input);
                        _args.success = value_98;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SendTsFilePieceNodeResult(_args);
    }
}
export interface ISendLoadCommandResultArgs {
    success?: TLoadResp.TLoadResp;
}
export class SendLoadCommandResult {
    public success?: TLoadResp.TLoadResp;
    constructor(args?: ISendLoadCommandResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SendLoadCommandResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SendLoadCommandResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_99: TLoadResp.TLoadResp = TLoadResp.TLoadResp.read(input);
                        _args.success = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SendLoadCommandResult(_args);
    }
}
export interface IUpdateAttributeResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class UpdateAttributeResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IUpdateAttributeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateAttributeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateAttributeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_100: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_100;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateAttributeResult(_args);
    }
}
export interface ICreateSchemaRegionResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateSchemaRegionResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateSchemaRegionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateSchemaRegionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateSchemaRegionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_101: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateSchemaRegionResult(_args);
    }
}
export interface ICreateDataRegionResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateDataRegionResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateDataRegionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateDataRegionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateDataRegionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_102: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_102;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateDataRegionResult(_args);
    }
}
export interface IInvalidatePartitionCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidatePartitionCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidatePartitionCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidatePartitionCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidatePartitionCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_103: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidatePartitionCacheResult(_args);
    }
}
export interface IInvalidateLastCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidateLastCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidateLastCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateLastCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateLastCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_104: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_104;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidateLastCacheResult(_args);
    }
}
export interface IInvalidateSchemaCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidateSchemaCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidateSchemaCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateSchemaCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateSchemaCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_105: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_105;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidateSchemaCacheResult(_args);
    }
}
export interface IDeleteRegionResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteRegionResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteRegionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteRegionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteRegionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_106: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_106;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteRegionResult(_args);
    }
}
export interface IChangeRegionLeaderResultArgs {
    success?: TRegionLeaderChangeResp.TRegionLeaderChangeResp;
}
export class ChangeRegionLeaderResult {
    public success?: TRegionLeaderChangeResp.TRegionLeaderChangeResp;
    constructor(args?: IChangeRegionLeaderResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeRegionLeaderResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeRegionLeaderResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_107: TRegionLeaderChangeResp.TRegionLeaderChangeResp = TRegionLeaderChangeResp.TRegionLeaderChangeResp.read(input);
                        _args.success = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeRegionLeaderResult(_args);
    }
}
export interface ICreateNewRegionPeerResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateNewRegionPeerResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateNewRegionPeerResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateNewRegionPeerResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateNewRegionPeerResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_108: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_108;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateNewRegionPeerResult(_args);
    }
}
export interface IAddRegionPeerResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class AddRegionPeerResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IAddRegionPeerResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddRegionPeerResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddRegionPeerResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_109: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddRegionPeerResult(_args);
    }
}
export interface IRemoveRegionPeerResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class RemoveRegionPeerResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IRemoveRegionPeerResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveRegionPeerResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveRegionPeerResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_110: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_110;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveRegionPeerResult(_args);
    }
}
export interface IDeleteOldRegionPeerResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteOldRegionPeerResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteOldRegionPeerResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteOldRegionPeerResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteOldRegionPeerResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_111: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_111;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteOldRegionPeerResult(_args);
    }
}
export interface IResetPeerListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ResetPeerListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IResetPeerListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResetPeerListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResetPeerListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_112: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_112;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ResetPeerListResult(_args);
    }
}
export interface IGetRegionMaintainResultResultArgs {
    success?: TRegionMigrateResult.TRegionMigrateResult;
}
export class GetRegionMaintainResultResult {
    public success?: TRegionMigrateResult.TRegionMigrateResult;
    constructor(args?: IGetRegionMaintainResultResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetRegionMaintainResultResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetRegionMaintainResultResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_113: TRegionMigrateResult.TRegionMigrateResult = TRegionMigrateResult.TRegionMigrateResult.read(input);
                        _args.success = value_113;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetRegionMaintainResultResult(_args);
    }
}
export interface INotifyRegionMigrationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class NotifyRegionMigrationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: INotifyRegionMigrationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("NotifyRegionMigrationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): NotifyRegionMigrationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_114: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_114;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new NotifyRegionMigrationResult(_args);
    }
}
export interface ICleanDataNodeCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CleanDataNodeCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICleanDataNodeCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CleanDataNodeCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CleanDataNodeCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_115: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_115;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CleanDataNodeCacheResult(_args);
    }
}
export interface IStopAndClearDataNodeResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class StopAndClearDataNodeResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IStopAndClearDataNodeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("StopAndClearDataNodeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): StopAndClearDataNodeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_116: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_116;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new StopAndClearDataNodeResult(_args);
    }
}
export interface IGetDataNodeHeartBeatResultArgs {
    success?: TDataNodeHeartbeatResp.TDataNodeHeartbeatResp;
}
export class GetDataNodeHeartBeatResult {
    public success?: TDataNodeHeartbeatResp.TDataNodeHeartbeatResp;
    constructor(args?: IGetDataNodeHeartBeatResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDataNodeHeartBeatResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDataNodeHeartBeatResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_117: TDataNodeHeartbeatResp.TDataNodeHeartbeatResp = TDataNodeHeartbeatResp.TDataNodeHeartbeatResp.read(input);
                        _args.success = value_117;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDataNodeHeartBeatResult(_args);
    }
}
export interface IUpdateRegionCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class UpdateRegionCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IUpdateRegionCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateRegionCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateRegionCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_118: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_118;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateRegionCacheResult(_args);
    }
}
export interface ICreateFunctionResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateFunctionResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateFunctionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateFunctionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateFunctionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_119: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_119;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateFunctionResult(_args);
    }
}
export interface IDropFunctionResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DropFunctionResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDropFunctionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropFunctionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropFunctionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_120: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_120;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DropFunctionResult(_args);
    }
}
export interface ICreateTriggerInstanceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreateTriggerInstanceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreateTriggerInstanceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateTriggerInstanceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateTriggerInstanceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_121: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_121;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateTriggerInstanceResult(_args);
    }
}
export interface IActiveTriggerInstanceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ActiveTriggerInstanceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IActiveTriggerInstanceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ActiveTriggerInstanceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ActiveTriggerInstanceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_122: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_122;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ActiveTriggerInstanceResult(_args);
    }
}
export interface IInactiveTriggerInstanceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InactiveTriggerInstanceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInactiveTriggerInstanceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InactiveTriggerInstanceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InactiveTriggerInstanceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_123: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_123;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InactiveTriggerInstanceResult(_args);
    }
}
export interface IDropTriggerInstanceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DropTriggerInstanceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDropTriggerInstanceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropTriggerInstanceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropTriggerInstanceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_124: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_124;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DropTriggerInstanceResult(_args);
    }
}
export interface IUpdateTriggerLocationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class UpdateTriggerLocationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IUpdateTriggerLocationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTriggerLocationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTriggerLocationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_125: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_125;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateTriggerLocationResult(_args);
    }
}
export interface IFireTriggerResultArgs {
    success?: TFireTriggerResp.TFireTriggerResp;
}
export class FireTriggerResult {
    public success?: TFireTriggerResp.TFireTriggerResp;
    constructor(args?: IFireTriggerResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FireTriggerResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FireTriggerResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_126: TFireTriggerResp.TFireTriggerResp = TFireTriggerResp.TFireTriggerResp.read(input);
                        _args.success = value_126;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FireTriggerResult(_args);
    }
}
export interface IInvalidatePermissionCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidatePermissionCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidatePermissionCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidatePermissionCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidatePermissionCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_127: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_127;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidatePermissionCacheResult(_args);
    }
}
export interface ICreatePipePluginResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class CreatePipePluginResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ICreatePipePluginResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreatePipePluginResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreatePipePluginResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_128: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_128;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreatePipePluginResult(_args);
    }
}
export interface IDropPipePluginResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DropPipePluginResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDropPipePluginResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DropPipePluginResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DropPipePluginResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_129: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_129;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DropPipePluginResult(_args);
    }
}
export interface IMergeResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class MergeResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IMergeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MergeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MergeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_130: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_130;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MergeResult(_args);
    }
}
export interface IFlushResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class FlushResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IFlushResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FlushResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FlushResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_131: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_131;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FlushResult(_args);
    }
}
export interface ISettleResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SettleResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISettleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SettleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SettleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_132: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_132;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SettleResult(_args);
    }
}
export interface IStartRepairDataResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class StartRepairDataResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IStartRepairDataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("StartRepairDataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): StartRepairDataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_133: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_133;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new StartRepairDataResult(_args);
    }
}
export interface IStopRepairDataResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class StopRepairDataResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IStopRepairDataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("StopRepairDataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): StopRepairDataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_134: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_134;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new StopRepairDataResult(_args);
    }
}
export interface IClearCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ClearCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IClearCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ClearCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ClearCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_135: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_135;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ClearCacheResult(_args);
    }
}
export interface IShowConfigurationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp;
}
export class ShowConfigurationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp;
    constructor(args?: IShowConfigurationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShowConfigurationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShowConfigurationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_136: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp = org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp.read(input);
                        _args.success = value_136;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ShowConfigurationResult(_args);
    }
}
export interface ISetConfigurationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetConfigurationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetConfigurationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetConfigurationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetConfigurationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_137: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_137;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetConfigurationResult(_args);
    }
}
export interface ILoadConfigurationResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class LoadConfigurationResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ILoadConfigurationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("LoadConfigurationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): LoadConfigurationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_138: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_138;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new LoadConfigurationResult(_args);
    }
}
export interface ISetSystemStatusResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetSystemStatusResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetSystemStatusResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetSystemStatusResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetSystemStatusResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_139: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_139;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetSystemStatusResult(_args);
    }
}
export interface IKillQueryInstanceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class KillQueryInstanceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IKillQueryInstanceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("KillQueryInstanceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): KillQueryInstanceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_140: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_140;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new KillQueryInstanceResult(_args);
    }
}
export interface ISetTTLResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetTTLResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetTTLResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetTTLResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetTTLResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_141: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_141;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetTTLResult(_args);
    }
}
export interface IUpdateTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class UpdateTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IUpdateTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_142: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_142;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateTemplateResult(_args);
    }
}
export interface IConstructSchemaBlackListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ConstructSchemaBlackListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IConstructSchemaBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructSchemaBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructSchemaBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_143: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_143;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ConstructSchemaBlackListResult(_args);
    }
}
export interface IRollbackSchemaBlackListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class RollbackSchemaBlackListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IRollbackSchemaBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackSchemaBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackSchemaBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_144: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_144;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RollbackSchemaBlackListResult(_args);
    }
}
export interface IInvalidateMatchedSchemaCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidateMatchedSchemaCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidateMatchedSchemaCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateMatchedSchemaCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateMatchedSchemaCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_145: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_145;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidateMatchedSchemaCacheResult(_args);
    }
}
export interface IFetchSchemaBlackListResultArgs {
    success?: TFetchSchemaBlackListResp.TFetchSchemaBlackListResp;
}
export class FetchSchemaBlackListResult {
    public success?: TFetchSchemaBlackListResp.TFetchSchemaBlackListResp;
    constructor(args?: IFetchSchemaBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchSchemaBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchSchemaBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_146: TFetchSchemaBlackListResp.TFetchSchemaBlackListResp = TFetchSchemaBlackListResp.TFetchSchemaBlackListResp.read(input);
                        _args.success = value_146;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchSchemaBlackListResult(_args);
    }
}
export interface IDeleteDataForDeleteSchemaResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteDataForDeleteSchemaResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteDataForDeleteSchemaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataForDeleteSchemaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataForDeleteSchemaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_147: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_147;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteDataForDeleteSchemaResult(_args);
    }
}
export interface IDeleteTimeSeriesResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteTimeSeriesResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteTimeSeriesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteTimeSeriesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteTimeSeriesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_148: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_148;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteTimeSeriesResult(_args);
    }
}
export interface IConstructSchemaBlackListWithTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ConstructSchemaBlackListWithTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IConstructSchemaBlackListWithTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructSchemaBlackListWithTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructSchemaBlackListWithTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_149: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_149;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ConstructSchemaBlackListWithTemplateResult(_args);
    }
}
export interface IRollbackSchemaBlackListWithTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class RollbackSchemaBlackListWithTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IRollbackSchemaBlackListWithTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackSchemaBlackListWithTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackSchemaBlackListWithTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_150: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_150;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RollbackSchemaBlackListWithTemplateResult(_args);
    }
}
export interface IDeactivateTemplateResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeactivateTemplateResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeactivateTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeactivateTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeactivateTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_151: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_151;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeactivateTemplateResult(_args);
    }
}
export interface ICountPathsUsingTemplateResultArgs {
    success?: TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp;
}
export class CountPathsUsingTemplateResult {
    public success?: TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp;
    constructor(args?: ICountPathsUsingTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CountPathsUsingTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CountPathsUsingTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_152: TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp = TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp.read(input);
                        _args.success = value_152;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CountPathsUsingTemplateResult(_args);
    }
}
export interface ICheckSchemaRegionUsingTemplateResultArgs {
    success?: TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp;
}
export class CheckSchemaRegionUsingTemplateResult {
    public success?: TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp;
    constructor(args?: ICheckSchemaRegionUsingTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckSchemaRegionUsingTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckSchemaRegionUsingTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_153: TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp = TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp.read(input);
                        _args.success = value_153;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckSchemaRegionUsingTemplateResult(_args);
    }
}
export interface ICheckTimeSeriesExistenceResultArgs {
    success?: TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp;
}
export class CheckTimeSeriesExistenceResult {
    public success?: TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp;
    constructor(args?: ICheckTimeSeriesExistenceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckTimeSeriesExistenceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckTimeSeriesExistenceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_154: TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp = TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp.read(input);
                        _args.success = value_154;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckTimeSeriesExistenceResult(_args);
    }
}
export interface IConstructViewSchemaBlackListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ConstructViewSchemaBlackListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IConstructViewSchemaBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructViewSchemaBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructViewSchemaBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_155: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_155;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ConstructViewSchemaBlackListResult(_args);
    }
}
export interface IRollbackViewSchemaBlackListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class RollbackViewSchemaBlackListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IRollbackViewSchemaBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackViewSchemaBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackViewSchemaBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_156: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_156;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RollbackViewSchemaBlackListResult(_args);
    }
}
export interface IDeleteViewSchemaResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteViewSchemaResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteViewSchemaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteViewSchemaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteViewSchemaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_157: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_157;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteViewSchemaResult(_args);
    }
}
export interface IAlterViewResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class AlterViewResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IAlterViewResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AlterViewResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AlterViewResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_158: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_158;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AlterViewResult(_args);
    }
}
export interface IPushPipeMetaResultArgs {
    success?: TPushPipeMetaResp.TPushPipeMetaResp;
}
export class PushPipeMetaResult {
    public success?: TPushPipeMetaResp.TPushPipeMetaResp;
    constructor(args?: IPushPipeMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushPipeMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushPipeMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_159: TPushPipeMetaResp.TPushPipeMetaResp = TPushPipeMetaResp.TPushPipeMetaResp.read(input);
                        _args.success = value_159;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushPipeMetaResult(_args);
    }
}
export interface IPushSinglePipeMetaResultArgs {
    success?: TPushPipeMetaResp.TPushPipeMetaResp;
}
export class PushSinglePipeMetaResult {
    public success?: TPushPipeMetaResp.TPushPipeMetaResp;
    constructor(args?: IPushSinglePipeMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushSinglePipeMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushSinglePipeMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_160: TPushPipeMetaResp.TPushPipeMetaResp = TPushPipeMetaResp.TPushPipeMetaResp.read(input);
                        _args.success = value_160;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushSinglePipeMetaResult(_args);
    }
}
export interface IPushMultiPipeMetaResultArgs {
    success?: TPushPipeMetaResp.TPushPipeMetaResp;
}
export class PushMultiPipeMetaResult {
    public success?: TPushPipeMetaResp.TPushPipeMetaResp;
    constructor(args?: IPushMultiPipeMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushMultiPipeMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushMultiPipeMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_161: TPushPipeMetaResp.TPushPipeMetaResp = TPushPipeMetaResp.TPushPipeMetaResp.read(input);
                        _args.success = value_161;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushMultiPipeMetaResult(_args);
    }
}
export interface IPushTopicMetaResultArgs {
    success?: TPushTopicMetaResp.TPushTopicMetaResp;
}
export class PushTopicMetaResult {
    public success?: TPushTopicMetaResp.TPushTopicMetaResp;
    constructor(args?: IPushTopicMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushTopicMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushTopicMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_162: TPushTopicMetaResp.TPushTopicMetaResp = TPushTopicMetaResp.TPushTopicMetaResp.read(input);
                        _args.success = value_162;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushTopicMetaResult(_args);
    }
}
export interface IPushSingleTopicMetaResultArgs {
    success?: TPushTopicMetaResp.TPushTopicMetaResp;
}
export class PushSingleTopicMetaResult {
    public success?: TPushTopicMetaResp.TPushTopicMetaResp;
    constructor(args?: IPushSingleTopicMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushSingleTopicMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushSingleTopicMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_163: TPushTopicMetaResp.TPushTopicMetaResp = TPushTopicMetaResp.TPushTopicMetaResp.read(input);
                        _args.success = value_163;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushSingleTopicMetaResult(_args);
    }
}
export interface IPushMultiTopicMetaResultArgs {
    success?: TPushTopicMetaResp.TPushTopicMetaResp;
}
export class PushMultiTopicMetaResult {
    public success?: TPushTopicMetaResp.TPushTopicMetaResp;
    constructor(args?: IPushMultiTopicMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushMultiTopicMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushMultiTopicMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_164: TPushTopicMetaResp.TPushTopicMetaResp = TPushTopicMetaResp.TPushTopicMetaResp.read(input);
                        _args.success = value_164;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushMultiTopicMetaResult(_args);
    }
}
export interface IPushConsumerGroupMetaResultArgs {
    success?: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp;
}
export class PushConsumerGroupMetaResult {
    public success?: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp;
    constructor(args?: IPushConsumerGroupMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushConsumerGroupMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushConsumerGroupMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_165: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp = TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp.read(input);
                        _args.success = value_165;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushConsumerGroupMetaResult(_args);
    }
}
export interface IPushSingleConsumerGroupMetaResultArgs {
    success?: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp;
}
export class PushSingleConsumerGroupMetaResult {
    public success?: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp;
    constructor(args?: IPushSingleConsumerGroupMetaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PushSingleConsumerGroupMetaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PushSingleConsumerGroupMetaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_166: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp = TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp.read(input);
                        _args.success = value_166;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PushSingleConsumerGroupMetaResult(_args);
    }
}
export interface IPipeHeartbeatResultArgs {
    success?: TPipeHeartbeatResp.TPipeHeartbeatResp;
}
export class PipeHeartbeatResult {
    public success?: TPipeHeartbeatResp.TPipeHeartbeatResp;
    constructor(args?: IPipeHeartbeatResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PipeHeartbeatResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PipeHeartbeatResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_167: TPipeHeartbeatResp.TPipeHeartbeatResp = TPipeHeartbeatResp.TPipeHeartbeatResp.read(input);
                        _args.success = value_167;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PipeHeartbeatResult(_args);
    }
}
export interface IExecuteCQResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ExecuteCQResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IExecuteCQResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteCQResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteCQResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_168: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_168;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteCQResult(_args);
    }
}
export interface ISetSpaceQuotaResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetSpaceQuotaResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetSpaceQuotaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetSpaceQuotaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetSpaceQuotaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_169: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_169;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetSpaceQuotaResult(_args);
    }
}
export interface ISetThrottleQuotaResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class SetThrottleQuotaResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ISetThrottleQuotaResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetThrottleQuotaResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetThrottleQuotaResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_170: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_170;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetThrottleQuotaResult(_args);
    }
}
export interface IFetchFragmentInstanceStatisticsResultArgs {
    success?: TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp;
}
export class FetchFragmentInstanceStatisticsResult {
    public success?: TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp;
    constructor(args?: IFetchFragmentInstanceStatisticsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FetchFragmentInstanceStatisticsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FetchFragmentInstanceStatisticsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_171: TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp = TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp.read(input);
                        _args.success = value_171;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FetchFragmentInstanceStatisticsResult(_args);
    }
}
export interface IUpdateTableResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class UpdateTableResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IUpdateTableResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTableResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTableResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_172: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_172;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateTableResult(_args);
    }
}
export interface IInvalidateTableCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidateTableCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidateTableCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateTableCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateTableCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_173: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_173;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidateTableCacheResult(_args);
    }
}
export interface IDeleteDataForDropTableResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteDataForDropTableResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteDataForDropTableResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataForDropTableResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataForDropTableResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_174: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_174;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteDataForDropTableResult(_args);
    }
}
export interface IDeleteDevicesForDropTableResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteDevicesForDropTableResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteDevicesForDropTableResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDevicesForDropTableResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDevicesForDropTableResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_175: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_175;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteDevicesForDropTableResult(_args);
    }
}
export interface IInvalidateColumnCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidateColumnCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidateColumnCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateColumnCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateColumnCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_176: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_176;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidateColumnCacheResult(_args);
    }
}
export interface IDeleteColumnDataResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteColumnDataResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteColumnDataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteColumnDataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteColumnDataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_177: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_177;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteColumnDataResult(_args);
    }
}
export interface IConstructTableDeviceBlackListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class ConstructTableDeviceBlackListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IConstructTableDeviceBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConstructTableDeviceBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConstructTableDeviceBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_178: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_178;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ConstructTableDeviceBlackListResult(_args);
    }
}
export interface IRollbackTableDeviceBlackListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class RollbackTableDeviceBlackListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IRollbackTableDeviceBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RollbackTableDeviceBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RollbackTableDeviceBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_179: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_179;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RollbackTableDeviceBlackListResult(_args);
    }
}
export interface IInvalidateMatchedTableDeviceCacheResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class InvalidateMatchedTableDeviceCacheResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IInvalidateMatchedTableDeviceCacheResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("InvalidateMatchedTableDeviceCacheResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): InvalidateMatchedTableDeviceCacheResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_180: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_180;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new InvalidateMatchedTableDeviceCacheResult(_args);
    }
}
export interface IDeleteDataForTableDeviceResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteDataForTableDeviceResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteDataForTableDeviceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDataForTableDeviceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDataForTableDeviceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_181: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_181;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteDataForTableDeviceResult(_args);
    }
}
export interface IDeleteTableDeviceInBlackListResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class DeleteTableDeviceInBlackListResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: IDeleteTableDeviceInBlackListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteTableDeviceInBlackListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteTableDeviceInBlackListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_182: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_182;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteTableDeviceInBlackListResult(_args);
    }
}
export interface ISubmitTestConnectionTaskResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp;
}
export class SubmitTestConnectionTaskResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp;
    constructor(args?: ISubmitTestConnectionTaskResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SubmitTestConnectionTaskResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SubmitTestConnectionTaskResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_183: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp = org_apache_iotdb_common_rpc_thrift.TTestConnectionResp.read(input);
                        _args.success = value_183;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SubmitTestConnectionTaskResult(_args);
    }
}
export interface ISubmitInternalTestConnectionTaskResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp;
}
export class SubmitInternalTestConnectionTaskResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp;
    constructor(args?: ISubmitInternalTestConnectionTaskResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SubmitInternalTestConnectionTaskResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SubmitInternalTestConnectionTaskResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_184: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp = org_apache_iotdb_common_rpc_thrift.TTestConnectionResp.read(input);
                        _args.success = value_184;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SubmitInternalTestConnectionTaskResult(_args);
    }
}
export interface ITestConnectionEmptyRPCResultArgs {
    success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
}
export class TestConnectionEmptyRPCResult {
    public success?: org_apache_iotdb_common_rpc_thrift.TSStatus;
    constructor(args?: ITestConnectionEmptyRPCResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("TestConnectionEmptyRPCResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): TestConnectionEmptyRPCResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_185: org_apache_iotdb_common_rpc_thrift.TSStatus = org_apache_iotdb_common_rpc_thrift.TSStatus.read(input);
                        _args.success = value_185;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new TestConnectionEmptyRPCResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public sendFragmentInstance(req: TSendFragmentInstanceReq.TSendFragmentInstanceReq): Promise<TSendFragmentInstanceResp.TSendFragmentInstanceResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSendFragmentInstanceResp.TSendFragmentInstanceResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_sendFragmentInstance(req, requestId);
        });
    }
    public sendBatchPlanNode(req: TSendBatchPlanNodeReq.TSendBatchPlanNodeReq): Promise<TSendBatchPlanNodeResp.TSendBatchPlanNodeResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSendBatchPlanNodeResp.TSendBatchPlanNodeResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_sendBatchPlanNode(req, requestId);
        });
    }
    public fetchFragmentInstanceInfo(req: TFetchFragmentInstanceInfoReq.TFetchFragmentInstanceInfoReq): Promise<TFragmentInstanceInfoResp.TFragmentInstanceInfoResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TFragmentInstanceInfoResp.TFragmentInstanceInfoResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchFragmentInstanceInfo(req, requestId);
        });
    }
    public cancelQuery(req: TCancelQueryReq.TCancelQueryReq): Promise<TCancelResp.TCancelResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TCancelResp.TCancelResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cancelQuery(req, requestId);
        });
    }
    public cancelPlanFragment(req: TCancelPlanFragmentReq.TCancelPlanFragmentReq): Promise<TCancelResp.TCancelResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TCancelResp.TCancelResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cancelPlanFragment(req, requestId);
        });
    }
    public cancelFragmentInstance(req: TCancelFragmentInstanceReq.TCancelFragmentInstanceReq): Promise<TCancelResp.TCancelResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TCancelResp.TCancelResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cancelFragmentInstance(req, requestId);
        });
    }
    public fetchSchema(req: TSchemaFetchRequest.TSchemaFetchRequest): Promise<TSchemaFetchResponse.TSchemaFetchResponse> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TSchemaFetchResponse.TSchemaFetchResponse>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchSchema(req, requestId);
        });
    }
    public sendTsFilePieceNode(req: TTsFilePieceReq.TTsFilePieceReq): Promise<TLoadResp.TLoadResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TLoadResp.TLoadResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_sendTsFilePieceNode(req, requestId);
        });
    }
    public sendLoadCommand(req: TLoadCommandReq.TLoadCommandReq): Promise<TLoadResp.TLoadResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TLoadResp.TLoadResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_sendLoadCommand(req, requestId);
        });
    }
    public updateAttribute(req: TAttributeUpdateReq.TAttributeUpdateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateAttribute(req, requestId);
        });
    }
    public createSchemaRegion(req: TCreateSchemaRegionReq.TCreateSchemaRegionReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createSchemaRegion(req, requestId);
        });
    }
    public createDataRegion(req: TCreateDataRegionReq.TCreateDataRegionReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createDataRegion(req, requestId);
        });
    }
    public invalidatePartitionCache(req: TInvalidateCacheReq.TInvalidateCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidatePartitionCache(req, requestId);
        });
    }
    public invalidateLastCache(database: string): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidateLastCache(database, requestId);
        });
    }
    public invalidateSchemaCache(req: TInvalidateCacheReq.TInvalidateCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidateSchemaCache(req, requestId);
        });
    }
    public deleteRegion(consensusGroupId: org_apache_iotdb_common_rpc_thrift.TConsensusGroupId): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteRegion(consensusGroupId, requestId);
        });
    }
    public changeRegionLeader(req: TRegionLeaderChangeReq.TRegionLeaderChangeReq): Promise<TRegionLeaderChangeResp.TRegionLeaderChangeResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TRegionLeaderChangeResp.TRegionLeaderChangeResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeRegionLeader(req, requestId);
        });
    }
    public createNewRegionPeer(req: TCreatePeerReq.TCreatePeerReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createNewRegionPeer(req, requestId);
        });
    }
    public addRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addRegionPeer(req, requestId);
        });
    }
    public removeRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeRegionPeer(req, requestId);
        });
    }
    public deleteOldRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteOldRegionPeer(req, requestId);
        });
    }
    public resetPeerList(req: TResetPeerListReq.TResetPeerListReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_resetPeerList(req, requestId);
        });
    }
    public getRegionMaintainResult(taskId: Int64): Promise<TRegionMigrateResult.TRegionMigrateResult> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TRegionMigrateResult.TRegionMigrateResult>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getRegionMaintainResult(taskId, requestId);
        });
    }
    public notifyRegionMigration(req: TNotifyRegionMigrationReq.TNotifyRegionMigrationReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_notifyRegionMigration(req, requestId);
        });
    }
    public cleanDataNodeCache(req: TCleanDataNodeCacheReq.TCleanDataNodeCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cleanDataNodeCache(req, requestId);
        });
    }
    public stopAndClearDataNode(): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_stopAndClearDataNode(requestId);
        });
    }
    public getDataNodeHeartBeat(req: TDataNodeHeartbeatReq.TDataNodeHeartbeatReq): Promise<TDataNodeHeartbeatResp.TDataNodeHeartbeatResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TDataNodeHeartbeatResp.TDataNodeHeartbeatResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDataNodeHeartBeat(req, requestId);
        });
    }
    public updateRegionCache(req: TRegionRouteReq.TRegionRouteReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateRegionCache(req, requestId);
        });
    }
    public createFunction(req: TCreateFunctionInstanceReq.TCreateFunctionInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createFunction(req, requestId);
        });
    }
    public dropFunction(req: TDropFunctionInstanceReq.TDropFunctionInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_dropFunction(req, requestId);
        });
    }
    public createTriggerInstance(req: TCreateTriggerInstanceReq.TCreateTriggerInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createTriggerInstance(req, requestId);
        });
    }
    public activeTriggerInstance(req: TActiveTriggerInstanceReq.TActiveTriggerInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_activeTriggerInstance(req, requestId);
        });
    }
    public inactiveTriggerInstance(req: TInactiveTriggerInstanceReq.TInactiveTriggerInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_inactiveTriggerInstance(req, requestId);
        });
    }
    public dropTriggerInstance(req: TDropTriggerInstanceReq.TDropTriggerInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_dropTriggerInstance(req, requestId);
        });
    }
    public updateTriggerLocation(req: TUpdateTriggerLocationReq.TUpdateTriggerLocationReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateTriggerLocation(req, requestId);
        });
    }
    public fireTrigger(req: TFireTriggerReq.TFireTriggerReq): Promise<TFireTriggerResp.TFireTriggerResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TFireTriggerResp.TFireTriggerResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fireTrigger(req, requestId);
        });
    }
    public invalidatePermissionCache(req: TInvalidatePermissionCacheReq.TInvalidatePermissionCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidatePermissionCache(req, requestId);
        });
    }
    public createPipePlugin(req: TCreatePipePluginInstanceReq.TCreatePipePluginInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createPipePlugin(req, requestId);
        });
    }
    public dropPipePlugin(req: TDropPipePluginInstanceReq.TDropPipePluginInstanceReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_dropPipePlugin(req, requestId);
        });
    }
    public merge(): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_merge(requestId);
        });
    }
    public flush(req: org_apache_iotdb_common_rpc_thrift.TFlushReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_flush(req, requestId);
        });
    }
    public settle(req: org_apache_iotdb_common_rpc_thrift.TSettleReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_settle(req, requestId);
        });
    }
    public startRepairData(): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_startRepairData(requestId);
        });
    }
    public stopRepairData(): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_stopRepairData(requestId);
        });
    }
    public clearCache(cacheClearOptions: Set<number>): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_clearCache(cacheClearOptions, requestId);
        });
    }
    public showConfiguration(): Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_showConfiguration(requestId);
        });
    }
    public setConfiguration(req: org_apache_iotdb_common_rpc_thrift.TSetConfigurationReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setConfiguration(req, requestId);
        });
    }
    public loadConfiguration(): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_loadConfiguration(requestId);
        });
    }
    public setSystemStatus(status: string): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setSystemStatus(status, requestId);
        });
    }
    public killQueryInstance(queryId: string): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_killQueryInstance(queryId, requestId);
        });
    }
    public setTTL(req: org_apache_iotdb_common_rpc_thrift.TSetTTLReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setTTL(req, requestId);
        });
    }
    public updateTemplate(req: TUpdateTemplateReq.TUpdateTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateTemplate(req, requestId);
        });
    }
    public constructSchemaBlackList(req: TConstructSchemaBlackListReq.TConstructSchemaBlackListReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_constructSchemaBlackList(req, requestId);
        });
    }
    public rollbackSchemaBlackList(req: TRollbackSchemaBlackListReq.TRollbackSchemaBlackListReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_rollbackSchemaBlackList(req, requestId);
        });
    }
    public invalidateMatchedSchemaCache(req: TInvalidateMatchedSchemaCacheReq.TInvalidateMatchedSchemaCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidateMatchedSchemaCache(req, requestId);
        });
    }
    public fetchSchemaBlackList(req: TFetchSchemaBlackListReq.TFetchSchemaBlackListReq): Promise<TFetchSchemaBlackListResp.TFetchSchemaBlackListResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TFetchSchemaBlackListResp.TFetchSchemaBlackListResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchSchemaBlackList(req, requestId);
        });
    }
    public deleteDataForDeleteSchema(req: TDeleteDataForDeleteSchemaReq.TDeleteDataForDeleteSchemaReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteDataForDeleteSchema(req, requestId);
        });
    }
    public deleteTimeSeries(req: TDeleteTimeSeriesReq.TDeleteTimeSeriesReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteTimeSeries(req, requestId);
        });
    }
    public constructSchemaBlackListWithTemplate(req: TConstructSchemaBlackListWithTemplateReq.TConstructSchemaBlackListWithTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_constructSchemaBlackListWithTemplate(req, requestId);
        });
    }
    public rollbackSchemaBlackListWithTemplate(req: TRollbackSchemaBlackListWithTemplateReq.TRollbackSchemaBlackListWithTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_rollbackSchemaBlackListWithTemplate(req, requestId);
        });
    }
    public deactivateTemplate(req: TDeactivateTemplateReq.TDeactivateTemplateReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deactivateTemplate(req, requestId);
        });
    }
    public countPathsUsingTemplate(req: TCountPathsUsingTemplateReq.TCountPathsUsingTemplateReq): Promise<TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_countPathsUsingTemplate(req, requestId);
        });
    }
    public checkSchemaRegionUsingTemplate(req: TCheckSchemaRegionUsingTemplateReq.TCheckSchemaRegionUsingTemplateReq): Promise<TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_checkSchemaRegionUsingTemplate(req, requestId);
        });
    }
    public checkTimeSeriesExistence(req: TCheckTimeSeriesExistenceReq.TCheckTimeSeriesExistenceReq): Promise<TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_checkTimeSeriesExistence(req, requestId);
        });
    }
    public constructViewSchemaBlackList(req: TConstructViewSchemaBlackListReq.TConstructViewSchemaBlackListReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_constructViewSchemaBlackList(req, requestId);
        });
    }
    public rollbackViewSchemaBlackList(req: TRollbackViewSchemaBlackListReq.TRollbackViewSchemaBlackListReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_rollbackViewSchemaBlackList(req, requestId);
        });
    }
    public deleteViewSchema(req: TDeleteViewSchemaReq.TDeleteViewSchemaReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteViewSchema(req, requestId);
        });
    }
    public alterView(req: TAlterViewReq.TAlterViewReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_alterView(req, requestId);
        });
    }
    public pushPipeMeta(req: TPushPipeMetaReq.TPushPipeMetaReq): Promise<TPushPipeMetaResp.TPushPipeMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushPipeMetaResp.TPushPipeMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushPipeMeta(req, requestId);
        });
    }
    public pushSinglePipeMeta(req: TPushSinglePipeMetaReq.TPushSinglePipeMetaReq): Promise<TPushPipeMetaResp.TPushPipeMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushPipeMetaResp.TPushPipeMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushSinglePipeMeta(req, requestId);
        });
    }
    public pushMultiPipeMeta(req: TPushMultiPipeMetaReq.TPushMultiPipeMetaReq): Promise<TPushPipeMetaResp.TPushPipeMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushPipeMetaResp.TPushPipeMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushMultiPipeMeta(req, requestId);
        });
    }
    public pushTopicMeta(req: TPushTopicMetaReq.TPushTopicMetaReq): Promise<TPushTopicMetaResp.TPushTopicMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushTopicMetaResp.TPushTopicMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushTopicMeta(req, requestId);
        });
    }
    public pushSingleTopicMeta(req: TPushSingleTopicMetaReq.TPushSingleTopicMetaReq): Promise<TPushTopicMetaResp.TPushTopicMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushTopicMetaResp.TPushTopicMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushSingleTopicMeta(req, requestId);
        });
    }
    public pushMultiTopicMeta(req: TPushMultiTopicMetaReq.TPushMultiTopicMetaReq): Promise<TPushTopicMetaResp.TPushTopicMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushTopicMetaResp.TPushTopicMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushMultiTopicMeta(req, requestId);
        });
    }
    public pushConsumerGroupMeta(req: TPushConsumerGroupMetaReq.TPushConsumerGroupMetaReq): Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushConsumerGroupMeta(req, requestId);
        });
    }
    public pushSingleConsumerGroupMeta(req: TPushSingleConsumerGroupMetaReq.TPushSingleConsumerGroupMetaReq): Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pushSingleConsumerGroupMeta(req, requestId);
        });
    }
    public pipeHeartbeat(req: TPipeHeartbeatReq.TPipeHeartbeatReq): Promise<TPipeHeartbeatResp.TPipeHeartbeatResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TPipeHeartbeatResp.TPipeHeartbeatResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pipeHeartbeat(req, requestId);
        });
    }
    public executeCQ(req: TExecuteCQ.TExecuteCQ): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeCQ(req, requestId);
        });
    }
    public setSpaceQuota(req: org_apache_iotdb_common_rpc_thrift.TSetSpaceQuotaReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setSpaceQuota(req, requestId);
        });
    }
    public setThrottleQuota(req: org_apache_iotdb_common_rpc_thrift.TSetThrottleQuotaReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setThrottleQuota(req, requestId);
        });
    }
    public fetchFragmentInstanceStatistics(req: TFetchFragmentInstanceStatisticsReq.TFetchFragmentInstanceStatisticsReq): Promise<TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_fetchFragmentInstanceStatistics(req, requestId);
        });
    }
    public updateTable(req: TUpdateTableReq.TUpdateTableReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateTable(req, requestId);
        });
    }
    public invalidateTableCache(req: TInvalidateTableCacheReq.TInvalidateTableCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidateTableCache(req, requestId);
        });
    }
    public deleteDataForDropTable(req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteDataForDropTable(req, requestId);
        });
    }
    public deleteDevicesForDropTable(req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteDevicesForDropTable(req, requestId);
        });
    }
    public invalidateColumnCache(req: TInvalidateColumnCacheReq.TInvalidateColumnCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidateColumnCache(req, requestId);
        });
    }
    public deleteColumnData(req: TDeleteColumnDataReq.TDeleteColumnDataReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteColumnData(req, requestId);
        });
    }
    public constructTableDeviceBlackList(req: TTableDeviceDeletionWithPatternAndFilterReq.TTableDeviceDeletionWithPatternAndFilterReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_constructTableDeviceBlackList(req, requestId);
        });
    }
    public rollbackTableDeviceBlackList(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_rollbackTableDeviceBlackList(req, requestId);
        });
    }
    public invalidateMatchedTableDeviceCache(req: TTableDeviceInvalidateCacheReq.TTableDeviceInvalidateCacheReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_invalidateMatchedTableDeviceCache(req, requestId);
        });
    }
    public deleteDataForTableDevice(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteDataForTableDevice(req, requestId);
        });
    }
    public deleteTableDeviceInBlackList(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteTableDeviceInBlackList(req, requestId);
        });
    }
    public submitTestConnectionTask(nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations): Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_submitTestConnectionTask(nodeLocations, requestId);
        });
    }
    public submitInternalTestConnectionTask(nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations): Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_submitInternalTestConnectionTask(nodeLocations, requestId);
        });
    }
    public testConnectionEmptyRPC(): Promise<org_apache_iotdb_common_rpc_thrift.TSStatus> {
        const requestId: number = this.incrementSeqId();
        return new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_testConnectionEmptyRPC(requestId);
        });
    }
    public send_sendFragmentInstance(req: TSendFragmentInstanceReq.TSendFragmentInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("sendFragmentInstance", thrift.Thrift.MessageType.CALL, requestId);
        const args: SendFragmentInstanceArgs = new SendFragmentInstanceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_sendBatchPlanNode(req: TSendBatchPlanNodeReq.TSendBatchPlanNodeReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("sendBatchPlanNode", thrift.Thrift.MessageType.CALL, requestId);
        const args: SendBatchPlanNodeArgs = new SendBatchPlanNodeArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchFragmentInstanceInfo(req: TFetchFragmentInstanceInfoReq.TFetchFragmentInstanceInfoReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchFragmentInstanceInfo", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchFragmentInstanceInfoArgs = new FetchFragmentInstanceInfoArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cancelQuery(req: TCancelQueryReq.TCancelQueryReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cancelQuery", thrift.Thrift.MessageType.CALL, requestId);
        const args: CancelQueryArgs = new CancelQueryArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cancelPlanFragment(req: TCancelPlanFragmentReq.TCancelPlanFragmentReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cancelPlanFragment", thrift.Thrift.MessageType.CALL, requestId);
        const args: CancelPlanFragmentArgs = new CancelPlanFragmentArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cancelFragmentInstance(req: TCancelFragmentInstanceReq.TCancelFragmentInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cancelFragmentInstance", thrift.Thrift.MessageType.CALL, requestId);
        const args: CancelFragmentInstanceArgs = new CancelFragmentInstanceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchSchema(req: TSchemaFetchRequest.TSchemaFetchRequest, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchSchema", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchSchemaArgs = new FetchSchemaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_sendTsFilePieceNode(req: TTsFilePieceReq.TTsFilePieceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("sendTsFilePieceNode", thrift.Thrift.MessageType.CALL, requestId);
        const args: SendTsFilePieceNodeArgs = new SendTsFilePieceNodeArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_sendLoadCommand(req: TLoadCommandReq.TLoadCommandReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("sendLoadCommand", thrift.Thrift.MessageType.CALL, requestId);
        const args: SendLoadCommandArgs = new SendLoadCommandArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateAttribute(req: TAttributeUpdateReq.TAttributeUpdateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateAttribute", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateAttributeArgs = new UpdateAttributeArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createSchemaRegion(req: TCreateSchemaRegionReq.TCreateSchemaRegionReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createSchemaRegion", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateSchemaRegionArgs = new CreateSchemaRegionArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createDataRegion(req: TCreateDataRegionReq.TCreateDataRegionReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createDataRegion", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateDataRegionArgs = new CreateDataRegionArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidatePartitionCache(req: TInvalidateCacheReq.TInvalidateCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidatePartitionCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidatePartitionCacheArgs = new InvalidatePartitionCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidateLastCache(database: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidateLastCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidateLastCacheArgs = new InvalidateLastCacheArgs({ database });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidateSchemaCache(req: TInvalidateCacheReq.TInvalidateCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidateSchemaCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidateSchemaCacheArgs = new InvalidateSchemaCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteRegion(consensusGroupId: org_apache_iotdb_common_rpc_thrift.TConsensusGroupId, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteRegion", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteRegionArgs = new DeleteRegionArgs({ consensusGroupId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeRegionLeader(req: TRegionLeaderChangeReq.TRegionLeaderChangeReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeRegionLeader", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeRegionLeaderArgs = new ChangeRegionLeaderArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createNewRegionPeer(req: TCreatePeerReq.TCreatePeerReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createNewRegionPeer", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateNewRegionPeerArgs = new CreateNewRegionPeerArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addRegionPeer", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddRegionPeerArgs = new AddRegionPeerArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeRegionPeer", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveRegionPeerArgs = new RemoveRegionPeerArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteOldRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteOldRegionPeer", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteOldRegionPeerArgs = new DeleteOldRegionPeerArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_resetPeerList(req: TResetPeerListReq.TResetPeerListReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("resetPeerList", thrift.Thrift.MessageType.CALL, requestId);
        const args: ResetPeerListArgs = new ResetPeerListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getRegionMaintainResult(taskId: Int64, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getRegionMaintainResult", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetRegionMaintainResultArgs = new GetRegionMaintainResultArgs({ taskId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_notifyRegionMigration(req: TNotifyRegionMigrationReq.TNotifyRegionMigrationReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("notifyRegionMigration", thrift.Thrift.MessageType.CALL, requestId);
        const args: NotifyRegionMigrationArgs = new NotifyRegionMigrationArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cleanDataNodeCache(req: TCleanDataNodeCacheReq.TCleanDataNodeCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cleanDataNodeCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: CleanDataNodeCacheArgs = new CleanDataNodeCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_stopAndClearDataNode(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("stopAndClearDataNode", thrift.Thrift.MessageType.CALL, requestId);
        const args: StopAndClearDataNodeArgs = new StopAndClearDataNodeArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDataNodeHeartBeat(req: TDataNodeHeartbeatReq.TDataNodeHeartbeatReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDataNodeHeartBeat", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDataNodeHeartBeatArgs = new GetDataNodeHeartBeatArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateRegionCache(req: TRegionRouteReq.TRegionRouteReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateRegionCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateRegionCacheArgs = new UpdateRegionCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createFunction(req: TCreateFunctionInstanceReq.TCreateFunctionInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createFunction", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateFunctionArgs = new CreateFunctionArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_dropFunction(req: TDropFunctionInstanceReq.TDropFunctionInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("dropFunction", thrift.Thrift.MessageType.CALL, requestId);
        const args: DropFunctionArgs = new DropFunctionArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createTriggerInstance(req: TCreateTriggerInstanceReq.TCreateTriggerInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createTriggerInstance", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateTriggerInstanceArgs = new CreateTriggerInstanceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_activeTriggerInstance(req: TActiveTriggerInstanceReq.TActiveTriggerInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("activeTriggerInstance", thrift.Thrift.MessageType.CALL, requestId);
        const args: ActiveTriggerInstanceArgs = new ActiveTriggerInstanceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_inactiveTriggerInstance(req: TInactiveTriggerInstanceReq.TInactiveTriggerInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("inactiveTriggerInstance", thrift.Thrift.MessageType.CALL, requestId);
        const args: InactiveTriggerInstanceArgs = new InactiveTriggerInstanceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_dropTriggerInstance(req: TDropTriggerInstanceReq.TDropTriggerInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("dropTriggerInstance", thrift.Thrift.MessageType.CALL, requestId);
        const args: DropTriggerInstanceArgs = new DropTriggerInstanceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateTriggerLocation(req: TUpdateTriggerLocationReq.TUpdateTriggerLocationReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateTriggerLocation", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateTriggerLocationArgs = new UpdateTriggerLocationArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fireTrigger(req: TFireTriggerReq.TFireTriggerReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fireTrigger", thrift.Thrift.MessageType.CALL, requestId);
        const args: FireTriggerArgs = new FireTriggerArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidatePermissionCache(req: TInvalidatePermissionCacheReq.TInvalidatePermissionCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidatePermissionCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidatePermissionCacheArgs = new InvalidatePermissionCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createPipePlugin(req: TCreatePipePluginInstanceReq.TCreatePipePluginInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createPipePlugin", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreatePipePluginArgs = new CreatePipePluginArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_dropPipePlugin(req: TDropPipePluginInstanceReq.TDropPipePluginInstanceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("dropPipePlugin", thrift.Thrift.MessageType.CALL, requestId);
        const args: DropPipePluginArgs = new DropPipePluginArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_merge(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("merge", thrift.Thrift.MessageType.CALL, requestId);
        const args: MergeArgs = new MergeArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_flush(req: org_apache_iotdb_common_rpc_thrift.TFlushReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("flush", thrift.Thrift.MessageType.CALL, requestId);
        const args: FlushArgs = new FlushArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_settle(req: org_apache_iotdb_common_rpc_thrift.TSettleReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("settle", thrift.Thrift.MessageType.CALL, requestId);
        const args: SettleArgs = new SettleArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_startRepairData(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("startRepairData", thrift.Thrift.MessageType.CALL, requestId);
        const args: StartRepairDataArgs = new StartRepairDataArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_stopRepairData(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("stopRepairData", thrift.Thrift.MessageType.CALL, requestId);
        const args: StopRepairDataArgs = new StopRepairDataArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_clearCache(cacheClearOptions: Set<number>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("clearCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: ClearCacheArgs = new ClearCacheArgs({ cacheClearOptions });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_showConfiguration(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("showConfiguration", thrift.Thrift.MessageType.CALL, requestId);
        const args: ShowConfigurationArgs = new ShowConfigurationArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setConfiguration(req: org_apache_iotdb_common_rpc_thrift.TSetConfigurationReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setConfiguration", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetConfigurationArgs = new SetConfigurationArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_loadConfiguration(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("loadConfiguration", thrift.Thrift.MessageType.CALL, requestId);
        const args: LoadConfigurationArgs = new LoadConfigurationArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setSystemStatus(status: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setSystemStatus", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetSystemStatusArgs = new SetSystemStatusArgs({ status });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_killQueryInstance(queryId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("killQueryInstance", thrift.Thrift.MessageType.CALL, requestId);
        const args: KillQueryInstanceArgs = new KillQueryInstanceArgs({ queryId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setTTL(req: org_apache_iotdb_common_rpc_thrift.TSetTTLReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setTTL", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetTTLArgs = new SetTTLArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateTemplate(req: TUpdateTemplateReq.TUpdateTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateTemplateArgs = new UpdateTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_constructSchemaBlackList(req: TConstructSchemaBlackListReq.TConstructSchemaBlackListReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("constructSchemaBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: ConstructSchemaBlackListArgs = new ConstructSchemaBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_rollbackSchemaBlackList(req: TRollbackSchemaBlackListReq.TRollbackSchemaBlackListReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("rollbackSchemaBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: RollbackSchemaBlackListArgs = new RollbackSchemaBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidateMatchedSchemaCache(req: TInvalidateMatchedSchemaCacheReq.TInvalidateMatchedSchemaCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidateMatchedSchemaCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidateMatchedSchemaCacheArgs = new InvalidateMatchedSchemaCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchSchemaBlackList(req: TFetchSchemaBlackListReq.TFetchSchemaBlackListReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchSchemaBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchSchemaBlackListArgs = new FetchSchemaBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteDataForDeleteSchema(req: TDeleteDataForDeleteSchemaReq.TDeleteDataForDeleteSchemaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteDataForDeleteSchema", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteDataForDeleteSchemaArgs = new DeleteDataForDeleteSchemaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteTimeSeries(req: TDeleteTimeSeriesReq.TDeleteTimeSeriesReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteTimeSeries", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteTimeSeriesArgs = new DeleteTimeSeriesArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_constructSchemaBlackListWithTemplate(req: TConstructSchemaBlackListWithTemplateReq.TConstructSchemaBlackListWithTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("constructSchemaBlackListWithTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: ConstructSchemaBlackListWithTemplateArgs = new ConstructSchemaBlackListWithTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_rollbackSchemaBlackListWithTemplate(req: TRollbackSchemaBlackListWithTemplateReq.TRollbackSchemaBlackListWithTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("rollbackSchemaBlackListWithTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: RollbackSchemaBlackListWithTemplateArgs = new RollbackSchemaBlackListWithTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deactivateTemplate(req: TDeactivateTemplateReq.TDeactivateTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deactivateTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeactivateTemplateArgs = new DeactivateTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_countPathsUsingTemplate(req: TCountPathsUsingTemplateReq.TCountPathsUsingTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("countPathsUsingTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: CountPathsUsingTemplateArgs = new CountPathsUsingTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_checkSchemaRegionUsingTemplate(req: TCheckSchemaRegionUsingTemplateReq.TCheckSchemaRegionUsingTemplateReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("checkSchemaRegionUsingTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: CheckSchemaRegionUsingTemplateArgs = new CheckSchemaRegionUsingTemplateArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_checkTimeSeriesExistence(req: TCheckTimeSeriesExistenceReq.TCheckTimeSeriesExistenceReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("checkTimeSeriesExistence", thrift.Thrift.MessageType.CALL, requestId);
        const args: CheckTimeSeriesExistenceArgs = new CheckTimeSeriesExistenceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_constructViewSchemaBlackList(req: TConstructViewSchemaBlackListReq.TConstructViewSchemaBlackListReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("constructViewSchemaBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: ConstructViewSchemaBlackListArgs = new ConstructViewSchemaBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_rollbackViewSchemaBlackList(req: TRollbackViewSchemaBlackListReq.TRollbackViewSchemaBlackListReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("rollbackViewSchemaBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: RollbackViewSchemaBlackListArgs = new RollbackViewSchemaBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteViewSchema(req: TDeleteViewSchemaReq.TDeleteViewSchemaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteViewSchema", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteViewSchemaArgs = new DeleteViewSchemaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_alterView(req: TAlterViewReq.TAlterViewReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("alterView", thrift.Thrift.MessageType.CALL, requestId);
        const args: AlterViewArgs = new AlterViewArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushPipeMeta(req: TPushPipeMetaReq.TPushPipeMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushPipeMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushPipeMetaArgs = new PushPipeMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushSinglePipeMeta(req: TPushSinglePipeMetaReq.TPushSinglePipeMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushSinglePipeMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushSinglePipeMetaArgs = new PushSinglePipeMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushMultiPipeMeta(req: TPushMultiPipeMetaReq.TPushMultiPipeMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushMultiPipeMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushMultiPipeMetaArgs = new PushMultiPipeMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushTopicMeta(req: TPushTopicMetaReq.TPushTopicMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushTopicMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushTopicMetaArgs = new PushTopicMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushSingleTopicMeta(req: TPushSingleTopicMetaReq.TPushSingleTopicMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushSingleTopicMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushSingleTopicMetaArgs = new PushSingleTopicMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushMultiTopicMeta(req: TPushMultiTopicMetaReq.TPushMultiTopicMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushMultiTopicMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushMultiTopicMetaArgs = new PushMultiTopicMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushConsumerGroupMeta(req: TPushConsumerGroupMetaReq.TPushConsumerGroupMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushConsumerGroupMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushConsumerGroupMetaArgs = new PushConsumerGroupMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pushSingleConsumerGroupMeta(req: TPushSingleConsumerGroupMetaReq.TPushSingleConsumerGroupMetaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pushSingleConsumerGroupMeta", thrift.Thrift.MessageType.CALL, requestId);
        const args: PushSingleConsumerGroupMetaArgs = new PushSingleConsumerGroupMetaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pipeHeartbeat(req: TPipeHeartbeatReq.TPipeHeartbeatReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pipeHeartbeat", thrift.Thrift.MessageType.CALL, requestId);
        const args: PipeHeartbeatArgs = new PipeHeartbeatArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeCQ(req: TExecuteCQ.TExecuteCQ, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeCQ", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteCQArgs = new ExecuteCQArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setSpaceQuota(req: org_apache_iotdb_common_rpc_thrift.TSetSpaceQuotaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setSpaceQuota", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetSpaceQuotaArgs = new SetSpaceQuotaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setThrottleQuota(req: org_apache_iotdb_common_rpc_thrift.TSetThrottleQuotaReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setThrottleQuota", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetThrottleQuotaArgs = new SetThrottleQuotaArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_fetchFragmentInstanceStatistics(req: TFetchFragmentInstanceStatisticsReq.TFetchFragmentInstanceStatisticsReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("fetchFragmentInstanceStatistics", thrift.Thrift.MessageType.CALL, requestId);
        const args: FetchFragmentInstanceStatisticsArgs = new FetchFragmentInstanceStatisticsArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateTable(req: TUpdateTableReq.TUpdateTableReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateTable", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateTableArgs = new UpdateTableArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidateTableCache(req: TInvalidateTableCacheReq.TInvalidateTableCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidateTableCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidateTableCacheArgs = new InvalidateTableCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteDataForDropTable(req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteDataForDropTable", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteDataForDropTableArgs = new DeleteDataForDropTableArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteDevicesForDropTable(req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteDevicesForDropTable", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteDevicesForDropTableArgs = new DeleteDevicesForDropTableArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidateColumnCache(req: TInvalidateColumnCacheReq.TInvalidateColumnCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidateColumnCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidateColumnCacheArgs = new InvalidateColumnCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteColumnData(req: TDeleteColumnDataReq.TDeleteColumnDataReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteColumnData", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteColumnDataArgs = new DeleteColumnDataArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_constructTableDeviceBlackList(req: TTableDeviceDeletionWithPatternAndFilterReq.TTableDeviceDeletionWithPatternAndFilterReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("constructTableDeviceBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: ConstructTableDeviceBlackListArgs = new ConstructTableDeviceBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_rollbackTableDeviceBlackList(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("rollbackTableDeviceBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: RollbackTableDeviceBlackListArgs = new RollbackTableDeviceBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_invalidateMatchedTableDeviceCache(req: TTableDeviceInvalidateCacheReq.TTableDeviceInvalidateCacheReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("invalidateMatchedTableDeviceCache", thrift.Thrift.MessageType.CALL, requestId);
        const args: InvalidateMatchedTableDeviceCacheArgs = new InvalidateMatchedTableDeviceCacheArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteDataForTableDevice(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteDataForTableDevice", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteDataForTableDeviceArgs = new DeleteDataForTableDeviceArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteTableDeviceInBlackList(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteTableDeviceInBlackList", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteTableDeviceInBlackListArgs = new DeleteTableDeviceInBlackListArgs({ req });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_submitTestConnectionTask(nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("submitTestConnectionTask", thrift.Thrift.MessageType.CALL, requestId);
        const args: SubmitTestConnectionTaskArgs = new SubmitTestConnectionTaskArgs({ nodeLocations });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_submitInternalTestConnectionTask(nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("submitInternalTestConnectionTask", thrift.Thrift.MessageType.CALL, requestId);
        const args: SubmitInternalTestConnectionTaskArgs = new SubmitInternalTestConnectionTaskArgs({ nodeLocations });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_testConnectionEmptyRPC(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("testConnectionEmptyRPC", thrift.Thrift.MessageType.CALL, requestId);
        const args: TestConnectionEmptyRPCArgs = new TestConnectionEmptyRPCArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_sendFragmentInstance(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SendFragmentInstanceResult = SendFragmentInstanceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "sendFragmentInstance failed: unknown result"));
            }
        }
    }
    public recv_sendBatchPlanNode(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SendBatchPlanNodeResult = SendBatchPlanNodeResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "sendBatchPlanNode failed: unknown result"));
            }
        }
    }
    public recv_fetchFragmentInstanceInfo(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchFragmentInstanceInfoResult = FetchFragmentInstanceInfoResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchFragmentInstanceInfo failed: unknown result"));
            }
        }
    }
    public recv_cancelQuery(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CancelQueryResult = CancelQueryResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cancelQuery failed: unknown result"));
            }
        }
    }
    public recv_cancelPlanFragment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CancelPlanFragmentResult = CancelPlanFragmentResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cancelPlanFragment failed: unknown result"));
            }
        }
    }
    public recv_cancelFragmentInstance(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CancelFragmentInstanceResult = CancelFragmentInstanceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cancelFragmentInstance failed: unknown result"));
            }
        }
    }
    public recv_fetchSchema(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchSchemaResult = FetchSchemaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchSchema failed: unknown result"));
            }
        }
    }
    public recv_sendTsFilePieceNode(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SendTsFilePieceNodeResult = SendTsFilePieceNodeResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "sendTsFilePieceNode failed: unknown result"));
            }
        }
    }
    public recv_sendLoadCommand(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SendLoadCommandResult = SendLoadCommandResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "sendLoadCommand failed: unknown result"));
            }
        }
    }
    public recv_updateAttribute(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateAttributeResult = UpdateAttributeResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateAttribute failed: unknown result"));
            }
        }
    }
    public recv_createSchemaRegion(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateSchemaRegionResult = CreateSchemaRegionResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createSchemaRegion failed: unknown result"));
            }
        }
    }
    public recv_createDataRegion(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateDataRegionResult = CreateDataRegionResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createDataRegion failed: unknown result"));
            }
        }
    }
    public recv_invalidatePartitionCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidatePartitionCacheResult = InvalidatePartitionCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidatePartitionCache failed: unknown result"));
            }
        }
    }
    public recv_invalidateLastCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidateLastCacheResult = InvalidateLastCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidateLastCache failed: unknown result"));
            }
        }
    }
    public recv_invalidateSchemaCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidateSchemaCacheResult = InvalidateSchemaCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidateSchemaCache failed: unknown result"));
            }
        }
    }
    public recv_deleteRegion(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteRegionResult = DeleteRegionResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteRegion failed: unknown result"));
            }
        }
    }
    public recv_changeRegionLeader(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeRegionLeaderResult = ChangeRegionLeaderResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeRegionLeader failed: unknown result"));
            }
        }
    }
    public recv_createNewRegionPeer(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateNewRegionPeerResult = CreateNewRegionPeerResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createNewRegionPeer failed: unknown result"));
            }
        }
    }
    public recv_addRegionPeer(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddRegionPeerResult = AddRegionPeerResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addRegionPeer failed: unknown result"));
            }
        }
    }
    public recv_removeRegionPeer(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveRegionPeerResult = RemoveRegionPeerResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeRegionPeer failed: unknown result"));
            }
        }
    }
    public recv_deleteOldRegionPeer(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteOldRegionPeerResult = DeleteOldRegionPeerResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteOldRegionPeer failed: unknown result"));
            }
        }
    }
    public recv_resetPeerList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ResetPeerListResult = ResetPeerListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "resetPeerList failed: unknown result"));
            }
        }
    }
    public recv_getRegionMaintainResult(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetRegionMaintainResultResult = GetRegionMaintainResultResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getRegionMaintainResult failed: unknown result"));
            }
        }
    }
    public recv_notifyRegionMigration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: NotifyRegionMigrationResult = NotifyRegionMigrationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "notifyRegionMigration failed: unknown result"));
            }
        }
    }
    public recv_cleanDataNodeCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CleanDataNodeCacheResult = CleanDataNodeCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cleanDataNodeCache failed: unknown result"));
            }
        }
    }
    public recv_stopAndClearDataNode(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: StopAndClearDataNodeResult = StopAndClearDataNodeResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "stopAndClearDataNode failed: unknown result"));
            }
        }
    }
    public recv_getDataNodeHeartBeat(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDataNodeHeartBeatResult = GetDataNodeHeartBeatResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDataNodeHeartBeat failed: unknown result"));
            }
        }
    }
    public recv_updateRegionCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateRegionCacheResult = UpdateRegionCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateRegionCache failed: unknown result"));
            }
        }
    }
    public recv_createFunction(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateFunctionResult = CreateFunctionResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createFunction failed: unknown result"));
            }
        }
    }
    public recv_dropFunction(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DropFunctionResult = DropFunctionResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "dropFunction failed: unknown result"));
            }
        }
    }
    public recv_createTriggerInstance(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateTriggerInstanceResult = CreateTriggerInstanceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createTriggerInstance failed: unknown result"));
            }
        }
    }
    public recv_activeTriggerInstance(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ActiveTriggerInstanceResult = ActiveTriggerInstanceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "activeTriggerInstance failed: unknown result"));
            }
        }
    }
    public recv_inactiveTriggerInstance(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InactiveTriggerInstanceResult = InactiveTriggerInstanceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "inactiveTriggerInstance failed: unknown result"));
            }
        }
    }
    public recv_dropTriggerInstance(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DropTriggerInstanceResult = DropTriggerInstanceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "dropTriggerInstance failed: unknown result"));
            }
        }
    }
    public recv_updateTriggerLocation(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateTriggerLocationResult = UpdateTriggerLocationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateTriggerLocation failed: unknown result"));
            }
        }
    }
    public recv_fireTrigger(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FireTriggerResult = FireTriggerResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fireTrigger failed: unknown result"));
            }
        }
    }
    public recv_invalidatePermissionCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidatePermissionCacheResult = InvalidatePermissionCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidatePermissionCache failed: unknown result"));
            }
        }
    }
    public recv_createPipePlugin(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreatePipePluginResult = CreatePipePluginResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createPipePlugin failed: unknown result"));
            }
        }
    }
    public recv_dropPipePlugin(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DropPipePluginResult = DropPipePluginResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "dropPipePlugin failed: unknown result"));
            }
        }
    }
    public recv_merge(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: MergeResult = MergeResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "merge failed: unknown result"));
            }
        }
    }
    public recv_flush(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FlushResult = FlushResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "flush failed: unknown result"));
            }
        }
    }
    public recv_settle(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SettleResult = SettleResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "settle failed: unknown result"));
            }
        }
    }
    public recv_startRepairData(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: StartRepairDataResult = StartRepairDataResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "startRepairData failed: unknown result"));
            }
        }
    }
    public recv_stopRepairData(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: StopRepairDataResult = StopRepairDataResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "stopRepairData failed: unknown result"));
            }
        }
    }
    public recv_clearCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ClearCacheResult = ClearCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "clearCache failed: unknown result"));
            }
        }
    }
    public recv_showConfiguration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ShowConfigurationResult = ShowConfigurationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "showConfiguration failed: unknown result"));
            }
        }
    }
    public recv_setConfiguration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetConfigurationResult = SetConfigurationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setConfiguration failed: unknown result"));
            }
        }
    }
    public recv_loadConfiguration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: LoadConfigurationResult = LoadConfigurationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "loadConfiguration failed: unknown result"));
            }
        }
    }
    public recv_setSystemStatus(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetSystemStatusResult = SetSystemStatusResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setSystemStatus failed: unknown result"));
            }
        }
    }
    public recv_killQueryInstance(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: KillQueryInstanceResult = KillQueryInstanceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "killQueryInstance failed: unknown result"));
            }
        }
    }
    public recv_setTTL(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetTTLResult = SetTTLResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setTTL failed: unknown result"));
            }
        }
    }
    public recv_updateTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateTemplateResult = UpdateTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateTemplate failed: unknown result"));
            }
        }
    }
    public recv_constructSchemaBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ConstructSchemaBlackListResult = ConstructSchemaBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "constructSchemaBlackList failed: unknown result"));
            }
        }
    }
    public recv_rollbackSchemaBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RollbackSchemaBlackListResult = RollbackSchemaBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "rollbackSchemaBlackList failed: unknown result"));
            }
        }
    }
    public recv_invalidateMatchedSchemaCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidateMatchedSchemaCacheResult = InvalidateMatchedSchemaCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidateMatchedSchemaCache failed: unknown result"));
            }
        }
    }
    public recv_fetchSchemaBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchSchemaBlackListResult = FetchSchemaBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchSchemaBlackList failed: unknown result"));
            }
        }
    }
    public recv_deleteDataForDeleteSchema(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteDataForDeleteSchemaResult = DeleteDataForDeleteSchemaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteDataForDeleteSchema failed: unknown result"));
            }
        }
    }
    public recv_deleteTimeSeries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteTimeSeriesResult = DeleteTimeSeriesResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteTimeSeries failed: unknown result"));
            }
        }
    }
    public recv_constructSchemaBlackListWithTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ConstructSchemaBlackListWithTemplateResult = ConstructSchemaBlackListWithTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "constructSchemaBlackListWithTemplate failed: unknown result"));
            }
        }
    }
    public recv_rollbackSchemaBlackListWithTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RollbackSchemaBlackListWithTemplateResult = RollbackSchemaBlackListWithTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "rollbackSchemaBlackListWithTemplate failed: unknown result"));
            }
        }
    }
    public recv_deactivateTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeactivateTemplateResult = DeactivateTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deactivateTemplate failed: unknown result"));
            }
        }
    }
    public recv_countPathsUsingTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CountPathsUsingTemplateResult = CountPathsUsingTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "countPathsUsingTemplate failed: unknown result"));
            }
        }
    }
    public recv_checkSchemaRegionUsingTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CheckSchemaRegionUsingTemplateResult = CheckSchemaRegionUsingTemplateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkSchemaRegionUsingTemplate failed: unknown result"));
            }
        }
    }
    public recv_checkTimeSeriesExistence(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CheckTimeSeriesExistenceResult = CheckTimeSeriesExistenceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkTimeSeriesExistence failed: unknown result"));
            }
        }
    }
    public recv_constructViewSchemaBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ConstructViewSchemaBlackListResult = ConstructViewSchemaBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "constructViewSchemaBlackList failed: unknown result"));
            }
        }
    }
    public recv_rollbackViewSchemaBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RollbackViewSchemaBlackListResult = RollbackViewSchemaBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "rollbackViewSchemaBlackList failed: unknown result"));
            }
        }
    }
    public recv_deleteViewSchema(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteViewSchemaResult = DeleteViewSchemaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteViewSchema failed: unknown result"));
            }
        }
    }
    public recv_alterView(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AlterViewResult = AlterViewResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "alterView failed: unknown result"));
            }
        }
    }
    public recv_pushPipeMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushPipeMetaResult = PushPipeMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushPipeMeta failed: unknown result"));
            }
        }
    }
    public recv_pushSinglePipeMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushSinglePipeMetaResult = PushSinglePipeMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushSinglePipeMeta failed: unknown result"));
            }
        }
    }
    public recv_pushMultiPipeMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushMultiPipeMetaResult = PushMultiPipeMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushMultiPipeMeta failed: unknown result"));
            }
        }
    }
    public recv_pushTopicMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushTopicMetaResult = PushTopicMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushTopicMeta failed: unknown result"));
            }
        }
    }
    public recv_pushSingleTopicMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushSingleTopicMetaResult = PushSingleTopicMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushSingleTopicMeta failed: unknown result"));
            }
        }
    }
    public recv_pushMultiTopicMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushMultiTopicMetaResult = PushMultiTopicMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushMultiTopicMeta failed: unknown result"));
            }
        }
    }
    public recv_pushConsumerGroupMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushConsumerGroupMetaResult = PushConsumerGroupMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushConsumerGroupMeta failed: unknown result"));
            }
        }
    }
    public recv_pushSingleConsumerGroupMeta(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PushSingleConsumerGroupMetaResult = PushSingleConsumerGroupMetaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pushSingleConsumerGroupMeta failed: unknown result"));
            }
        }
    }
    public recv_pipeHeartbeat(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PipeHeartbeatResult = PipeHeartbeatResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pipeHeartbeat failed: unknown result"));
            }
        }
    }
    public recv_executeCQ(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteCQResult = ExecuteCQResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeCQ failed: unknown result"));
            }
        }
    }
    public recv_setSpaceQuota(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetSpaceQuotaResult = SetSpaceQuotaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setSpaceQuota failed: unknown result"));
            }
        }
    }
    public recv_setThrottleQuota(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetThrottleQuotaResult = SetThrottleQuotaResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setThrottleQuota failed: unknown result"));
            }
        }
    }
    public recv_fetchFragmentInstanceStatistics(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FetchFragmentInstanceStatisticsResult = FetchFragmentInstanceStatisticsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchFragmentInstanceStatistics failed: unknown result"));
            }
        }
    }
    public recv_updateTable(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateTableResult = UpdateTableResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateTable failed: unknown result"));
            }
        }
    }
    public recv_invalidateTableCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidateTableCacheResult = InvalidateTableCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidateTableCache failed: unknown result"));
            }
        }
    }
    public recv_deleteDataForDropTable(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteDataForDropTableResult = DeleteDataForDropTableResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteDataForDropTable failed: unknown result"));
            }
        }
    }
    public recv_deleteDevicesForDropTable(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteDevicesForDropTableResult = DeleteDevicesForDropTableResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteDevicesForDropTable failed: unknown result"));
            }
        }
    }
    public recv_invalidateColumnCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidateColumnCacheResult = InvalidateColumnCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidateColumnCache failed: unknown result"));
            }
        }
    }
    public recv_deleteColumnData(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteColumnDataResult = DeleteColumnDataResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteColumnData failed: unknown result"));
            }
        }
    }
    public recv_constructTableDeviceBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ConstructTableDeviceBlackListResult = ConstructTableDeviceBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "constructTableDeviceBlackList failed: unknown result"));
            }
        }
    }
    public recv_rollbackTableDeviceBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RollbackTableDeviceBlackListResult = RollbackTableDeviceBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "rollbackTableDeviceBlackList failed: unknown result"));
            }
        }
    }
    public recv_invalidateMatchedTableDeviceCache(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: InvalidateMatchedTableDeviceCacheResult = InvalidateMatchedTableDeviceCacheResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "invalidateMatchedTableDeviceCache failed: unknown result"));
            }
        }
    }
    public recv_deleteDataForTableDevice(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteDataForTableDeviceResult = DeleteDataForTableDeviceResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteDataForTableDevice failed: unknown result"));
            }
        }
    }
    public recv_deleteTableDeviceInBlackList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteTableDeviceInBlackListResult = DeleteTableDeviceInBlackListResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteTableDeviceInBlackList failed: unknown result"));
            }
        }
    }
    public recv_submitTestConnectionTask(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SubmitTestConnectionTaskResult = SubmitTestConnectionTaskResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "submitTestConnectionTask failed: unknown result"));
            }
        }
    }
    public recv_submitInternalTestConnectionTask(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SubmitInternalTestConnectionTaskResult = SubmitInternalTestConnectionTaskResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "submitInternalTestConnectionTask failed: unknown result"));
            }
        }
    }
    public recv_testConnectionEmptyRPC(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: TestConnectionEmptyRPCResult = TestConnectionEmptyRPCResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "testConnectionEmptyRPC failed: unknown result"));
            }
        }
    }
}
export interface IHandler {
    sendFragmentInstance(req: TSendFragmentInstanceReq.TSendFragmentInstanceReq): TSendFragmentInstanceResp.TSendFragmentInstanceResp | Promise<TSendFragmentInstanceResp.TSendFragmentInstanceResp>;
    sendBatchPlanNode(req: TSendBatchPlanNodeReq.TSendBatchPlanNodeReq): TSendBatchPlanNodeResp.TSendBatchPlanNodeResp | Promise<TSendBatchPlanNodeResp.TSendBatchPlanNodeResp>;
    fetchFragmentInstanceInfo(req: TFetchFragmentInstanceInfoReq.TFetchFragmentInstanceInfoReq): TFragmentInstanceInfoResp.TFragmentInstanceInfoResp | Promise<TFragmentInstanceInfoResp.TFragmentInstanceInfoResp>;
    cancelQuery(req: TCancelQueryReq.TCancelQueryReq): TCancelResp.TCancelResp | Promise<TCancelResp.TCancelResp>;
    cancelPlanFragment(req: TCancelPlanFragmentReq.TCancelPlanFragmentReq): TCancelResp.TCancelResp | Promise<TCancelResp.TCancelResp>;
    cancelFragmentInstance(req: TCancelFragmentInstanceReq.TCancelFragmentInstanceReq): TCancelResp.TCancelResp | Promise<TCancelResp.TCancelResp>;
    fetchSchema(req: TSchemaFetchRequest.TSchemaFetchRequest): TSchemaFetchResponse.TSchemaFetchResponse | Promise<TSchemaFetchResponse.TSchemaFetchResponse>;
    sendTsFilePieceNode(req: TTsFilePieceReq.TTsFilePieceReq): TLoadResp.TLoadResp | Promise<TLoadResp.TLoadResp>;
    sendLoadCommand(req: TLoadCommandReq.TLoadCommandReq): TLoadResp.TLoadResp | Promise<TLoadResp.TLoadResp>;
    updateAttribute(req: TAttributeUpdateReq.TAttributeUpdateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createSchemaRegion(req: TCreateSchemaRegionReq.TCreateSchemaRegionReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createDataRegion(req: TCreateDataRegionReq.TCreateDataRegionReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    invalidatePartitionCache(req: TInvalidateCacheReq.TInvalidateCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    invalidateLastCache(database: string): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    invalidateSchemaCache(req: TInvalidateCacheReq.TInvalidateCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteRegion(consensusGroupId: org_apache_iotdb_common_rpc_thrift.TConsensusGroupId): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    changeRegionLeader(req: TRegionLeaderChangeReq.TRegionLeaderChangeReq): TRegionLeaderChangeResp.TRegionLeaderChangeResp | Promise<TRegionLeaderChangeResp.TRegionLeaderChangeResp>;
    createNewRegionPeer(req: TCreatePeerReq.TCreatePeerReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    addRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    removeRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteOldRegionPeer(req: TMaintainPeerReq.TMaintainPeerReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    resetPeerList(req: TResetPeerListReq.TResetPeerListReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    getRegionMaintainResult(taskId: Int64): TRegionMigrateResult.TRegionMigrateResult | Promise<TRegionMigrateResult.TRegionMigrateResult>;
    notifyRegionMigration(req: TNotifyRegionMigrationReq.TNotifyRegionMigrationReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    cleanDataNodeCache(req: TCleanDataNodeCacheReq.TCleanDataNodeCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    stopAndClearDataNode(): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    getDataNodeHeartBeat(req: TDataNodeHeartbeatReq.TDataNodeHeartbeatReq): TDataNodeHeartbeatResp.TDataNodeHeartbeatResp | Promise<TDataNodeHeartbeatResp.TDataNodeHeartbeatResp>;
    updateRegionCache(req: TRegionRouteReq.TRegionRouteReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createFunction(req: TCreateFunctionInstanceReq.TCreateFunctionInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    dropFunction(req: TDropFunctionInstanceReq.TDropFunctionInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createTriggerInstance(req: TCreateTriggerInstanceReq.TCreateTriggerInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    activeTriggerInstance(req: TActiveTriggerInstanceReq.TActiveTriggerInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    inactiveTriggerInstance(req: TInactiveTriggerInstanceReq.TInactiveTriggerInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    dropTriggerInstance(req: TDropTriggerInstanceReq.TDropTriggerInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    updateTriggerLocation(req: TUpdateTriggerLocationReq.TUpdateTriggerLocationReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    fireTrigger(req: TFireTriggerReq.TFireTriggerReq): TFireTriggerResp.TFireTriggerResp | Promise<TFireTriggerResp.TFireTriggerResp>;
    invalidatePermissionCache(req: TInvalidatePermissionCacheReq.TInvalidatePermissionCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    createPipePlugin(req: TCreatePipePluginInstanceReq.TCreatePipePluginInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    dropPipePlugin(req: TDropPipePluginInstanceReq.TDropPipePluginInstanceReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    merge(): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    flush(req: org_apache_iotdb_common_rpc_thrift.TFlushReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    settle(req: org_apache_iotdb_common_rpc_thrift.TSettleReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    startRepairData(): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    stopRepairData(): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    clearCache(cacheClearOptions: Set<number>): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    showConfiguration(): org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp | Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp>;
    setConfiguration(req: org_apache_iotdb_common_rpc_thrift.TSetConfigurationReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    loadConfiguration(): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    setSystemStatus(status: string): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    killQueryInstance(queryId: string): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    setTTL(req: org_apache_iotdb_common_rpc_thrift.TSetTTLReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    updateTemplate(req: TUpdateTemplateReq.TUpdateTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    constructSchemaBlackList(req: TConstructSchemaBlackListReq.TConstructSchemaBlackListReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    rollbackSchemaBlackList(req: TRollbackSchemaBlackListReq.TRollbackSchemaBlackListReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    invalidateMatchedSchemaCache(req: TInvalidateMatchedSchemaCacheReq.TInvalidateMatchedSchemaCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    fetchSchemaBlackList(req: TFetchSchemaBlackListReq.TFetchSchemaBlackListReq): TFetchSchemaBlackListResp.TFetchSchemaBlackListResp | Promise<TFetchSchemaBlackListResp.TFetchSchemaBlackListResp>;
    deleteDataForDeleteSchema(req: TDeleteDataForDeleteSchemaReq.TDeleteDataForDeleteSchemaReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteTimeSeries(req: TDeleteTimeSeriesReq.TDeleteTimeSeriesReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    constructSchemaBlackListWithTemplate(req: TConstructSchemaBlackListWithTemplateReq.TConstructSchemaBlackListWithTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    rollbackSchemaBlackListWithTemplate(req: TRollbackSchemaBlackListWithTemplateReq.TRollbackSchemaBlackListWithTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deactivateTemplate(req: TDeactivateTemplateReq.TDeactivateTemplateReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    countPathsUsingTemplate(req: TCountPathsUsingTemplateReq.TCountPathsUsingTemplateReq): TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp | Promise<TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp>;
    checkSchemaRegionUsingTemplate(req: TCheckSchemaRegionUsingTemplateReq.TCheckSchemaRegionUsingTemplateReq): TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp | Promise<TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp>;
    checkTimeSeriesExistence(req: TCheckTimeSeriesExistenceReq.TCheckTimeSeriesExistenceReq): TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp | Promise<TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp>;
    constructViewSchemaBlackList(req: TConstructViewSchemaBlackListReq.TConstructViewSchemaBlackListReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    rollbackViewSchemaBlackList(req: TRollbackViewSchemaBlackListReq.TRollbackViewSchemaBlackListReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteViewSchema(req: TDeleteViewSchemaReq.TDeleteViewSchemaReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    alterView(req: TAlterViewReq.TAlterViewReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    pushPipeMeta(req: TPushPipeMetaReq.TPushPipeMetaReq): TPushPipeMetaResp.TPushPipeMetaResp | Promise<TPushPipeMetaResp.TPushPipeMetaResp>;
    pushSinglePipeMeta(req: TPushSinglePipeMetaReq.TPushSinglePipeMetaReq): TPushPipeMetaResp.TPushPipeMetaResp | Promise<TPushPipeMetaResp.TPushPipeMetaResp>;
    pushMultiPipeMeta(req: TPushMultiPipeMetaReq.TPushMultiPipeMetaReq): TPushPipeMetaResp.TPushPipeMetaResp | Promise<TPushPipeMetaResp.TPushPipeMetaResp>;
    pushTopicMeta(req: TPushTopicMetaReq.TPushTopicMetaReq): TPushTopicMetaResp.TPushTopicMetaResp | Promise<TPushTopicMetaResp.TPushTopicMetaResp>;
    pushSingleTopicMeta(req: TPushSingleTopicMetaReq.TPushSingleTopicMetaReq): TPushTopicMetaResp.TPushTopicMetaResp | Promise<TPushTopicMetaResp.TPushTopicMetaResp>;
    pushMultiTopicMeta(req: TPushMultiTopicMetaReq.TPushMultiTopicMetaReq): TPushTopicMetaResp.TPushTopicMetaResp | Promise<TPushTopicMetaResp.TPushTopicMetaResp>;
    pushConsumerGroupMeta(req: TPushConsumerGroupMetaReq.TPushConsumerGroupMetaReq): TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp | Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp>;
    pushSingleConsumerGroupMeta(req: TPushSingleConsumerGroupMetaReq.TPushSingleConsumerGroupMetaReq): TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp | Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp>;
    pipeHeartbeat(req: TPipeHeartbeatReq.TPipeHeartbeatReq): TPipeHeartbeatResp.TPipeHeartbeatResp | Promise<TPipeHeartbeatResp.TPipeHeartbeatResp>;
    executeCQ(req: TExecuteCQ.TExecuteCQ): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    setSpaceQuota(req: org_apache_iotdb_common_rpc_thrift.TSetSpaceQuotaReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    setThrottleQuota(req: org_apache_iotdb_common_rpc_thrift.TSetThrottleQuotaReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    fetchFragmentInstanceStatistics(req: TFetchFragmentInstanceStatisticsReq.TFetchFragmentInstanceStatisticsReq): TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp | Promise<TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp>;
    updateTable(req: TUpdateTableReq.TUpdateTableReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    invalidateTableCache(req: TInvalidateTableCacheReq.TInvalidateTableCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteDataForDropTable(req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteDevicesForDropTable(req: TDeleteDataOrDevicesForDropTableReq.TDeleteDataOrDevicesForDropTableReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    invalidateColumnCache(req: TInvalidateColumnCacheReq.TInvalidateColumnCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteColumnData(req: TDeleteColumnDataReq.TDeleteColumnDataReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    constructTableDeviceBlackList(req: TTableDeviceDeletionWithPatternAndFilterReq.TTableDeviceDeletionWithPatternAndFilterReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    rollbackTableDeviceBlackList(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    invalidateMatchedTableDeviceCache(req: TTableDeviceInvalidateCacheReq.TTableDeviceInvalidateCacheReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteDataForTableDevice(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    deleteTableDeviceInBlackList(req: TTableDeviceDeletionWithPatternOrModReq.TTableDeviceDeletionWithPatternOrModReq): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
    submitTestConnectionTask(nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations): org_apache_iotdb_common_rpc_thrift.TTestConnectionResp | Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp>;
    submitInternalTestConnectionTask(nodeLocations: org_apache_iotdb_common_rpc_thrift.TNodeLocations): org_apache_iotdb_common_rpc_thrift.TTestConnectionResp | Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp>;
    testConnectionEmptyRPC(): org_apache_iotdb_common_rpc_thrift.TSStatus | Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_sendFragmentInstance": {
                this.process_sendFragmentInstance(requestId, input, output);
                return;
            }
            case "process_sendBatchPlanNode": {
                this.process_sendBatchPlanNode(requestId, input, output);
                return;
            }
            case "process_fetchFragmentInstanceInfo": {
                this.process_fetchFragmentInstanceInfo(requestId, input, output);
                return;
            }
            case "process_cancelQuery": {
                this.process_cancelQuery(requestId, input, output);
                return;
            }
            case "process_cancelPlanFragment": {
                this.process_cancelPlanFragment(requestId, input, output);
                return;
            }
            case "process_cancelFragmentInstance": {
                this.process_cancelFragmentInstance(requestId, input, output);
                return;
            }
            case "process_fetchSchema": {
                this.process_fetchSchema(requestId, input, output);
                return;
            }
            case "process_sendTsFilePieceNode": {
                this.process_sendTsFilePieceNode(requestId, input, output);
                return;
            }
            case "process_sendLoadCommand": {
                this.process_sendLoadCommand(requestId, input, output);
                return;
            }
            case "process_updateAttribute": {
                this.process_updateAttribute(requestId, input, output);
                return;
            }
            case "process_createSchemaRegion": {
                this.process_createSchemaRegion(requestId, input, output);
                return;
            }
            case "process_createDataRegion": {
                this.process_createDataRegion(requestId, input, output);
                return;
            }
            case "process_invalidatePartitionCache": {
                this.process_invalidatePartitionCache(requestId, input, output);
                return;
            }
            case "process_invalidateLastCache": {
                this.process_invalidateLastCache(requestId, input, output);
                return;
            }
            case "process_invalidateSchemaCache": {
                this.process_invalidateSchemaCache(requestId, input, output);
                return;
            }
            case "process_deleteRegion": {
                this.process_deleteRegion(requestId, input, output);
                return;
            }
            case "process_changeRegionLeader": {
                this.process_changeRegionLeader(requestId, input, output);
                return;
            }
            case "process_createNewRegionPeer": {
                this.process_createNewRegionPeer(requestId, input, output);
                return;
            }
            case "process_addRegionPeer": {
                this.process_addRegionPeer(requestId, input, output);
                return;
            }
            case "process_removeRegionPeer": {
                this.process_removeRegionPeer(requestId, input, output);
                return;
            }
            case "process_deleteOldRegionPeer": {
                this.process_deleteOldRegionPeer(requestId, input, output);
                return;
            }
            case "process_resetPeerList": {
                this.process_resetPeerList(requestId, input, output);
                return;
            }
            case "process_getRegionMaintainResult": {
                this.process_getRegionMaintainResult(requestId, input, output);
                return;
            }
            case "process_notifyRegionMigration": {
                this.process_notifyRegionMigration(requestId, input, output);
                return;
            }
            case "process_cleanDataNodeCache": {
                this.process_cleanDataNodeCache(requestId, input, output);
                return;
            }
            case "process_stopAndClearDataNode": {
                this.process_stopAndClearDataNode(requestId, input, output);
                return;
            }
            case "process_getDataNodeHeartBeat": {
                this.process_getDataNodeHeartBeat(requestId, input, output);
                return;
            }
            case "process_updateRegionCache": {
                this.process_updateRegionCache(requestId, input, output);
                return;
            }
            case "process_createFunction": {
                this.process_createFunction(requestId, input, output);
                return;
            }
            case "process_dropFunction": {
                this.process_dropFunction(requestId, input, output);
                return;
            }
            case "process_createTriggerInstance": {
                this.process_createTriggerInstance(requestId, input, output);
                return;
            }
            case "process_activeTriggerInstance": {
                this.process_activeTriggerInstance(requestId, input, output);
                return;
            }
            case "process_inactiveTriggerInstance": {
                this.process_inactiveTriggerInstance(requestId, input, output);
                return;
            }
            case "process_dropTriggerInstance": {
                this.process_dropTriggerInstance(requestId, input, output);
                return;
            }
            case "process_updateTriggerLocation": {
                this.process_updateTriggerLocation(requestId, input, output);
                return;
            }
            case "process_fireTrigger": {
                this.process_fireTrigger(requestId, input, output);
                return;
            }
            case "process_invalidatePermissionCache": {
                this.process_invalidatePermissionCache(requestId, input, output);
                return;
            }
            case "process_createPipePlugin": {
                this.process_createPipePlugin(requestId, input, output);
                return;
            }
            case "process_dropPipePlugin": {
                this.process_dropPipePlugin(requestId, input, output);
                return;
            }
            case "process_merge": {
                this.process_merge(requestId, input, output);
                return;
            }
            case "process_flush": {
                this.process_flush(requestId, input, output);
                return;
            }
            case "process_settle": {
                this.process_settle(requestId, input, output);
                return;
            }
            case "process_startRepairData": {
                this.process_startRepairData(requestId, input, output);
                return;
            }
            case "process_stopRepairData": {
                this.process_stopRepairData(requestId, input, output);
                return;
            }
            case "process_clearCache": {
                this.process_clearCache(requestId, input, output);
                return;
            }
            case "process_showConfiguration": {
                this.process_showConfiguration(requestId, input, output);
                return;
            }
            case "process_setConfiguration": {
                this.process_setConfiguration(requestId, input, output);
                return;
            }
            case "process_loadConfiguration": {
                this.process_loadConfiguration(requestId, input, output);
                return;
            }
            case "process_setSystemStatus": {
                this.process_setSystemStatus(requestId, input, output);
                return;
            }
            case "process_killQueryInstance": {
                this.process_killQueryInstance(requestId, input, output);
                return;
            }
            case "process_setTTL": {
                this.process_setTTL(requestId, input, output);
                return;
            }
            case "process_updateTemplate": {
                this.process_updateTemplate(requestId, input, output);
                return;
            }
            case "process_constructSchemaBlackList": {
                this.process_constructSchemaBlackList(requestId, input, output);
                return;
            }
            case "process_rollbackSchemaBlackList": {
                this.process_rollbackSchemaBlackList(requestId, input, output);
                return;
            }
            case "process_invalidateMatchedSchemaCache": {
                this.process_invalidateMatchedSchemaCache(requestId, input, output);
                return;
            }
            case "process_fetchSchemaBlackList": {
                this.process_fetchSchemaBlackList(requestId, input, output);
                return;
            }
            case "process_deleteDataForDeleteSchema": {
                this.process_deleteDataForDeleteSchema(requestId, input, output);
                return;
            }
            case "process_deleteTimeSeries": {
                this.process_deleteTimeSeries(requestId, input, output);
                return;
            }
            case "process_constructSchemaBlackListWithTemplate": {
                this.process_constructSchemaBlackListWithTemplate(requestId, input, output);
                return;
            }
            case "process_rollbackSchemaBlackListWithTemplate": {
                this.process_rollbackSchemaBlackListWithTemplate(requestId, input, output);
                return;
            }
            case "process_deactivateTemplate": {
                this.process_deactivateTemplate(requestId, input, output);
                return;
            }
            case "process_countPathsUsingTemplate": {
                this.process_countPathsUsingTemplate(requestId, input, output);
                return;
            }
            case "process_checkSchemaRegionUsingTemplate": {
                this.process_checkSchemaRegionUsingTemplate(requestId, input, output);
                return;
            }
            case "process_checkTimeSeriesExistence": {
                this.process_checkTimeSeriesExistence(requestId, input, output);
                return;
            }
            case "process_constructViewSchemaBlackList": {
                this.process_constructViewSchemaBlackList(requestId, input, output);
                return;
            }
            case "process_rollbackViewSchemaBlackList": {
                this.process_rollbackViewSchemaBlackList(requestId, input, output);
                return;
            }
            case "process_deleteViewSchema": {
                this.process_deleteViewSchema(requestId, input, output);
                return;
            }
            case "process_alterView": {
                this.process_alterView(requestId, input, output);
                return;
            }
            case "process_pushPipeMeta": {
                this.process_pushPipeMeta(requestId, input, output);
                return;
            }
            case "process_pushSinglePipeMeta": {
                this.process_pushSinglePipeMeta(requestId, input, output);
                return;
            }
            case "process_pushMultiPipeMeta": {
                this.process_pushMultiPipeMeta(requestId, input, output);
                return;
            }
            case "process_pushTopicMeta": {
                this.process_pushTopicMeta(requestId, input, output);
                return;
            }
            case "process_pushSingleTopicMeta": {
                this.process_pushSingleTopicMeta(requestId, input, output);
                return;
            }
            case "process_pushMultiTopicMeta": {
                this.process_pushMultiTopicMeta(requestId, input, output);
                return;
            }
            case "process_pushConsumerGroupMeta": {
                this.process_pushConsumerGroupMeta(requestId, input, output);
                return;
            }
            case "process_pushSingleConsumerGroupMeta": {
                this.process_pushSingleConsumerGroupMeta(requestId, input, output);
                return;
            }
            case "process_pipeHeartbeat": {
                this.process_pipeHeartbeat(requestId, input, output);
                return;
            }
            case "process_executeCQ": {
                this.process_executeCQ(requestId, input, output);
                return;
            }
            case "process_setSpaceQuota": {
                this.process_setSpaceQuota(requestId, input, output);
                return;
            }
            case "process_setThrottleQuota": {
                this.process_setThrottleQuota(requestId, input, output);
                return;
            }
            case "process_fetchFragmentInstanceStatistics": {
                this.process_fetchFragmentInstanceStatistics(requestId, input, output);
                return;
            }
            case "process_updateTable": {
                this.process_updateTable(requestId, input, output);
                return;
            }
            case "process_invalidateTableCache": {
                this.process_invalidateTableCache(requestId, input, output);
                return;
            }
            case "process_deleteDataForDropTable": {
                this.process_deleteDataForDropTable(requestId, input, output);
                return;
            }
            case "process_deleteDevicesForDropTable": {
                this.process_deleteDevicesForDropTable(requestId, input, output);
                return;
            }
            case "process_invalidateColumnCache": {
                this.process_invalidateColumnCache(requestId, input, output);
                return;
            }
            case "process_deleteColumnData": {
                this.process_deleteColumnData(requestId, input, output);
                return;
            }
            case "process_constructTableDeviceBlackList": {
                this.process_constructTableDeviceBlackList(requestId, input, output);
                return;
            }
            case "process_rollbackTableDeviceBlackList": {
                this.process_rollbackTableDeviceBlackList(requestId, input, output);
                return;
            }
            case "process_invalidateMatchedTableDeviceCache": {
                this.process_invalidateMatchedTableDeviceCache(requestId, input, output);
                return;
            }
            case "process_deleteDataForTableDevice": {
                this.process_deleteDataForTableDevice(requestId, input, output);
                return;
            }
            case "process_deleteTableDeviceInBlackList": {
                this.process_deleteTableDeviceInBlackList(requestId, input, output);
                return;
            }
            case "process_submitTestConnectionTask": {
                this.process_submitTestConnectionTask(requestId, input, output);
                return;
            }
            case "process_submitInternalTestConnectionTask": {
                this.process_submitInternalTestConnectionTask(requestId, input, output);
                return;
            }
            case "process_testConnectionEmptyRPC": {
                this.process_testConnectionEmptyRPC(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_sendFragmentInstance(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSendFragmentInstanceResp.TSendFragmentInstanceResp>((resolve, reject): void => {
            try {
                const args: SendFragmentInstanceArgs = SendFragmentInstanceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.sendFragmentInstance(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSendFragmentInstanceResp.TSendFragmentInstanceResp): void => {
            const result: SendFragmentInstanceResult = new SendFragmentInstanceResult({ success: data });
            output.writeMessageBegin("sendFragmentInstance", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("sendFragmentInstance", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_sendBatchPlanNode(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSendBatchPlanNodeResp.TSendBatchPlanNodeResp>((resolve, reject): void => {
            try {
                const args: SendBatchPlanNodeArgs = SendBatchPlanNodeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.sendBatchPlanNode(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSendBatchPlanNodeResp.TSendBatchPlanNodeResp): void => {
            const result: SendBatchPlanNodeResult = new SendBatchPlanNodeResult({ success: data });
            output.writeMessageBegin("sendBatchPlanNode", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("sendBatchPlanNode", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchFragmentInstanceInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TFragmentInstanceInfoResp.TFragmentInstanceInfoResp>((resolve, reject): void => {
            try {
                const args: FetchFragmentInstanceInfoArgs = FetchFragmentInstanceInfoArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.fetchFragmentInstanceInfo(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TFragmentInstanceInfoResp.TFragmentInstanceInfoResp): void => {
            const result: FetchFragmentInstanceInfoResult = new FetchFragmentInstanceInfoResult({ success: data });
            output.writeMessageBegin("fetchFragmentInstanceInfo", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchFragmentInstanceInfo", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_cancelQuery(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TCancelResp.TCancelResp>((resolve, reject): void => {
            try {
                const args: CancelQueryArgs = CancelQueryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cancelQuery(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TCancelResp.TCancelResp): void => {
            const result: CancelQueryResult = new CancelQueryResult({ success: data });
            output.writeMessageBegin("cancelQuery", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("cancelQuery", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_cancelPlanFragment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TCancelResp.TCancelResp>((resolve, reject): void => {
            try {
                const args: CancelPlanFragmentArgs = CancelPlanFragmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cancelPlanFragment(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TCancelResp.TCancelResp): void => {
            const result: CancelPlanFragmentResult = new CancelPlanFragmentResult({ success: data });
            output.writeMessageBegin("cancelPlanFragment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("cancelPlanFragment", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_cancelFragmentInstance(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TCancelResp.TCancelResp>((resolve, reject): void => {
            try {
                const args: CancelFragmentInstanceArgs = CancelFragmentInstanceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cancelFragmentInstance(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TCancelResp.TCancelResp): void => {
            const result: CancelFragmentInstanceResult = new CancelFragmentInstanceResult({ success: data });
            output.writeMessageBegin("cancelFragmentInstance", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("cancelFragmentInstance", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchSchema(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TSchemaFetchResponse.TSchemaFetchResponse>((resolve, reject): void => {
            try {
                const args: FetchSchemaArgs = FetchSchemaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.fetchSchema(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TSchemaFetchResponse.TSchemaFetchResponse): void => {
            const result: FetchSchemaResult = new FetchSchemaResult({ success: data });
            output.writeMessageBegin("fetchSchema", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchSchema", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_sendTsFilePieceNode(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TLoadResp.TLoadResp>((resolve, reject): void => {
            try {
                const args: SendTsFilePieceNodeArgs = SendTsFilePieceNodeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.sendTsFilePieceNode(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TLoadResp.TLoadResp): void => {
            const result: SendTsFilePieceNodeResult = new SendTsFilePieceNodeResult({ success: data });
            output.writeMessageBegin("sendTsFilePieceNode", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("sendTsFilePieceNode", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_sendLoadCommand(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TLoadResp.TLoadResp>((resolve, reject): void => {
            try {
                const args: SendLoadCommandArgs = SendLoadCommandArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.sendLoadCommand(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TLoadResp.TLoadResp): void => {
            const result: SendLoadCommandResult = new SendLoadCommandResult({ success: data });
            output.writeMessageBegin("sendLoadCommand", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("sendLoadCommand", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_updateAttribute(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: UpdateAttributeArgs = UpdateAttributeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateAttribute(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: UpdateAttributeResult = new UpdateAttributeResult({ success: data });
            output.writeMessageBegin("updateAttribute", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("updateAttribute", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createSchemaRegion(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateSchemaRegionArgs = CreateSchemaRegionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createSchemaRegion(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateSchemaRegionResult = new CreateSchemaRegionResult({ success: data });
            output.writeMessageBegin("createSchemaRegion", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createSchemaRegion", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createDataRegion(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateDataRegionArgs = CreateDataRegionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createDataRegion(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateDataRegionResult = new CreateDataRegionResult({ success: data });
            output.writeMessageBegin("createDataRegion", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createDataRegion", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidatePartitionCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidatePartitionCacheArgs = InvalidatePartitionCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidatePartitionCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidatePartitionCacheResult = new InvalidatePartitionCacheResult({ success: data });
            output.writeMessageBegin("invalidatePartitionCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidatePartitionCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidateLastCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidateLastCacheArgs = InvalidateLastCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidateLastCache(args.database));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidateLastCacheResult = new InvalidateLastCacheResult({ success: data });
            output.writeMessageBegin("invalidateLastCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidateLastCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidateSchemaCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidateSchemaCacheArgs = InvalidateSchemaCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidateSchemaCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidateSchemaCacheResult = new InvalidateSchemaCacheResult({ success: data });
            output.writeMessageBegin("invalidateSchemaCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidateSchemaCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteRegion(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteRegionArgs = DeleteRegionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteRegion(args.consensusGroupId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteRegionResult = new DeleteRegionResult({ success: data });
            output.writeMessageBegin("deleteRegion", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteRegion", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_changeRegionLeader(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TRegionLeaderChangeResp.TRegionLeaderChangeResp>((resolve, reject): void => {
            try {
                const args: ChangeRegionLeaderArgs = ChangeRegionLeaderArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeRegionLeader(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TRegionLeaderChangeResp.TRegionLeaderChangeResp): void => {
            const result: ChangeRegionLeaderResult = new ChangeRegionLeaderResult({ success: data });
            output.writeMessageBegin("changeRegionLeader", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("changeRegionLeader", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createNewRegionPeer(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateNewRegionPeerArgs = CreateNewRegionPeerArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createNewRegionPeer(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateNewRegionPeerResult = new CreateNewRegionPeerResult({ success: data });
            output.writeMessageBegin("createNewRegionPeer", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createNewRegionPeer", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_addRegionPeer(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: AddRegionPeerArgs = AddRegionPeerArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addRegionPeer(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: AddRegionPeerResult = new AddRegionPeerResult({ success: data });
            output.writeMessageBegin("addRegionPeer", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("addRegionPeer", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_removeRegionPeer(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: RemoveRegionPeerArgs = RemoveRegionPeerArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeRegionPeer(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: RemoveRegionPeerResult = new RemoveRegionPeerResult({ success: data });
            output.writeMessageBegin("removeRegionPeer", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("removeRegionPeer", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteOldRegionPeer(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteOldRegionPeerArgs = DeleteOldRegionPeerArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteOldRegionPeer(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteOldRegionPeerResult = new DeleteOldRegionPeerResult({ success: data });
            output.writeMessageBegin("deleteOldRegionPeer", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteOldRegionPeer", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_resetPeerList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ResetPeerListArgs = ResetPeerListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.resetPeerList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ResetPeerListResult = new ResetPeerListResult({ success: data });
            output.writeMessageBegin("resetPeerList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("resetPeerList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getRegionMaintainResult(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TRegionMigrateResult.TRegionMigrateResult>((resolve, reject): void => {
            try {
                const args: GetRegionMaintainResultArgs = GetRegionMaintainResultArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getRegionMaintainResult(args.taskId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TRegionMigrateResult.TRegionMigrateResult): void => {
            const result: GetRegionMaintainResultResult = new GetRegionMaintainResultResult({ success: data });
            output.writeMessageBegin("getRegionMaintainResult", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getRegionMaintainResult", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_notifyRegionMigration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: NotifyRegionMigrationArgs = NotifyRegionMigrationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.notifyRegionMigration(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: NotifyRegionMigrationResult = new NotifyRegionMigrationResult({ success: data });
            output.writeMessageBegin("notifyRegionMigration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("notifyRegionMigration", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_cleanDataNodeCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CleanDataNodeCacheArgs = CleanDataNodeCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cleanDataNodeCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CleanDataNodeCacheResult = new CleanDataNodeCacheResult({ success: data });
            output.writeMessageBegin("cleanDataNodeCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("cleanDataNodeCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_stopAndClearDataNode(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.stopAndClearDataNode());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: StopAndClearDataNodeResult = new StopAndClearDataNodeResult({ success: data });
            output.writeMessageBegin("stopAndClearDataNode", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("stopAndClearDataNode", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getDataNodeHeartBeat(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TDataNodeHeartbeatResp.TDataNodeHeartbeatResp>((resolve, reject): void => {
            try {
                const args: GetDataNodeHeartBeatArgs = GetDataNodeHeartBeatArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDataNodeHeartBeat(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TDataNodeHeartbeatResp.TDataNodeHeartbeatResp): void => {
            const result: GetDataNodeHeartBeatResult = new GetDataNodeHeartBeatResult({ success: data });
            output.writeMessageBegin("getDataNodeHeartBeat", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getDataNodeHeartBeat", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_updateRegionCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: UpdateRegionCacheArgs = UpdateRegionCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateRegionCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: UpdateRegionCacheResult = new UpdateRegionCacheResult({ success: data });
            output.writeMessageBegin("updateRegionCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("updateRegionCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createFunction(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateFunctionArgs = CreateFunctionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createFunction(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateFunctionResult = new CreateFunctionResult({ success: data });
            output.writeMessageBegin("createFunction", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createFunction", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_dropFunction(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DropFunctionArgs = DropFunctionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.dropFunction(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DropFunctionResult = new DropFunctionResult({ success: data });
            output.writeMessageBegin("dropFunction", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("dropFunction", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createTriggerInstance(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreateTriggerInstanceArgs = CreateTriggerInstanceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createTriggerInstance(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreateTriggerInstanceResult = new CreateTriggerInstanceResult({ success: data });
            output.writeMessageBegin("createTriggerInstance", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createTriggerInstance", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_activeTriggerInstance(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ActiveTriggerInstanceArgs = ActiveTriggerInstanceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.activeTriggerInstance(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ActiveTriggerInstanceResult = new ActiveTriggerInstanceResult({ success: data });
            output.writeMessageBegin("activeTriggerInstance", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("activeTriggerInstance", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_inactiveTriggerInstance(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InactiveTriggerInstanceArgs = InactiveTriggerInstanceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.inactiveTriggerInstance(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InactiveTriggerInstanceResult = new InactiveTriggerInstanceResult({ success: data });
            output.writeMessageBegin("inactiveTriggerInstance", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("inactiveTriggerInstance", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_dropTriggerInstance(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DropTriggerInstanceArgs = DropTriggerInstanceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.dropTriggerInstance(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DropTriggerInstanceResult = new DropTriggerInstanceResult({ success: data });
            output.writeMessageBegin("dropTriggerInstance", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("dropTriggerInstance", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_updateTriggerLocation(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: UpdateTriggerLocationArgs = UpdateTriggerLocationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateTriggerLocation(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: UpdateTriggerLocationResult = new UpdateTriggerLocationResult({ success: data });
            output.writeMessageBegin("updateTriggerLocation", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("updateTriggerLocation", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fireTrigger(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TFireTriggerResp.TFireTriggerResp>((resolve, reject): void => {
            try {
                const args: FireTriggerArgs = FireTriggerArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.fireTrigger(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TFireTriggerResp.TFireTriggerResp): void => {
            const result: FireTriggerResult = new FireTriggerResult({ success: data });
            output.writeMessageBegin("fireTrigger", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fireTrigger", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidatePermissionCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidatePermissionCacheArgs = InvalidatePermissionCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidatePermissionCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidatePermissionCacheResult = new InvalidatePermissionCacheResult({ success: data });
            output.writeMessageBegin("invalidatePermissionCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidatePermissionCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_createPipePlugin(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: CreatePipePluginArgs = CreatePipePluginArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createPipePlugin(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: CreatePipePluginResult = new CreatePipePluginResult({ success: data });
            output.writeMessageBegin("createPipePlugin", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("createPipePlugin", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_dropPipePlugin(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DropPipePluginArgs = DropPipePluginArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.dropPipePlugin(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DropPipePluginResult = new DropPipePluginResult({ success: data });
            output.writeMessageBegin("dropPipePlugin", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("dropPipePlugin", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_merge(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.merge());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: MergeResult = new MergeResult({ success: data });
            output.writeMessageBegin("merge", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("merge", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_flush(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: FlushArgs = FlushArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.flush(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: FlushResult = new FlushResult({ success: data });
            output.writeMessageBegin("flush", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("flush", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_settle(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SettleArgs = SettleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.settle(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SettleResult = new SettleResult({ success: data });
            output.writeMessageBegin("settle", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("settle", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_startRepairData(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.startRepairData());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: StartRepairDataResult = new StartRepairDataResult({ success: data });
            output.writeMessageBegin("startRepairData", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("startRepairData", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_stopRepairData(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.stopRepairData());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: StopRepairDataResult = new StopRepairDataResult({ success: data });
            output.writeMessageBegin("stopRepairData", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("stopRepairData", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_clearCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ClearCacheArgs = ClearCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.clearCache(args.cacheClearOptions));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ClearCacheResult = new ClearCacheResult({ success: data });
            output.writeMessageBegin("clearCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("clearCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_showConfiguration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.showConfiguration());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TShowConfigurationResp): void => {
            const result: ShowConfigurationResult = new ShowConfigurationResult({ success: data });
            output.writeMessageBegin("showConfiguration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("showConfiguration", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setConfiguration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetConfigurationArgs = SetConfigurationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setConfiguration(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetConfigurationResult = new SetConfigurationResult({ success: data });
            output.writeMessageBegin("setConfiguration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setConfiguration", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_loadConfiguration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.loadConfiguration());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: LoadConfigurationResult = new LoadConfigurationResult({ success: data });
            output.writeMessageBegin("loadConfiguration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("loadConfiguration", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setSystemStatus(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetSystemStatusArgs = SetSystemStatusArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setSystemStatus(args.status));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetSystemStatusResult = new SetSystemStatusResult({ success: data });
            output.writeMessageBegin("setSystemStatus", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setSystemStatus", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_killQueryInstance(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: KillQueryInstanceArgs = KillQueryInstanceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.killQueryInstance(args.queryId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: KillQueryInstanceResult = new KillQueryInstanceResult({ success: data });
            output.writeMessageBegin("killQueryInstance", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("killQueryInstance", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setTTL(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetTTLArgs = SetTTLArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setTTL(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetTTLResult = new SetTTLResult({ success: data });
            output.writeMessageBegin("setTTL", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setTTL", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_updateTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: UpdateTemplateArgs = UpdateTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: UpdateTemplateResult = new UpdateTemplateResult({ success: data });
            output.writeMessageBegin("updateTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("updateTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_constructSchemaBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ConstructSchemaBlackListArgs = ConstructSchemaBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.constructSchemaBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ConstructSchemaBlackListResult = new ConstructSchemaBlackListResult({ success: data });
            output.writeMessageBegin("constructSchemaBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("constructSchemaBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_rollbackSchemaBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: RollbackSchemaBlackListArgs = RollbackSchemaBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.rollbackSchemaBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: RollbackSchemaBlackListResult = new RollbackSchemaBlackListResult({ success: data });
            output.writeMessageBegin("rollbackSchemaBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("rollbackSchemaBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidateMatchedSchemaCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidateMatchedSchemaCacheArgs = InvalidateMatchedSchemaCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidateMatchedSchemaCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidateMatchedSchemaCacheResult = new InvalidateMatchedSchemaCacheResult({ success: data });
            output.writeMessageBegin("invalidateMatchedSchemaCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidateMatchedSchemaCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchSchemaBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TFetchSchemaBlackListResp.TFetchSchemaBlackListResp>((resolve, reject): void => {
            try {
                const args: FetchSchemaBlackListArgs = FetchSchemaBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.fetchSchemaBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TFetchSchemaBlackListResp.TFetchSchemaBlackListResp): void => {
            const result: FetchSchemaBlackListResult = new FetchSchemaBlackListResult({ success: data });
            output.writeMessageBegin("fetchSchemaBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchSchemaBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteDataForDeleteSchema(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteDataForDeleteSchemaArgs = DeleteDataForDeleteSchemaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteDataForDeleteSchema(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteDataForDeleteSchemaResult = new DeleteDataForDeleteSchemaResult({ success: data });
            output.writeMessageBegin("deleteDataForDeleteSchema", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteDataForDeleteSchema", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteTimeSeries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteTimeSeriesArgs = DeleteTimeSeriesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteTimeSeries(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteTimeSeriesResult = new DeleteTimeSeriesResult({ success: data });
            output.writeMessageBegin("deleteTimeSeries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteTimeSeries", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_constructSchemaBlackListWithTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ConstructSchemaBlackListWithTemplateArgs = ConstructSchemaBlackListWithTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.constructSchemaBlackListWithTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ConstructSchemaBlackListWithTemplateResult = new ConstructSchemaBlackListWithTemplateResult({ success: data });
            output.writeMessageBegin("constructSchemaBlackListWithTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("constructSchemaBlackListWithTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_rollbackSchemaBlackListWithTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: RollbackSchemaBlackListWithTemplateArgs = RollbackSchemaBlackListWithTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.rollbackSchemaBlackListWithTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: RollbackSchemaBlackListWithTemplateResult = new RollbackSchemaBlackListWithTemplateResult({ success: data });
            output.writeMessageBegin("rollbackSchemaBlackListWithTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("rollbackSchemaBlackListWithTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deactivateTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeactivateTemplateArgs = DeactivateTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deactivateTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeactivateTemplateResult = new DeactivateTemplateResult({ success: data });
            output.writeMessageBegin("deactivateTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deactivateTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_countPathsUsingTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp>((resolve, reject): void => {
            try {
                const args: CountPathsUsingTemplateArgs = CountPathsUsingTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.countPathsUsingTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TCountPathsUsingTemplateResp.TCountPathsUsingTemplateResp): void => {
            const result: CountPathsUsingTemplateResult = new CountPathsUsingTemplateResult({ success: data });
            output.writeMessageBegin("countPathsUsingTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("countPathsUsingTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_checkSchemaRegionUsingTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp>((resolve, reject): void => {
            try {
                const args: CheckSchemaRegionUsingTemplateArgs = CheckSchemaRegionUsingTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.checkSchemaRegionUsingTemplate(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TCheckSchemaRegionUsingTemplateResp.TCheckSchemaRegionUsingTemplateResp): void => {
            const result: CheckSchemaRegionUsingTemplateResult = new CheckSchemaRegionUsingTemplateResult({ success: data });
            output.writeMessageBegin("checkSchemaRegionUsingTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("checkSchemaRegionUsingTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_checkTimeSeriesExistence(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp>((resolve, reject): void => {
            try {
                const args: CheckTimeSeriesExistenceArgs = CheckTimeSeriesExistenceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.checkTimeSeriesExistence(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TCheckTimeSeriesExistenceResp.TCheckTimeSeriesExistenceResp): void => {
            const result: CheckTimeSeriesExistenceResult = new CheckTimeSeriesExistenceResult({ success: data });
            output.writeMessageBegin("checkTimeSeriesExistence", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("checkTimeSeriesExistence", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_constructViewSchemaBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ConstructViewSchemaBlackListArgs = ConstructViewSchemaBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.constructViewSchemaBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ConstructViewSchemaBlackListResult = new ConstructViewSchemaBlackListResult({ success: data });
            output.writeMessageBegin("constructViewSchemaBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("constructViewSchemaBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_rollbackViewSchemaBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: RollbackViewSchemaBlackListArgs = RollbackViewSchemaBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.rollbackViewSchemaBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: RollbackViewSchemaBlackListResult = new RollbackViewSchemaBlackListResult({ success: data });
            output.writeMessageBegin("rollbackViewSchemaBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("rollbackViewSchemaBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteViewSchema(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteViewSchemaArgs = DeleteViewSchemaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteViewSchema(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteViewSchemaResult = new DeleteViewSchemaResult({ success: data });
            output.writeMessageBegin("deleteViewSchema", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteViewSchema", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_alterView(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: AlterViewArgs = AlterViewArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.alterView(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: AlterViewResult = new AlterViewResult({ success: data });
            output.writeMessageBegin("alterView", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("alterView", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushPipeMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushPipeMetaResp.TPushPipeMetaResp>((resolve, reject): void => {
            try {
                const args: PushPipeMetaArgs = PushPipeMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushPipeMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushPipeMetaResp.TPushPipeMetaResp): void => {
            const result: PushPipeMetaResult = new PushPipeMetaResult({ success: data });
            output.writeMessageBegin("pushPipeMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushPipeMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushSinglePipeMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushPipeMetaResp.TPushPipeMetaResp>((resolve, reject): void => {
            try {
                const args: PushSinglePipeMetaArgs = PushSinglePipeMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushSinglePipeMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushPipeMetaResp.TPushPipeMetaResp): void => {
            const result: PushSinglePipeMetaResult = new PushSinglePipeMetaResult({ success: data });
            output.writeMessageBegin("pushSinglePipeMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushSinglePipeMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushMultiPipeMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushPipeMetaResp.TPushPipeMetaResp>((resolve, reject): void => {
            try {
                const args: PushMultiPipeMetaArgs = PushMultiPipeMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushMultiPipeMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushPipeMetaResp.TPushPipeMetaResp): void => {
            const result: PushMultiPipeMetaResult = new PushMultiPipeMetaResult({ success: data });
            output.writeMessageBegin("pushMultiPipeMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushMultiPipeMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushTopicMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushTopicMetaResp.TPushTopicMetaResp>((resolve, reject): void => {
            try {
                const args: PushTopicMetaArgs = PushTopicMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushTopicMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushTopicMetaResp.TPushTopicMetaResp): void => {
            const result: PushTopicMetaResult = new PushTopicMetaResult({ success: data });
            output.writeMessageBegin("pushTopicMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushTopicMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushSingleTopicMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushTopicMetaResp.TPushTopicMetaResp>((resolve, reject): void => {
            try {
                const args: PushSingleTopicMetaArgs = PushSingleTopicMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushSingleTopicMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushTopicMetaResp.TPushTopicMetaResp): void => {
            const result: PushSingleTopicMetaResult = new PushSingleTopicMetaResult({ success: data });
            output.writeMessageBegin("pushSingleTopicMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushSingleTopicMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushMultiTopicMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushTopicMetaResp.TPushTopicMetaResp>((resolve, reject): void => {
            try {
                const args: PushMultiTopicMetaArgs = PushMultiTopicMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushMultiTopicMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushTopicMetaResp.TPushTopicMetaResp): void => {
            const result: PushMultiTopicMetaResult = new PushMultiTopicMetaResult({ success: data });
            output.writeMessageBegin("pushMultiTopicMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushMultiTopicMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushConsumerGroupMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp>((resolve, reject): void => {
            try {
                const args: PushConsumerGroupMetaArgs = PushConsumerGroupMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushConsumerGroupMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp): void => {
            const result: PushConsumerGroupMetaResult = new PushConsumerGroupMetaResult({ success: data });
            output.writeMessageBegin("pushConsumerGroupMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushConsumerGroupMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pushSingleConsumerGroupMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp>((resolve, reject): void => {
            try {
                const args: PushSingleConsumerGroupMetaArgs = PushSingleConsumerGroupMetaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pushSingleConsumerGroupMeta(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPushConsumerGroupMetaResp.TPushConsumerGroupMetaResp): void => {
            const result: PushSingleConsumerGroupMetaResult = new PushSingleConsumerGroupMetaResult({ success: data });
            output.writeMessageBegin("pushSingleConsumerGroupMeta", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pushSingleConsumerGroupMeta", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_pipeHeartbeat(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TPipeHeartbeatResp.TPipeHeartbeatResp>((resolve, reject): void => {
            try {
                const args: PipeHeartbeatArgs = PipeHeartbeatArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pipeHeartbeat(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TPipeHeartbeatResp.TPipeHeartbeatResp): void => {
            const result: PipeHeartbeatResult = new PipeHeartbeatResult({ success: data });
            output.writeMessageBegin("pipeHeartbeat", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("pipeHeartbeat", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_executeCQ(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ExecuteCQArgs = ExecuteCQArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeCQ(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ExecuteCQResult = new ExecuteCQResult({ success: data });
            output.writeMessageBegin("executeCQ", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("executeCQ", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setSpaceQuota(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetSpaceQuotaArgs = SetSpaceQuotaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setSpaceQuota(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetSpaceQuotaResult = new SetSpaceQuotaResult({ success: data });
            output.writeMessageBegin("setSpaceQuota", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setSpaceQuota", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_setThrottleQuota(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: SetThrottleQuotaArgs = SetThrottleQuotaArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setThrottleQuota(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: SetThrottleQuotaResult = new SetThrottleQuotaResult({ success: data });
            output.writeMessageBegin("setThrottleQuota", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("setThrottleQuota", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_fetchFragmentInstanceStatistics(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp>((resolve, reject): void => {
            try {
                const args: FetchFragmentInstanceStatisticsArgs = FetchFragmentInstanceStatisticsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.fetchFragmentInstanceStatistics(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: TFetchFragmentInstanceStatisticsResp.TFetchFragmentInstanceStatisticsResp): void => {
            const result: FetchFragmentInstanceStatisticsResult = new FetchFragmentInstanceStatisticsResult({ success: data });
            output.writeMessageBegin("fetchFragmentInstanceStatistics", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("fetchFragmentInstanceStatistics", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_updateTable(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: UpdateTableArgs = UpdateTableArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateTable(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: UpdateTableResult = new UpdateTableResult({ success: data });
            output.writeMessageBegin("updateTable", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("updateTable", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidateTableCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidateTableCacheArgs = InvalidateTableCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidateTableCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidateTableCacheResult = new InvalidateTableCacheResult({ success: data });
            output.writeMessageBegin("invalidateTableCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidateTableCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteDataForDropTable(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteDataForDropTableArgs = DeleteDataForDropTableArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteDataForDropTable(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteDataForDropTableResult = new DeleteDataForDropTableResult({ success: data });
            output.writeMessageBegin("deleteDataForDropTable", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteDataForDropTable", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteDevicesForDropTable(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteDevicesForDropTableArgs = DeleteDevicesForDropTableArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteDevicesForDropTable(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteDevicesForDropTableResult = new DeleteDevicesForDropTableResult({ success: data });
            output.writeMessageBegin("deleteDevicesForDropTable", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteDevicesForDropTable", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidateColumnCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidateColumnCacheArgs = InvalidateColumnCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidateColumnCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidateColumnCacheResult = new InvalidateColumnCacheResult({ success: data });
            output.writeMessageBegin("invalidateColumnCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidateColumnCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteColumnData(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteColumnDataArgs = DeleteColumnDataArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteColumnData(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteColumnDataResult = new DeleteColumnDataResult({ success: data });
            output.writeMessageBegin("deleteColumnData", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteColumnData", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_constructTableDeviceBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: ConstructTableDeviceBlackListArgs = ConstructTableDeviceBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.constructTableDeviceBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: ConstructTableDeviceBlackListResult = new ConstructTableDeviceBlackListResult({ success: data });
            output.writeMessageBegin("constructTableDeviceBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("constructTableDeviceBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_rollbackTableDeviceBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: RollbackTableDeviceBlackListArgs = RollbackTableDeviceBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.rollbackTableDeviceBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: RollbackTableDeviceBlackListResult = new RollbackTableDeviceBlackListResult({ success: data });
            output.writeMessageBegin("rollbackTableDeviceBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("rollbackTableDeviceBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_invalidateMatchedTableDeviceCache(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: InvalidateMatchedTableDeviceCacheArgs = InvalidateMatchedTableDeviceCacheArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.invalidateMatchedTableDeviceCache(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: InvalidateMatchedTableDeviceCacheResult = new InvalidateMatchedTableDeviceCacheResult({ success: data });
            output.writeMessageBegin("invalidateMatchedTableDeviceCache", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("invalidateMatchedTableDeviceCache", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteDataForTableDevice(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteDataForTableDeviceArgs = DeleteDataForTableDeviceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteDataForTableDevice(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteDataForTableDeviceResult = new DeleteDataForTableDeviceResult({ success: data });
            output.writeMessageBegin("deleteDataForTableDevice", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteDataForTableDevice", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_deleteTableDeviceInBlackList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                const args: DeleteTableDeviceInBlackListArgs = DeleteTableDeviceInBlackListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteTableDeviceInBlackList(args.req));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: DeleteTableDeviceInBlackListResult = new DeleteTableDeviceInBlackListResult({ success: data });
            output.writeMessageBegin("deleteTableDeviceInBlackList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("deleteTableDeviceInBlackList", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_submitTestConnectionTask(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp>((resolve, reject): void => {
            try {
                const args: SubmitTestConnectionTaskArgs = SubmitTestConnectionTaskArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.submitTestConnectionTask(args.nodeLocations));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp): void => {
            const result: SubmitTestConnectionTaskResult = new SubmitTestConnectionTaskResult({ success: data });
            output.writeMessageBegin("submitTestConnectionTask", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("submitTestConnectionTask", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_submitInternalTestConnectionTask(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TTestConnectionResp>((resolve, reject): void => {
            try {
                const args: SubmitInternalTestConnectionTaskArgs = SubmitInternalTestConnectionTaskArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.submitInternalTestConnectionTask(args.nodeLocations));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TTestConnectionResp): void => {
            const result: SubmitInternalTestConnectionTaskResult = new SubmitInternalTestConnectionTaskResult({ success: data });
            output.writeMessageBegin("submitInternalTestConnectionTask", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("submitInternalTestConnectionTask", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_testConnectionEmptyRPC(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<org_apache_iotdb_common_rpc_thrift.TSStatus>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.testConnectionEmptyRPC());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: org_apache_iotdb_common_rpc_thrift.TSStatus): void => {
            const result: TestConnectionEmptyRPCResult = new TestConnectionEmptyRPCResult({ success: data });
            output.writeMessageBegin("testConnectionEmptyRPC", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("testConnectionEmptyRPC", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
}
